commit cc76de28cf588e463628f9b8b1fff5389c5bbfb8
Author: lexicalmathical <lexicalmathical@gmail.com>
Date:   Sun Nov 2 17:01:31 2025 +0800

    Fix calendar display after migration - load from database when authenticated
    
    Changes:
    - CalendarPopup.tsx now loads calendar entries from database when authenticated
    - Falls back to localStorage for guest mode
    - Delete operations also database-aware
    - Fixes issue where calendar appeared empty after successful migration
    
    ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

diff --git a/backend/data/ink-and-memory.db b/backend/data/ink-and-memory.db
index 6de16bb..0bf47a7 100644
Binary files a/backend/data/ink-and-memory.db and b/backend/data/ink-and-memory.db differ
diff --git a/frontend/src/App.tsx b/frontend/src/App.tsx
index eb4a196..5582ee9 100644
--- a/frontend/src/App.tsx
+++ b/frontend/src/App.tsx
@@ -370,6 +370,8 @@ export default function App() {
 
   // @@@ Check for localStorage migration after login
   useEffect(() => {
+    console.log('ðŸ” Migration check:', { isAuthenticated, isLoading });
+
     if (isAuthenticated && !isLoading) {
       // Check if user has localStorage data that needs migration
       const hasLocalData =
@@ -385,7 +387,24 @@ export default function App() {
       // Check if migration already done (flag stored after migration)
       const migrationDone = localStorage.getItem(STORAGE_KEYS.MIGRATION_COMPLETED);
 
+      console.log('ðŸ“¦ Migration status:', {
+        hasLocalData: !!hasLocalData,
+        migrationDone: !!migrationDone,
+        editorState: !!localStorage.getItem(STORAGE_KEYS.EDITOR_STATE),
+        calendarEntries: !!localStorage.getItem(STORAGE_KEYS.CALENDAR_ENTRIES),
+        dailyPictures: !!localStorage.getItem(STORAGE_KEYS.DAILY_PICTURES)
+      });
+
+      // @@@ TEMPORARY: Force re-migration if calendar entries exist but weren't imported
+      // Check if calendar entries exist but no sessions in database (migration failed)
+      const hasCalendar = !!localStorage.getItem(STORAGE_KEYS.CALENDAR_ENTRIES);
+      if (hasCalendar && migrationDone) {
+        console.warn('âš ï¸ Found calendar entries but migration was marked done - forcing re-migration');
+        localStorage.removeItem(STORAGE_KEYS.MIGRATION_COMPLETED);
+      }
+
       if (hasLocalData && !migrationDone) {
+        console.log('âœ… Showing migration dialog');
         setShowMigrationDialog(true);
       }
     }
diff --git a/frontend/src/components/CalendarPopup.tsx b/frontend/src/components/CalendarPopup.tsx
index fe4b197..8fba1a6 100644
--- a/frontend/src/components/CalendarPopup.tsx
+++ b/frontend/src/components/CalendarPopup.tsx
@@ -6,6 +6,7 @@ import {
   deleteEntry,
   type CalendarEntry
 } from '../utils/calendarStorage';
+import { useAuth } from '../contexts/AuthContext';
 
 interface Props {
   onLoadEntry: (entry: CalendarEntry) => void;
@@ -13,14 +14,60 @@ interface Props {
 }
 
 export default function CalendarPopup({ onLoadEntry, onClose }: Props) {
+  const { isAuthenticated } = useAuth();
   const [currentMonth, setCurrentMonth] = useState(new Date());
   const [selectedDate, setSelectedDate] = useState<string | null>(getTodayKey());
-  const [calendarData, setCalendarData] = useState(getCalendarData());
+  const [calendarData, setCalendarData] = useState<Record<string, CalendarEntry[]>>({});
 
-  // Refresh calendar data when component mounts or updates
+  // @@@ Load calendar data from database if authenticated, localStorage if guest
   useEffect(() => {
-    setCalendarData(getCalendarData());
-  }, []);
+    const loadData = async () => {
+      if (isAuthenticated) {
+        try {
+          // Load from database - sessions imported during migration
+          const { listSessions, getSession } = await import('../api/voiceApi');
+          const sessions = await listSessions();
+
+          // Group sessions by date (extract from session name which has format "YYYY-MM-DD - FirstLine")
+          const grouped: Record<string, CalendarEntry[]> = {};
+
+          for (const session of sessions) {
+            const fullSession = await getSession(session.id);
+
+            // Extract date from name or use created_at
+            let dateKey = session.created_at?.split('T')[0] || getTodayKey();
+
+            // If name starts with YYYY-MM-DD format, use that
+            if (session.name && /^\d{4}-\d{2}-\d{2}/.test(session.name)) {
+              dateKey = session.name.split(' - ')[0];
+            }
+
+            if (!grouped[dateKey]) {
+              grouped[dateKey] = [];
+            }
+
+            grouped[dateKey].push({
+              id: session.id,
+              timestamp: new Date(session.created_at || Date.now()).getTime(),
+              state: fullSession.editor_state,
+              firstLine: session.name || 'Untitled'
+            });
+          }
+
+          setCalendarData(grouped);
+        } catch (error) {
+          console.error('Failed to load calendar from database:', error);
+          // Fallback to localStorage
+          setCalendarData(getCalendarData());
+        }
+      } else {
+        // Guest mode: load from localStorage
+        setCalendarData(getCalendarData());
+      }
+    };
+
+    loadData();
+  }, [isAuthenticated]);
 
   const today = getTodayKey();
   const datesWithEntries = Object.keys(calendarData);
@@ -64,10 +111,45 @@ export default function CalendarPopup({ onLoadEntry, onClose }: Props) {
     setSelectedDate(dateKey);
   };
 
-  const handleDeleteEntry = (dateKey: string, entryId: string) => {
+  const handleDeleteEntry = async (dateKey: string, entryId: string) => {
     if (confirm('Delete this entry?')) {
-      deleteEntry(dateKey, entryId);
-      setCalendarData(getCalendarData());
+      if (isAuthenticated) {
+        try {
+          // Delete from database
+          const { deleteSession } = await import('../api/voiceApi');
+          await deleteSession(entryId);
+
+          // Reload calendar data
+          const { listSessions, getSession } = await import('../api/voiceApi');
+          const sessions = await listSessions();
+          const grouped: Record<string, CalendarEntry[]> = {};
+
+          for (const session of sessions) {
+            const fullSession = await getSession(session.id);
+            let dateKey = session.created_at?.split('T')[0] || getTodayKey();
+            if (session.name && /^\d{4}-\d{2}-\d{2}/.test(session.name)) {
+              dateKey = session.name.split(' - ')[0];
+            }
+            if (!grouped[dateKey]) {
+              grouped[dateKey] = [];
+            }
+            grouped[dateKey].push({
+              id: session.id,
+              timestamp: new Date(session.created_at || Date.now()).getTime(),
+              state: fullSession.editor_state,
+              firstLine: session.name || 'Untitled'
+            });
+          }
+          setCalendarData(grouped);
+        } catch (error) {
+          console.error('Failed to delete from database:', error);
+          alert('Failed to delete entry');
+        }
+      } else {
+        // Guest mode: delete from localStorage
+        deleteEntry(dateKey, entryId);
+        setCalendarData(getCalendarData());
+      }
     }
   };
 
