*** FILE: backend/database.py ***
@@ -1070,6 +1070,39 @@ def get_session(user_id: int, session_id: str):
     finally:
         db.close()
 
+def get_sessions_batch(user_id: int, session_ids: list[str]) -> list[dict]:
+    """Fetch multiple sessions in a single query (includes full editor_state)."""
+    if not session_ids:
+        return []
+
+    db = get_db()
+    try:
+        placeholders = ",".join("?" for _ in session_ids)
+        query = f"""
+        SELECT id, name, editor_state_json, created_at, updated_at
+        FROM user_sessions
+        WHERE user_id = ? AND id IN ({placeholders})
+        """
+        rows = db.execute(query, (user_id, *session_ids)).fetchall()
+        sessions = []
+        for row in rows:
+            try:
+                state = json.loads(row["editor_state_json"])
+            except Exception:
+                state = {}
+            sessions.append(
+                {
+                    "id": row["id"],
+                    "name": row["name"],
+                    "created_at": row["created_at"],
+                    "updated_at": row["updated_at"],
+                    "editor_state": state,
+                }
+            )
+        return sessions
+    finally:
+        db.close()
+
 def list_sessions(user_id: int):
     """List all sessions for a user with a lightweight preview."""
     db = get_db()

*** FILE: backend/server.py ***
@@ -19,7 +19,7 @@
 from stateless_analyzer import analyze_stateless
 from speech_recognition import init_speech_recognition
 import config
-from typing import Optional
+from typing import Optional, List
 from pydantic import BaseModel
 
 # Import database and auth modules
@@ -892,6 +892,9 @@ class ImportDataRequest(BaseModel):
     analysisReports: Optional[str] = None
     oldDocument: Optional[str] = None
 
+class SessionBatchRequest(BaseModel):
+    ids: List[str]
+
 
 # ========== Auth Dependency ==========
 
@@ -1292,6 +1295,20 @@ def list_sessions(timezone: str = "Asia/Shanghai", current_user: dict = Depends(
 
     return {"sessions": enriched}
 
+@app.post("/api/sessions/batch")
+def get_sessions_batch(payload: SessionBatchRequest, current_user: dict = Depends(get_current_user)):
+    """
+    Fetch multiple sessions (with editor_state) in a single request.
+    """
+    user_id = current_user["user_id"]
+    session_ids = payload.ids or []
+
+    if not session_ids:
+        return {"sessions": []}
+
+    sessions = database.get_sessions_batch(user_id, session_ids)
+    return {"sessions": sessions}
+
 @app.get("/api/sessions/aggregate")
 def get_sessions_aggregate(timezone: str = "Asia/Shanghai", current_user: dict = Depends(get_current_user)):
     """

*** FILE: frontend/src/api/voiceApi.ts ***
@@ -443,6 +443,27 @@ export async function getSession(sessionId: string): Promise<any> {
   return await response.json();
 }
 
+/**
+ * Fetch multiple sessions (with editor_state) in a single request.
+ */
+export async function getSessionsBatch(sessionIds: string[]): Promise<any[]> {
+  if (!sessionIds || sessionIds.length === 0) return [];
+
+  const response = await fetch(`${API_BASE}/api/sessions/batch`, {
+    method: 'POST',
+    headers: getAuthHeaders(),
+    body: JSON.stringify({ ids: sessionIds })
+  });
+
+  if (!response.ok) {
+    const error = await response.json();
+    throw new Error(error.detail || 'Batch session fetch failed');
+  }
+
+  const data = await response.json();
+  return data.sessions;
+}
+
 /**
  * Delete a session
  */

*** FILE: frontend/src/components/CollectionsView.tsx ***
@@ -6,7 +6,7 @@ import { useAuth } from '../contexts/AuthContext';
 import { STORAGE_KEYS } from '../constants/storageKeys';
 import { getDateLocale } from '../i18n';
 import { extractFirstLine } from '../utils/calendarStorage';
-import { loadSessionsGroupedByDate } from '../utils/sessionGrouping';
+import { getLocalDayKey } from '../utils/timezone';
 
 // @@@ TypeScript interfaces
 interface TimelineDay {
@@ -29,6 +29,15 @@ interface TimelineEntryData {
   comments: Commentor[];
 }
 
+interface SessionSummary {
+  id: string;
+  date_key?: string | null;
+  first_line?: string;
+  name?: string | null;
+  created_at?: string;
+  updated_at?: string;
+}
+
 interface CollectionsViewProps {
   isVisible: boolean;
   voiceConfigs: Record<string, any>;
@@ -407,6 +416,8 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin
   const [textByDate, setTextByDate] = useState<Map<string, string>>(new Map());
   const [firstLineByDate, setFirstLineByDate] = useState<Map<string, string>>(new Map());
   const [pictures, setPictures] = useState<TimelinePicture[]>([]);
+  const [sessionSummaries, setSessionSummaries] = useState<SessionSummary[]>([]);
+  const [datesWithSessions, setDatesWithSessions] = useState<Set<string>>(new Set());
   const [generatingForDate, setGeneratingForDate] = useState<string | null>(null);
   const [viewingImage, setViewingImage] = useState<{ base64: string; full_base64?: string; prompt: string; date: string; } | null>(null);
   const [initialLoading, setInitialLoading] = useState(true);
@@ -415,63 +426,78 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin
   const allTimelineDays = useMemo(() => generateTimelineDays(), []);
 
   useEffect(() => {
+    let cancelled = false;
+
     const loadTimelineData = async () => {
+      setInitialLoading(true);
+      setStarredComments([]);
+      setAllCommentsByDate(new Map());
+      setTextByDate(new Map());
+      setFirstLineByDate(new Map());
+      setDatesWithSessions(new Set());
+      setPictures([]);
+
       if (isAuthenticated) {
         try {
-          const { listSessions, getSession } = await import('../api/voiceApi');
-          const groupedEntries = await loadSessionsGroupedByDate(() => listSessions(timezone), getSession, {
-            requireName: true,
-            timezone
-          });
+          const { listSessions, getDailyPictures } = await import('../api/voiceApi');
+          const sessions: SessionSummary[] = await listSessions(timezone);
+          if (cancelled) return;
 
-          const allStarred: Commentor[] = [];
-          const commentsByDate = new Map<string, Commentor[]>();
-          const textByDateMap = new Map<string, string>();
-          const firstLineMap = new Map<string, string>();
+          setSessionSummaries(sessions);
 
-          Object.entries(groupedEntries).forEach(([dateKey, entries]) => {
-            if (entries.length > 0 && !firstLineMap.has(dateKey)) {
-              firstLineMap.set(dateKey, entries[0].firstLine);
+          const firstLineMap = new Map<string, string>();
+          const dates = new Set<string>();
+          sessions.forEach((session) => {
+            const dateKey = session.date_key;
+            if (dateKey) {
+              dates.add(dateKey);
+              if (!firstLineMap.has(dateKey)) {
+                const line = session.first_line || session.name || 'Untitled';
+                firstLineMap.set(dateKey, line);
+              }
             }
+          });
 
-            entries.forEach(entry => {
-              const state = entry.state;
-              if (!state) return;
-
-              const comments = state.commentors || [];
-              const starred = comments.filter((c: Commentor) => c.feedback === 'star');
-              allStarred.push(...starred);
+          if (!cancelled) {
+            setFirstLineByDate(firstLineMap);
+            setDatesWithSessions(dates);
+          }
 
-              comments.filter((c: Commentor) => c.appliedAt).forEach((comment: Commentor) => {
-                const commentDate = new Date(comment.appliedAt || comment.computedAt);
-                const date = getLocalDateString(commentDate);
-                if (!commentsByDate.has(date)) {
-                  commentsByDate.set(date, []);
+          try {
+            const dbPictures = await getDailyPictures(30);
+            if (!cancelled) {
+              const formattedPictures = dbPictures.map((p: any) => ({
+                date: p.date,
+                base64: p.base64,
+                prompt: p.prompt || ''
+              }));
+              setPictures(formattedPictures);
+            }
+          } catch (error) {
+            console.error('Failed to load pictures from database:', error);
+            if (!cancelled) {
+              const savedPictures = localStorage.getItem(STORAGE_KEYS.DAILY_PICTURES);
+              if (savedPictures) {
+                try {
+                  const parsed = JSON.parse(savedPictures);
+                  const thumbnailsOnly = parsed.map((p: any) => ({
+                    date: p.date,
+                    base64: p.base64,
+                    prompt: p.prompt
+                  }));
+                  setPictures(thumbnailsOnly);
+                } catch (e) {
+                  console.error('Failed to load pictures:', e);
                 }
-                commentsByDate.get(date)!.push(comment);
-              });
-
-              const text = state.cells
-                ?.filter((c: any) => c.type === 'text')
-                .map((c: any) => c.content)
-                .join(' ')
-                .trim();
-
-              if (text) {
-                const existingText = textByDateMap.get(dateKey) || '';
-                textByDateMap.set(dateKey, existingText ? `${existingText} ${text}` : text);
               }
-            });
-          });
-
-          setStarredComments(allStarred);
-          setAllCommentsByDate(commentsByDate);
-          setTextByDate(textByDateMap);
-          setFirstLineByDate(firstLineMap);
+            }
+          }
         } catch (error) {
-          console.error('Failed to load comments from database:', error);
+          console.error('Failed to load timeline data:', error);
+          setSessionSummaries([]);
         }
       } else {
+        setSessionSummaries([]);
         const savedState = localStorage.getItem(STORAGE_KEYS.EDITOR_STATE);
         if (savedState) {
           try {
@@ -511,36 +537,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin
           setTextByDate(new Map());
           setFirstLineByDate(new Map());
         }
-      }
 
-      if (isAuthenticated) {
-        try {
-          const { getDailyPictures } = await import('../api/voiceApi');
-          const dbPictures = await getDailyPictures(30);
-          const formattedPictures = dbPictures.map(p => ({
-            date: p.date,
-            base64: p.base64,
-            prompt: p.prompt || ''
-          }));
-          setPictures(formattedPictures);
-        } catch (error) {
-          console.error('Failed to load pictures from database:', error);
-          const savedPictures = localStorage.getItem(STORAGE_KEYS.DAILY_PICTURES);
-          if (savedPictures) {
-            try {
-              const parsed = JSON.parse(savedPictures);
-              const thumbnailsOnly = parsed.map((p: any) => ({
-                date: p.date,
-                base64: p.base64,
-                prompt: p.prompt
-              }));
-              setPictures(thumbnailsOnly);
-            } catch (e) {
-              console.error('Failed to load pictures:', e);
-            }
-          }
-        }
-      } else {
         const savedPictures = localStorage.getItem(STORAGE_KEYS.DAILY_PICTURES);
         if (savedPictures) {
           try {
@@ -557,23 +554,44 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin
         }
       }
 
-      setInitialLoading(false);
+      if (!cancelled) {
+        setInitialLoading(false);
+      }
     };
 
     loadTimelineData();
-  }, [isAuthenticated, timezone, dateLocale]);
+
+    return () => {
+      cancelled = true;
+    };
+  }, [isAuthenticated, timezone, dateLocale, allTimelineDays]);
 
   // @@@ Group items by date
   const timelineByDate = useMemo(() => {
     const map = new Map<string, TimelineEntryData>();
 
+    datesWithSessions.forEach(date => {
+      if (!map.has(date)) {
+        map.set(date, { comments: [] });
+      }
+    });
+
+    allCommentsByDate.forEach((comments, date) => {
+      const entry = map.get(date) || { comments: [] };
+      entry.comments = comments;
+      map.set(date, entry);
+    });
+
     starredComments.forEach(comment => {
       const commentDate = new Date(comment.appliedAt || comment.computedAt);
       const date = getLocalDateString(commentDate);
+      const hasFullComments = allCommentsByDate.has(date);
       if (!map.has(date)) {
         map.set(date, { comments: [] });
       }
-      map.get(date)!.comments.push(comment);
+      if (!hasFullComments) {
+        map.get(date)!.comments.push(comment);
+      }
     });
 
     pictures.forEach(pic => {
@@ -585,7 +603,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin
     });
 
     return map;
-  }, [starredComments, pictures]);
+  }, [datesWithSessions, allCommentsByDate, starredComments, pictures]);
 
   // @@@ Set initial scroll position to show today's row centered
   useLayoutEffect(() => {
@@ -614,27 +632,34 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin
 
     try {
       if (isAuthenticated) {
-        const { listSessions, getSession } = await import('../api/voiceApi');
-        const sessions = await listSessions(timezone);
-        const commentsForDate: Commentor[] = [];
+        const sessionsForDate = sessionSummaries.filter(session => session.date_key === dateStr);
 
-        for (const session of sessions) {
-          try {
-            const fullSession = await getSession(session.id);
-            const comments = fullSession.editor_state?.commentors || [];
-
-            comments.filter((c: Commentor) => c.appliedAt).forEach((comment: Commentor) => {
-              const commentDate = new Date(comment.appliedAt || comment.computedAt);
-              const date = getLocalDateString(commentDate);
-              if (date === dateStr) {
-                commentsForDate.push(comment);
-              }
-            });
-          } catch (err) {
-            console.error(`Failed to load session ${session.id}:`, err);
-          }
+        if (sessionsForDate.length === 0) {
+          setAllCommentsByDate(prev => {
+            const next = new Map(prev);
+            next.set(dateStr, []);
+            return next;
+          });
+          return;
         }
 
+        const { getSessionsBatch } = await import('../api/voiceApi');
+        const batch = await getSessionsBatch(sessionsForDate.map(s => s.id));
+        const commentsForDate: Commentor[] = [];
+
+        batch.forEach((session: any) => {
+          const comments = session.editor_state?.commentors || [];
+
+          comments.filter((c: Commentor) => c.appliedAt).forEach((comment: Commentor) => {
+            const rawTs = comment.appliedAt || comment.computedAt;
+            const commentDate = getLocalDayKey(rawTs, timezone)
+              || getLocalDateString(new Date(rawTs));
+            if (commentDate === dateStr) {
+              commentsForDate.push(comment);
+            }
+          });
+        });
+
         setAllCommentsByDate(prev => {
           const next = new Map(prev);
           next.set(dateStr, commentsForDate);
@@ -1095,7 +1120,9 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin
                 color: '#888'
               }}>
                 {(() => {
-                  const commentCount = timelineByDate.get(viewingImage.date)?.comments?.length || 0;
+                  const commentCount =
+                    (allCommentsByDate.get(viewingImage.date)?.length)
+                    ?? (timelineByDate.get(viewingImage.date)?.comments?.length || 0);
                   return t('timeline.entryCount', { count: commentCount });
                 })()}
               </div>

*** FILE: frontend/src/utils/sessionGrouping.ts ***
@@ -1,76 +0,0 @@
-import type { CalendarEntry } from './calendarStorage';
-import { extractFirstLine, getTodayKey } from './calendarStorage';
-import type { EditorState } from '../engine/EditorEngine';
-import { getLocalDayKey, parseFlexibleTimestamp } from './timezone';
-
-type ListSessionsFn = () => Promise<any[]>;
-type GetSessionFn = (id: string) => Promise<any>;
-
-function getSessionTimestamp(sessionMeta: any, fullSession: any): Date | null {
-  const stateTimestamp = parseFlexibleTimestamp(fullSession?.editor_state?.createdAt);
-  if (stateTimestamp) return stateTimestamp;
-
-  const createdAt = parseFlexibleTimestamp(fullSession?.created_at || sessionMeta?.created_at);
-  if (createdAt) return createdAt;
-
-  const updatedAt = parseFlexibleTimestamp(fullSession?.updated_at || sessionMeta?.updated_at);
-  return updatedAt;
-}
-
-function getSessionDateKey(session: any, fullSession: any, timezone: string): string {
-  const timestamp = getSessionTimestamp(session, fullSession);
-  if (!timestamp) {
-    console.warn('Session missing timestamp data', session?.id);
-    return getTodayKey();
-  }
-  return getLocalDayKey(timestamp, timezone) ?? getTodayKey();
-}
-
-function getEntryFirstLine(sessionName: string | undefined, state?: EditorState): string {
-  if (sessionName && sessionName.trim().length > 0) {
-    return sessionName.trim();
-  }
-  if (state) {
-    return extractFirstLine(state);
-  }
-  return 'Untitled';
-}
-
-export async function loadSessionsGroupedByDate(
-  listSessions: ListSessionsFn,
-  getSession: GetSessionFn,
-  options: { requireName?: boolean; timezone?: string } = {}
-): Promise<Record<string, CalendarEntry[]>> {
-  const { requireName = false, timezone = 'UTC' } = options;
-  const sessions = await listSessions();
-  const grouped: Record<string, CalendarEntry[]> = {};
-
-  for (const session of sessions) {
-    if (requireName && !session.name) continue;
-
-    try {
-      const fullSession = await getSession(session.id);
-      if (!fullSession?.editor_state) continue;
-
-      const dateKey = getSessionDateKey(session, fullSession, timezone);
-      const firstLine = getEntryFirstLine(session.name, fullSession.editor_state);
-      if (!grouped[dateKey]) {
-        grouped[dateKey] = [];
-      }
-
-      const timestamp = getSessionTimestamp(session, fullSession);
-      const displayTimestamp = timestamp ? timestamp.getTime() : Date.now();
-
-      grouped[dateKey].push({
-        id: session.id,
-        timestamp: displayTimestamp,
-        state: fullSession.editor_state,
-        firstLine
-      });
-    } catch (error) {
-      console.error(`Failed to load session ${session.id}:`, error);
-    }
-  }
-
-  return grouped;
-}

