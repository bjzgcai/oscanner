commit 32cb8e834fba996aac0047e2a24027fc45f87b2d
Author: lexicalmathical <lexicalmathical@gmail.com>
Date:   Tue Oct 14 20:37:56 2025 +0800

    Fix LLM loop bugs: show used personas and clarify phrase length
    
    The LLM was getting stuck in loops due to two issues:
    
    1. Persona loop: LLM didn't know which personas were already used,
       so it kept suggesting the same ones (which got filtered silently).
       Fix: Show explicit "ALREADY USED PERSONAS" list in prompt.
    
    2. Sentence occupation confusion: LLM saw short trigger phrases but
       didn't understand the entire sentence was off-limits, so it tried
       to comment on different parts of occupied sentences.
       Fix: Show full sentences with explanation of phrase vs. sentence.
    
    3. Phrase length issue: LLM was returning whole sentences as phrases,
       making highlights too long and cluttered.
       Fix: Add explicit guidance for SHORT phrases (2-6 words) with
       examples and UI context ("This will be HIGHLIGHTED").
    
    Changes:
    - backend/stateful_analyzer.py: Add used persona tracking, full
      sentence display with trigger phrase mapping, phrase-vs-sentence
      distinction explanation, and SHORT phrase emphasis with examples
    - frontend/src/api/voiceApi.ts: Debug logging (from previous session)
    
    ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

diff --git a/backend/stateful_analyzer.py b/backend/stateful_analyzer.py
index 45831e2..bcea6ae 100644
--- a/backend/stateful_analyzer.py
+++ b/backend/stateful_analyzer.py
@@ -169,11 +169,63 @@ class StatefulVoiceAnalyzer:
             for name, v in config.VOICE_ARCHETYPES.items()
         ])
 
+        # @@@ Build list of occupied sentences AND used personas to guide LLM
         existing_summary = ""
         if self.comments:
-            existing_summary = "\n\nEXISTING COMMENTS (do NOT repeat these):\n"
+            # Get sentence boundaries
+            sentences = self._get_sentences(text)
+            sentence_positions = []
+            pos = 0
+            for sent in sentences:
+                start = text.lower().find(sent.lower(), pos)
+                if start != -1:
+                    sentence_positions.append((start, start + len(sent), sent))
+                    pos = start + len(sent)
+
+            # Find which sentences are occupied
+            occupied_sentences = set()
+            for comment in self.comments:
+                phrase_pos = text.lower().find(comment["phrase"].lower())
+                if phrase_pos != -1:
+                    for i, (start, end, sent) in enumerate(sentence_positions):
+                        if start <= phrase_pos < end:
+                            occupied_sentences.add(i)
+                            break
+
+            # Build summary with used personas and occupied sentences
+            used_personas = {c['voice'] for c in self.comments}
+
+            existing_summary = "\n\nâš ï¸  ALREADY USED PERSONAS (DO NOT USE THESE AGAIN - each persona can only appear ONCE):\n"
+            for persona in sorted(used_personas):
+                existing_summary += f"  - {persona}\n"
+            existing_summary += "ðŸ‘‰ You MUST choose a persona that is NOT in the list above!\n"
+
+            existing_summary += "\n\nEXISTING COMMENTS:\n"
             for c in self.comments:
-                existing_summary += f"- {c['voice']} on \"{c['phrase']}\": {c['comment']}\n"
+                existing_summary += f"- {c['voice']} commented on phrase \"{c['phrase']}\": {c['comment']}\n"
+
+            if occupied_sentences:
+                # @@@ phrase-vs-sentence - LLM must understand that even though only a phrase is highlighted,
+                # the ENTIRE sentence containing that phrase is off-limits for new comments
+                existing_summary += f"\nâš ï¸  OCCUPIED SENTENCES (already have comments, CANNOT comment anywhere in these sentences):\n"
+                existing_summary += "NOTE: Even though only a PHRASE is highlighted/commented, the rule is that the ENTIRE SENTENCE containing that phrase is now occupied.\n"
+                existing_summary += "You cannot add any new comment to any part of these full sentences:\n\n"
+                for i in sorted(occupied_sentences):
+                    if i < len(sentence_positions):
+                        full_sentence = sentence_positions[i][2]  # Show FULL sentence, no truncation
+                        # Find which comment triggered this sentence
+                        trigger_phrase = None
+                        for c in self.comments:
+                            phrase_pos = text.lower().find(c["phrase"].lower())
+                            if phrase_pos != -1:
+                                start, end, _ = sentence_positions[i]
+                                if start <= phrase_pos < end:
+                                    trigger_phrase = c["phrase"]
+                                    break
+
+                        existing_summary += f"  Sentence {i+1} (triggered by phrase \"{trigger_phrase}\"):\n"
+                        existing_summary += f"  \"{full_sentence}\"\n\n"
+                existing_summary += "ðŸ‘‰ Focus your analysis on NEW/UNCOMMENTED sentences only!\n"
 
         prompt = f"""You are analyzing internal dialogue using the voice system from Disco Elysium.
 
@@ -188,19 +240,30 @@ Available voice archetypes:
 {existing_summary}
 
 For each NEW voice you detect:
-1. Extract the EXACT phrase that triggered it (word-for-word from the text)
+1. Extract a SHORT phrase that triggered it (word-for-word from the text)
+   - The phrase should be SMALL - typically 2-6 words, the most essential/striking part
+   - This phrase will be HIGHLIGHTED in the UI - keep it concise!
+   - âœ… Good examples: "contemplative walk", "thinking about meaning", "life and death"
+   - âŒ Bad examples: (whole sentences, too long, not focused)
 2. Choose the matching voice archetype
 3. Write what this voice is saying (as if the voice itself is speaking)
 4. Use the voice's designated icon and color
 
+CRITICAL DISTINCTION:
+- **Phrase** = SHORT essential words you return (what gets highlighted, 2-6 words ideal)
+- **Sentence** = The occupation boundary (you can't comment anywhere else in that sentence)
+- Even though your phrase is short, it occupies the ENTIRE sentence it appears in
+
 IMPORTANT:
 - Maximum {config.MAX_VOICES} NEW voices
-- Only identify clearly present voices
-- Phrase must be verbatim from text
+- **It's perfectly fine to return NO comment (null) if nothing is worth commenting on**
+- Only identify clearly present voices - quality over quantity
+- Phrase must be verbatim from text and KEEP IT SHORT (2-6 words typical)
 - Each voice should be distinct
 - DO NOT comment on parts that already have comments
 - Avoid commenting too close to existing comments
 - DO NOT comment on the last sentence if it appears incomplete (no ending punctuation like .!?ã€‚ï¼ï¼Ÿ)
+- **If all available sentences are already occupied or incomplete, return null**
 - Write comments in the SAME LANGUAGE as the text being analyzed (if text is Chinese, respond in Chinese; if English, respond in English)
 """
 
diff --git a/frontend/src/api/voiceApi.ts b/frontend/src/api/voiceApi.ts
index 4df8a7c..c0a8ba3 100644
--- a/frontend/src/api/voiceApi.ts
+++ b/frontend/src/api/voiceApi.ts
@@ -29,6 +29,7 @@ interface StatusResponse {
  * Trigger voice analysis session
  */
 export async function triggerAnalysis(text: string, sessionId: string): Promise<string> {
+  console.log('ðŸ“¤ Sending trigger request...');
   const response = await fetch(`${API_BASE}/api/trigger`, {
     method: 'POST',
     headers: { 'Content-Type': 'application/json' },
@@ -38,11 +39,15 @@ export async function triggerAnalysis(text: string, sessionId: string): Promise<
     })
   });
 
+  console.log('ðŸ“¥ Got response, status:', response.status);
   const data: TriggerResponse = await response.json();
+  console.log('ðŸ“‹ Parsed JSON:', data);
+
   if (!data.success) {
     throw new Error('Failed to trigger analysis');
   }
 
+  console.log('âœ… Exec ID:', data.exec_id);
   return data.exec_id;
 }
 
@@ -54,11 +59,16 @@ export async function getAnalysisResult(exec_id: string): Promise<StatusResponse
   const maxAttempts = 60;
   let attempts = 0;
 
+  console.log('ðŸ”„ Starting to poll for exec_id:', exec_id);
+
   while (attempts < maxAttempts) {
+    console.log(`ðŸ“Š Polling attempt ${attempts + 1}/${maxAttempts}...`);
     const response = await fetch(`${API_BASE}/api/status/${exec_id}`);
     const data: StatusResponse = await response.json();
+    console.log('ðŸ“Š Status:', data.status);
 
     if (data.status === 'completed') {
+      console.log('âœ… Analysis completed!', data.result);
       return data.result;
     }
 
