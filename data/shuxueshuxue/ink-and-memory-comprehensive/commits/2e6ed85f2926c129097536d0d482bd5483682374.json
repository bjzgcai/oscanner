{
  "sha": "2e6ed85f2926c129097536d0d482bd5483682374",
  "node_id": "C_kwDOP2Zrm9oAKDJlNmVkODVmMjkyNmMxMjkwOTc1MzZkMGQ0ODJiZDU0ODM2ODIzNzQ",
  "commit": {
    "author": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-12-18T09:50:49Z"
    },
    "committer": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-12-18T09:50:49Z"
    },
    "message": "force model to use id in backend analysis",
    "tree": {
      "sha": "4a96b82e4de8b833bc9b77cd4075b9b64310b105",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/trees/4a96b82e4de8b833bc9b77cd4075b9b64310b105"
    },
    "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/commits/2e6ed85f2926c129097536d0d482bd5483682374",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/2e6ed85f2926c129097536d0d482bd5483682374",
  "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/2e6ed85f2926c129097536d0d482bd5483682374",
  "comments_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/2e6ed85f2926c129097536d0d482bd5483682374/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "0386af9af8ff3f2708263fe7d7e47ae63b5cba41",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/0386af9af8ff3f2708263fe7d7e47ae63b5cba41",
      "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/0386af9af8ff3f2708263fe7d7e47ae63b5cba41"
    }
  ],
  "stats": {
    "total": 87,
    "additions": 61,
    "deletions": 26
  },
  "files": [
    {
      "sha": "e7ef54670d62acc832b496510ba6a601b36cec89",
      "filename": "backend/stateless_analyzer.py",
      "status": "modified",
      "additions": 61,
      "deletions": 26,
      "changes": 87,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/2e6ed85f2926c129097536d0d482bd5483682374/backend%2Fstateless_analyzer.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/2e6ed85f2926c129097536d0d482bd5483682374/backend%2Fstateless_analyzer.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fstateless_analyzer.py?ref=2e6ed85f2926c129097536d0d482bd5483682374",
      "patch": "@@ -6,18 +6,37 @@\n from polycli import PolyAgent\n import config\n \n+\n class VoiceTrigger(BaseModel):\n-    phrase: str = Field(description=\"Exact trigger phrase from text (verbatim, 2-4 words, avoid punctuation)\")\n-    voice_id: str = Field(description=\"Voice ID from the available list (e.g., 'holder', 'mirror', 'starter')\")\n-    voice_name: str = Field(description=\"Voice display name (will be auto-filled, LLM should not generate this)\")\n+    phrase: str = Field(\n+        description=\"Exact trigger phrase from text (verbatim, 2-4 words, avoid punctuation)\"\n+    )\n+    voice_id: str = Field(\n+        description=\"Voice ID from the available list (e.g., 'holder', 'mirror', 'starter')\"\n+    )\n+    voice_name: str = Field(\n+        description=\"Voice display name (will be auto-filled, LLM should not generate this)\"\n+    )\n     comment: str = Field(description=\"What this voice is saying (as if speaking)\")\n     icon: str = Field(description=\"Icon identifier\")\n     color: str = Field(description=\"Color identifier\")\n \n+\n class SingleVoiceAnalysis(BaseModel):\n-    voice: Optional[VoiceTrigger] = Field(description=\"Single voice trigger, or None if nothing to comment\")\n+    voice: Optional[VoiceTrigger] = Field(\n+        description=\"Single voice trigger, or None if nothing to comment\"\n+    )\n \n-def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict], voices: dict = None, meta_prompt: str = \"\", state_prompt: str = \"\", overlapped_phrases: List[str] = None) -> dict:\n+\n+def analyze_stateless(\n+    agent: PolyAgent,\n+    text: str,\n+    applied_comments: List[dict],\n+    voices: dict = None,\n+    meta_prompt: str = \"\",\n+    state_prompt: str = \"\",\n+    overlapped_phrases: List[str] = None,\n+) -> dict:\n     \"\"\"\n     Stateless analysis - receives applied comments, returns ONE new comment.\n \n@@ -34,44 +53,60 @@ def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict],\n         Dict with single new voice (or empty list if none)\n     \"\"\"\n     overlapped_phrases = overlapped_phrases or []\n-    print(f\"\\n{'='*60}\")\n+    print(f\"\\n{'=' * 60}\")\n     print(f\"\ud83d\udcca Stateless Analysis\")\n     print(f\"   Text: {text[:100]}...\")\n     print(f\"   Applied comments: {len(applied_comments)}\")\n-    print(f\"{'='*60}\\n\")\n+    print(f\"{'=' * 60}\\n\")\n \n     # Use provided voices or defaults\n     voice_archetypes = voices or config.VOICE_ARCHETYPES\n \n     # Build voice list for prompt\n-    voice_list = \"\\n\".join([\n-        f\"- ID: {key} | Name: {v.get('name', key)} | ({v['icon']}, {v['color']})\\n  {v.get('systemPrompt', '')}\"\n-        for key, v in voice_archetypes.items()\n-    ])\n+    voice_list = \"\\n\".join(\n+        [\n+            f\"- ID: {key} | Name: {v.get('name', key)} | ({v['icon']}, {v['color']})\\n  {v.get('systemPrompt', '')}\"\n+            for key, v in voice_archetypes.items()\n+        ]\n+    )\n \n     # Build existing conversation context\n     conversation_context = \"\"\n     highlighted_phrases = []\n     if applied_comments:\n-        conversation_context = \"\\n\\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\"\n-        conversation_context += \"EXISTING CONVERSATION (for context - do NOT extract phrases from here):\\n\"\n-        conversation_context += \"\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\"\n+        conversation_context = (\n+            \"\\n\\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\"\n+        )\n+        conversation_context += (\n+            \"EXISTING CONVERSATION (for context - do NOT extract phrases from here):\\n\"\n+        )\n+        conversation_context += (\n+            \"\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\"\n+        )\n         for c in applied_comments:\n-            phrase = c.get('phrase', '')\n+            phrase = c.get(\"phrase\", \"\")\n             highlighted_phrases.append(phrase)\n-            conversation_context += f\"\\n{c.get('voice', 'Unknown')} commented on \\\"{phrase}\\\":\\n\"\n+            conversation_context += (\n+                f'\\n{c.get(\"voice\", \"Unknown\")} commented on \"{phrase}\":\\n'\n+            )\n             conversation_context += f\"  \u2192 {c.get('comment', '')}\\n\"\n \n-        conversation_context += f\"\\n\u26a0\ufe0f Already highlighted phrases (do NOT overlap): {highlighted_phrases}\\n\"\n+        conversation_context += (\n+            f\"\\n\u26a0\ufe0f Already highlighted phrases (do NOT overlap): {highlighted_phrases}\\n\"\n+        )\n \n     # @@@ Add overlapped phrases feedback (phrases that were rejected due to overlap)\n     rejected_section = \"\"\n     if overlapped_phrases:\n-        rejected_section = \"\\n\\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\"\n+        rejected_section = (\n+            \"\\n\\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\"\n+        )\n         rejected_section += \"REJECTED PHRASES (these were tried but overlapped):\\n\"\n-        rejected_section += \"\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\"\n+        rejected_section += (\n+            \"\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\"\n+        )\n         for phrase in overlapped_phrases:\n-            rejected_section += f\"  \u2717 \\\"{phrase}\\\" - REJECTED, do NOT suggest again\\n\"\n+            rejected_section += f'  \u2717 \"{phrase}\" - REJECTED, do NOT suggest again\\n'\n         rejected_section += f\"\\n\u26a0\ufe0f Do NOT suggest any variation of these phrases!\\n\"\n \n     prompt = f\"\"\"You are analyzing internal dialogue as distinct inner voice personas.\n@@ -102,7 +137,7 @@ def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict],\n    - Verify character-by-character that your phrase exists in the text\n \n 2. Choose a voice ID from the available list above\n-   - Use the ID field (e.g., 'holder', 'mirror'), NOT the name\n+   - Use the ID field (which might be a complex, nonsensical string), NOT the name\n    - Return ONLY the ID in the voice_id field\n \n 3. Write what this voice is saying (1-2 sentences)\n@@ -143,7 +178,7 @@ def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict],\n         model=config.MODEL,\n         cli=\"no-tools\",\n         schema_cls=SingleVoiceAnalysis,\n-        tracked=True\n+        tracked=True,\n     )\n \n     if not result.is_success or not result.has_data():\n@@ -166,11 +201,11 @@ def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict],\n         # Build return object with both ID and name\n         result_voice = {\n             \"phrase\": voice.get(\"phrase\"),\n-            \"voice_id\": voice_id,                    # NEW: ID for lookup\n-            \"voice\": archetype.get(\"name\", voice_id), # KEEP: Name for display\n+            \"voice_id\": voice_id,  # NEW: ID for lookup\n+            \"voice\": archetype.get(\"name\", voice_id),  # KEEP: Name for display\n             \"comment\": voice.get(\"comment\"),\n-            \"icon\": archetype[\"icon\"],               # Ensure correct icon\n-            \"color\": archetype[\"color\"]              # Ensure correct color\n+            \"icon\": archetype[\"icon\"],  # Ensure correct icon\n+            \"color\": archetype[\"color\"],  # Ensure correct color\n         }\n \n         print(f\"\u2705 Got 1 new comment: {voice_id} ({result_voice['voice']})\")"
    }
  ]
}