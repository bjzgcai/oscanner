{
  "sha": "9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7",
  "node_id": "C_kwDOP2Zrm9oAKDlhMTRkOTU3ZjNiMzY4OGQwY2Y4NTJiNGE3YzJmYmJmNzhhNmI1ZDc",
  "commit": {
    "author": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-12-10T05:49:45Z"
    },
    "committer": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-12-10T05:49:45Z"
    },
    "message": "more efficient timeline fetching logic",
    "tree": {
      "sha": "3a645ebcf19c838397b95c891260332d9cbdb386",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/trees/3a645ebcf19c838397b95c891260332d9cbdb386"
    },
    "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/commits/9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7",
  "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7",
  "comments_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "878d4289ef68d2dae43aba9c2cdb779a99118c45",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/878d4289ef68d2dae43aba9c2cdb779a99118c45",
      "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/878d4289ef68d2dae43aba9c2cdb779a99118c45"
    }
  ],
  "stats": {
    "total": 370,
    "additions": 196,
    "deletions": 174
  },
  "files": [
    {
      "sha": "ab716286b0c552f59b318574c5275358acb2fbe6",
      "filename": "backend/database.py",
      "status": "modified",
      "additions": 33,
      "deletions": 0,
      "changes": 33,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7/backend%2Fdatabase.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7/backend%2Fdatabase.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fdatabase.py?ref=9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7",
      "patch": "@@ -1070,6 +1070,39 @@ def get_session(user_id: int, session_id: str):\n     finally:\n         db.close()\n \n+def get_sessions_batch(user_id: int, session_ids: list[str]) -> list[dict]:\n+    \"\"\"Fetch multiple sessions in a single query (includes full editor_state).\"\"\"\n+    if not session_ids:\n+        return []\n+\n+    db = get_db()\n+    try:\n+        placeholders = \",\".join(\"?\" for _ in session_ids)\n+        query = f\"\"\"\n+        SELECT id, name, editor_state_json, created_at, updated_at\n+        FROM user_sessions\n+        WHERE user_id = ? AND id IN ({placeholders})\n+        \"\"\"\n+        rows = db.execute(query, (user_id, *session_ids)).fetchall()\n+        sessions = []\n+        for row in rows:\n+            try:\n+                state = json.loads(row[\"editor_state_json\"])\n+            except Exception:\n+                state = {}\n+            sessions.append(\n+                {\n+                    \"id\": row[\"id\"],\n+                    \"name\": row[\"name\"],\n+                    \"created_at\": row[\"created_at\"],\n+                    \"updated_at\": row[\"updated_at\"],\n+                    \"editor_state\": state,\n+                }\n+            )\n+        return sessions\n+    finally:\n+        db.close()\n+\n def list_sessions(user_id: int):\n     \"\"\"List all sessions for a user with a lightweight preview.\"\"\"\n     db = get_db()"
    },
    {
      "sha": "d14c2b1e4d0af512c9a9247c421bae6c72aa0e46",
      "filename": "backend/server.py",
      "status": "modified",
      "additions": 18,
      "deletions": 1,
      "changes": 19,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7/backend%2Fserver.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7/backend%2Fserver.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fserver.py?ref=9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7",
      "patch": "@@ -19,7 +19,7 @@\n from stateless_analyzer import analyze_stateless\n from speech_recognition import init_speech_recognition\n import config\n-from typing import Optional\n+from typing import Optional, List\n from pydantic import BaseModel\n \n # Import database and auth modules\n@@ -892,6 +892,9 @@ class ImportDataRequest(BaseModel):\n     analysisReports: Optional[str] = None\n     oldDocument: Optional[str] = None\n \n+class SessionBatchRequest(BaseModel):\n+    ids: List[str]\n+\n \n # ========== Auth Dependency ==========\n \n@@ -1292,6 +1295,20 @@ def list_sessions(timezone: str = \"Asia/Shanghai\", current_user: dict = Depends(\n \n     return {\"sessions\": enriched}\n \n+@app.post(\"/api/sessions/batch\")\n+def get_sessions_batch(payload: SessionBatchRequest, current_user: dict = Depends(get_current_user)):\n+    \"\"\"\n+    Fetch multiple sessions (with editor_state) in a single request.\n+    \"\"\"\n+    user_id = current_user[\"user_id\"]\n+    session_ids = payload.ids or []\n+\n+    if not session_ids:\n+        return {\"sessions\": []}\n+\n+    sessions = database.get_sessions_batch(user_id, session_ids)\n+    return {\"sessions\": sessions}\n+\n @app.get(\"/api/sessions/aggregate\")\n def get_sessions_aggregate(timezone: str = \"Asia/Shanghai\", current_user: dict = Depends(get_current_user)):\n     \"\"\""
    },
    {
      "sha": "84c16d74bfabdce38adfff37497adebe83a586e6",
      "filename": "frontend/src/api/voiceApi.ts",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7/frontend%2Fsrc%2Fapi%2FvoiceApi.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7/frontend%2Fsrc%2Fapi%2FvoiceApi.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fapi%2FvoiceApi.ts?ref=9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7",
      "patch": "@@ -443,6 +443,27 @@ export async function getSession(sessionId: string): Promise<any> {\n   return await response.json();\n }\n \n+/**\n+ * Fetch multiple sessions (with editor_state) in a single request.\n+ */\n+export async function getSessionsBatch(sessionIds: string[]): Promise<any[]> {\n+  if (!sessionIds || sessionIds.length === 0) return [];\n+\n+  const response = await fetch(`${API_BASE}/api/sessions/batch`, {\n+    method: 'POST',\n+    headers: getAuthHeaders(),\n+    body: JSON.stringify({ ids: sessionIds })\n+  });\n+\n+  if (!response.ok) {\n+    const error = await response.json();\n+    throw new Error(error.detail || 'Batch session fetch failed');\n+  }\n+\n+  const data = await response.json();\n+  return data.sessions;\n+}\n+\n /**\n  * Delete a session\n  */"
    },
    {
      "sha": "d71359e85312d61527711d7b815eab235d0185c7",
      "filename": "frontend/src/components/CollectionsView.tsx",
      "status": "modified",
      "additions": 124,
      "deletions": 97,
      "changes": 221,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx?ref=9a14d957f3b3688d0cf852b4a7c2fbbf78a6b5d7",
      "patch": "@@ -6,7 +6,7 @@ import { useAuth } from '../contexts/AuthContext';\n import { STORAGE_KEYS } from '../constants/storageKeys';\n import { getDateLocale } from '../i18n';\n import { extractFirstLine } from '../utils/calendarStorage';\n-import { loadSessionsGroupedByDate } from '../utils/sessionGrouping';\n+import { getLocalDayKey } from '../utils/timezone';\n \n // @@@ TypeScript interfaces\n interface TimelineDay {\n@@ -29,6 +29,15 @@ interface TimelineEntryData {\n   comments: Commentor[];\n }\n \n+interface SessionSummary {\n+  id: string;\n+  date_key?: string | null;\n+  first_line?: string;\n+  name?: string | null;\n+  created_at?: string;\n+  updated_at?: string;\n+}\n+\n interface CollectionsViewProps {\n   isVisible: boolean;\n   voiceConfigs: Record<string, any>;\n@@ -407,6 +416,8 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n   const [textByDate, setTextByDate] = useState<Map<string, string>>(new Map());\n   const [firstLineByDate, setFirstLineByDate] = useState<Map<string, string>>(new Map());\n   const [pictures, setPictures] = useState<TimelinePicture[]>([]);\n+  const [sessionSummaries, setSessionSummaries] = useState<SessionSummary[]>([]);\n+  const [datesWithSessions, setDatesWithSessions] = useState<Set<string>>(new Set());\n   const [generatingForDate, setGeneratingForDate] = useState<string | null>(null);\n   const [viewingImage, setViewingImage] = useState<{ base64: string; full_base64?: string; prompt: string; date: string; } | null>(null);\n   const [initialLoading, setInitialLoading] = useState(true);\n@@ -415,63 +426,78 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n   const allTimelineDays = useMemo(() => generateTimelineDays(), []);\n \n   useEffect(() => {\n+    let cancelled = false;\n+\n     const loadTimelineData = async () => {\n+      setInitialLoading(true);\n+      setStarredComments([]);\n+      setAllCommentsByDate(new Map());\n+      setTextByDate(new Map());\n+      setFirstLineByDate(new Map());\n+      setDatesWithSessions(new Set());\n+      setPictures([]);\n+\n       if (isAuthenticated) {\n         try {\n-          const { listSessions, getSession } = await import('../api/voiceApi');\n-          const groupedEntries = await loadSessionsGroupedByDate(() => listSessions(timezone), getSession, {\n-            requireName: true,\n-            timezone\n-          });\n+          const { listSessions, getDailyPictures } = await import('../api/voiceApi');\n+          const sessions: SessionSummary[] = await listSessions(timezone);\n+          if (cancelled) return;\n \n-          const allStarred: Commentor[] = [];\n-          const commentsByDate = new Map<string, Commentor[]>();\n-          const textByDateMap = new Map<string, string>();\n-          const firstLineMap = new Map<string, string>();\n+          setSessionSummaries(sessions);\n \n-          Object.entries(groupedEntries).forEach(([dateKey, entries]) => {\n-            if (entries.length > 0 && !firstLineMap.has(dateKey)) {\n-              firstLineMap.set(dateKey, entries[0].firstLine);\n+          const firstLineMap = new Map<string, string>();\n+          const dates = new Set<string>();\n+          sessions.forEach((session) => {\n+            const dateKey = session.date_key;\n+            if (dateKey) {\n+              dates.add(dateKey);\n+              if (!firstLineMap.has(dateKey)) {\n+                const line = session.first_line || session.name || 'Untitled';\n+                firstLineMap.set(dateKey, line);\n+              }\n             }\n+          });\n \n-            entries.forEach(entry => {\n-              const state = entry.state;\n-              if (!state) return;\n-\n-              const comments = state.commentors || [];\n-              const starred = comments.filter((c: Commentor) => c.feedback === 'star');\n-              allStarred.push(...starred);\n+          if (!cancelled) {\n+            setFirstLineByDate(firstLineMap);\n+            setDatesWithSessions(dates);\n+          }\n \n-              comments.filter((c: Commentor) => c.appliedAt).forEach((comment: Commentor) => {\n-                const commentDate = new Date(comment.appliedAt || comment.computedAt);\n-                const date = getLocalDateString(commentDate);\n-                if (!commentsByDate.has(date)) {\n-                  commentsByDate.set(date, []);\n+          try {\n+            const dbPictures = await getDailyPictures(30);\n+            if (!cancelled) {\n+              const formattedPictures = dbPictures.map((p: any) => ({\n+                date: p.date,\n+                base64: p.base64,\n+                prompt: p.prompt || ''\n+              }));\n+              setPictures(formattedPictures);\n+            }\n+          } catch (error) {\n+            console.error('Failed to load pictures from database:', error);\n+            if (!cancelled) {\n+              const savedPictures = localStorage.getItem(STORAGE_KEYS.DAILY_PICTURES);\n+              if (savedPictures) {\n+                try {\n+                  const parsed = JSON.parse(savedPictures);\n+                  const thumbnailsOnly = parsed.map((p: any) => ({\n+                    date: p.date,\n+                    base64: p.base64,\n+                    prompt: p.prompt\n+                  }));\n+                  setPictures(thumbnailsOnly);\n+                } catch (e) {\n+                  console.error('Failed to load pictures:', e);\n                 }\n-                commentsByDate.get(date)!.push(comment);\n-              });\n-\n-              const text = state.cells\n-                ?.filter((c: any) => c.type === 'text')\n-                .map((c: any) => c.content)\n-                .join(' ')\n-                .trim();\n-\n-              if (text) {\n-                const existingText = textByDateMap.get(dateKey) || '';\n-                textByDateMap.set(dateKey, existingText ? `${existingText} ${text}` : text);\n               }\n-            });\n-          });\n-\n-          setStarredComments(allStarred);\n-          setAllCommentsByDate(commentsByDate);\n-          setTextByDate(textByDateMap);\n-          setFirstLineByDate(firstLineMap);\n+            }\n+          }\n         } catch (error) {\n-          console.error('Failed to load comments from database:', error);\n+          console.error('Failed to load timeline data:', error);\n+          setSessionSummaries([]);\n         }\n       } else {\n+        setSessionSummaries([]);\n         const savedState = localStorage.getItem(STORAGE_KEYS.EDITOR_STATE);\n         if (savedState) {\n           try {\n@@ -511,36 +537,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n           setTextByDate(new Map());\n           setFirstLineByDate(new Map());\n         }\n-      }\n \n-      if (isAuthenticated) {\n-        try {\n-          const { getDailyPictures } = await import('../api/voiceApi');\n-          const dbPictures = await getDailyPictures(30);\n-          const formattedPictures = dbPictures.map(p => ({\n-            date: p.date,\n-            base64: p.base64,\n-            prompt: p.prompt || ''\n-          }));\n-          setPictures(formattedPictures);\n-        } catch (error) {\n-          console.error('Failed to load pictures from database:', error);\n-          const savedPictures = localStorage.getItem(STORAGE_KEYS.DAILY_PICTURES);\n-          if (savedPictures) {\n-            try {\n-              const parsed = JSON.parse(savedPictures);\n-              const thumbnailsOnly = parsed.map((p: any) => ({\n-                date: p.date,\n-                base64: p.base64,\n-                prompt: p.prompt\n-              }));\n-              setPictures(thumbnailsOnly);\n-            } catch (e) {\n-              console.error('Failed to load pictures:', e);\n-            }\n-          }\n-        }\n-      } else {\n         const savedPictures = localStorage.getItem(STORAGE_KEYS.DAILY_PICTURES);\n         if (savedPictures) {\n           try {\n@@ -557,23 +554,44 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n         }\n       }\n \n-      setInitialLoading(false);\n+      if (!cancelled) {\n+        setInitialLoading(false);\n+      }\n     };\n \n     loadTimelineData();\n-  }, [isAuthenticated, timezone, dateLocale]);\n+\n+    return () => {\n+      cancelled = true;\n+    };\n+  }, [isAuthenticated, timezone, dateLocale, allTimelineDays]);\n \n   // @@@ Group items by date\n   const timelineByDate = useMemo(() => {\n     const map = new Map<string, TimelineEntryData>();\n \n+    datesWithSessions.forEach(date => {\n+      if (!map.has(date)) {\n+        map.set(date, { comments: [] });\n+      }\n+    });\n+\n+    allCommentsByDate.forEach((comments, date) => {\n+      const entry = map.get(date) || { comments: [] };\n+      entry.comments = comments;\n+      map.set(date, entry);\n+    });\n+\n     starredComments.forEach(comment => {\n       const commentDate = new Date(comment.appliedAt || comment.computedAt);\n       const date = getLocalDateString(commentDate);\n+      const hasFullComments = allCommentsByDate.has(date);\n       if (!map.has(date)) {\n         map.set(date, { comments: [] });\n       }\n-      map.get(date)!.comments.push(comment);\n+      if (!hasFullComments) {\n+        map.get(date)!.comments.push(comment);\n+      }\n     });\n \n     pictures.forEach(pic => {\n@@ -585,7 +603,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n     });\n \n     return map;\n-  }, [starredComments, pictures]);\n+  }, [datesWithSessions, allCommentsByDate, starredComments, pictures]);\n \n   // @@@ Set initial scroll position to show today's row centered\n   useLayoutEffect(() => {\n@@ -614,27 +632,34 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n \n     try {\n       if (isAuthenticated) {\n-        const { listSessions, getSession } = await import('../api/voiceApi');\n-        const sessions = await listSessions(timezone);\n-        const commentsForDate: Commentor[] = [];\n+        const sessionsForDate = sessionSummaries.filter(session => session.date_key === dateStr);\n \n-        for (const session of sessions) {\n-          try {\n-            const fullSession = await getSession(session.id);\n-            const comments = fullSession.editor_state?.commentors || [];\n-\n-            comments.filter((c: Commentor) => c.appliedAt).forEach((comment: Commentor) => {\n-              const commentDate = new Date(comment.appliedAt || comment.computedAt);\n-              const date = getLocalDateString(commentDate);\n-              if (date === dateStr) {\n-                commentsForDate.push(comment);\n-              }\n-            });\n-          } catch (err) {\n-            console.error(`Failed to load session ${session.id}:`, err);\n-          }\n+        if (sessionsForDate.length === 0) {\n+          setAllCommentsByDate(prev => {\n+            const next = new Map(prev);\n+            next.set(dateStr, []);\n+            return next;\n+          });\n+          return;\n         }\n \n+        const { getSessionsBatch } = await import('../api/voiceApi');\n+        const batch = await getSessionsBatch(sessionsForDate.map(s => s.id));\n+        const commentsForDate: Commentor[] = [];\n+\n+        batch.forEach((session: any) => {\n+          const comments = session.editor_state?.commentors || [];\n+\n+          comments.filter((c: Commentor) => c.appliedAt).forEach((comment: Commentor) => {\n+            const rawTs = comment.appliedAt || comment.computedAt;\n+            const commentDate = getLocalDayKey(rawTs, timezone)\n+              || getLocalDateString(new Date(rawTs));\n+            if (commentDate === dateStr) {\n+              commentsForDate.push(comment);\n+            }\n+          });\n+        });\n+\n         setAllCommentsByDate(prev => {\n           const next = new Map(prev);\n           next.set(dateStr, commentsForDate);\n@@ -1095,7 +1120,9 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n                 color: '#888'\n               }}>\n                 {(() => {\n-                  const commentCount = timelineByDate.get(viewingImage.date)?.comments?.length || 0;\n+                  const commentCount =\n+                    (allCommentsByDate.get(viewingImage.date)?.length)\n+                    ?? (timelineByDate.get(viewingImage.date)?.comments?.length || 0);\n                   return t('timeline.entryCount', { count: commentCount });\n                 })()}\n               </div>"
    },
    {
      "sha": "b65073f82dda2d4bbace33c0dafe9c46d9e38957",
      "filename": "frontend/src/utils/sessionGrouping.ts",
      "status": "removed",
      "additions": 0,
      "deletions": 76,
      "changes": 76,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/878d4289ef68d2dae43aba9c2cdb779a99118c45/frontend%2Fsrc%2Futils%2FsessionGrouping.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/878d4289ef68d2dae43aba9c2cdb779a99118c45/frontend%2Fsrc%2Futils%2FsessionGrouping.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Futils%2FsessionGrouping.ts?ref=878d4289ef68d2dae43aba9c2cdb779a99118c45",
      "patch": "@@ -1,76 +0,0 @@\n-import type { CalendarEntry } from './calendarStorage';\n-import { extractFirstLine, getTodayKey } from './calendarStorage';\n-import type { EditorState } from '../engine/EditorEngine';\n-import { getLocalDayKey, parseFlexibleTimestamp } from './timezone';\n-\n-type ListSessionsFn = () => Promise<any[]>;\n-type GetSessionFn = (id: string) => Promise<any>;\n-\n-function getSessionTimestamp(sessionMeta: any, fullSession: any): Date | null {\n-  const stateTimestamp = parseFlexibleTimestamp(fullSession?.editor_state?.createdAt);\n-  if (stateTimestamp) return stateTimestamp;\n-\n-  const createdAt = parseFlexibleTimestamp(fullSession?.created_at || sessionMeta?.created_at);\n-  if (createdAt) return createdAt;\n-\n-  const updatedAt = parseFlexibleTimestamp(fullSession?.updated_at || sessionMeta?.updated_at);\n-  return updatedAt;\n-}\n-\n-function getSessionDateKey(session: any, fullSession: any, timezone: string): string {\n-  const timestamp = getSessionTimestamp(session, fullSession);\n-  if (!timestamp) {\n-    console.warn('Session missing timestamp data', session?.id);\n-    return getTodayKey();\n-  }\n-  return getLocalDayKey(timestamp, timezone) ?? getTodayKey();\n-}\n-\n-function getEntryFirstLine(sessionName: string | undefined, state?: EditorState): string {\n-  if (sessionName && sessionName.trim().length > 0) {\n-    return sessionName.trim();\n-  }\n-  if (state) {\n-    return extractFirstLine(state);\n-  }\n-  return 'Untitled';\n-}\n-\n-export async function loadSessionsGroupedByDate(\n-  listSessions: ListSessionsFn,\n-  getSession: GetSessionFn,\n-  options: { requireName?: boolean; timezone?: string } = {}\n-): Promise<Record<string, CalendarEntry[]>> {\n-  const { requireName = false, timezone = 'UTC' } = options;\n-  const sessions = await listSessions();\n-  const grouped: Record<string, CalendarEntry[]> = {};\n-\n-  for (const session of sessions) {\n-    if (requireName && !session.name) continue;\n-\n-    try {\n-      const fullSession = await getSession(session.id);\n-      if (!fullSession?.editor_state) continue;\n-\n-      const dateKey = getSessionDateKey(session, fullSession, timezone);\n-      const firstLine = getEntryFirstLine(session.name, fullSession.editor_state);\n-      if (!grouped[dateKey]) {\n-        grouped[dateKey] = [];\n-      }\n-\n-      const timestamp = getSessionTimestamp(session, fullSession);\n-      const displayTimestamp = timestamp ? timestamp.getTime() : Date.now();\n-\n-      grouped[dateKey].push({\n-        id: session.id,\n-        timestamp: displayTimestamp,\n-        state: fullSession.editor_state,\n-        firstLine\n-      });\n-    } catch (error) {\n-      console.error(`Failed to load session ${session.id}:`, error);\n-    }\n-  }\n-\n-  return grouped;\n-}"
    }
  ]
}