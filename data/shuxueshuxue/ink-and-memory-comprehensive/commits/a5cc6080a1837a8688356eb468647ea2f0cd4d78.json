{
  "sha": "a5cc6080a1837a8688356eb468647ea2f0cd4d78",
  "node_id": "C_kwDOP2Zrm9oAKGE1Y2M2MDgwYTE4MzdhODY4ODM1NmViNDY4NjQ3ZWEyZjBjZDRkNzg",
  "commit": {
    "author": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-12-11T12:50:52Z"
    },
    "committer": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-12-11T12:50:52Z"
    },
    "message": "add comment and inspiration hook",
    "tree": {
      "sha": "78e158ecbf5512b3bc9eac3e0d69faf835d59ecf",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/trees/78e158ecbf5512b3bc9eac3e0d69faf835d59ecf"
    },
    "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/commits/a5cc6080a1837a8688356eb468647ea2f0cd4d78",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/a5cc6080a1837a8688356eb468647ea2f0cd4d78",
  "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/a5cc6080a1837a8688356eb468647ea2f0cd4d78",
  "comments_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/a5cc6080a1837a8688356eb468647ea2f0cd4d78/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "328acbae45eb7e15d90f3ea0f3cb0adc055f4c91",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/328acbae45eb7e15d90f3ea0f3cb0adc055f4c91",
      "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/328acbae45eb7e15d90f3ea0f3cb0adc055f4c91"
    }
  ],
  "stats": {
    "total": 1148,
    "additions": 659,
    "deletions": 489
  },
  "files": [
    {
      "sha": "e0cd2c2f8ae12a737aca49d131569294008f554c",
      "filename": ".gitignore",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a5cc6080a1837a8688356eb468647ea2f0cd4d78/.gitignore",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a5cc6080a1837a8688356eb468647ea2f0cd4d78/.gitignore",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/.gitignore?ref=a5cc6080a1837a8688356eb468647ea2f0cd4d78",
      "patch": "@@ -9,6 +9,7 @@ __pycache__/\n *.pyc\n AGENTS.md\n operation_book.md\n+.operations\n backend/pyrightconfig.json\n \n # Test artifacts"
    },
    {
      "sha": "886996c05b0237f4b57e5dab8c7b94d12a1d4467",
      "filename": "frontend/src/App.tsx",
      "status": "modified",
      "additions": 106,
      "deletions": 488,
      "changes": 594,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a5cc6080a1837a8688356eb468647ea2f0cd4d78/frontend%2Fsrc%2FApp.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a5cc6080a1837a8688356eb468647ea2f0cd4d78/frontend%2Fsrc%2FApp.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2FApp.tsx?ref=a5cc6080a1837a8688356eb468647ea2f0cd4d78",
      "patch": "@@ -1,3 +1,4 @@\n+// App.tsx\n import React, { useState, useEffect, useLayoutEffect, useRef, useCallback, useMemo } from 'react';\n import { useTranslation } from 'react-i18next';\n import type { Commentor, EditorState, TextCell } from './engine/EditorEngine';\n@@ -22,7 +23,7 @@ import ChatWidgetUI from './components/ChatWidgetUI';\n import StateChooser from './components/StateChooser';\n import type { VoiceConfig } from './api/voiceApi';\n import { getVoices, getMetaPrompt, getStateConfig } from './utils/voiceStorage';\n-import { getDefaultVoices, chatWithVoice, importLocalData, getSuggestion, loadVoicesFromDecks, type VoiceInspiration } from './api/voiceApi';\n+import { getDefaultVoices, chatWithVoice, importLocalData, loadVoicesFromDecks } from './api/voiceApi';\n import { useMobile } from './utils/mobileDetect';\n import { CommentGroupCard } from './components/CommentCard';\n import { findNormalizedPhrase } from './utils/textNormalize';\n@@ -32,6 +33,9 @@ import RegisterForm from './components/Auth/RegisterForm';\n import { STORAGE_KEYS } from './constants/storageKeys';\n import { getLocalDayKey, getTodayKeyInTimezone } from './utils/timezone';\n import { useSessionLifecycle } from './hooks/useSessionLifecycle';\n+import { useInspiration } from './hooks/useInspiration';\n+import { InspirationHint } from './components/Editor/InspirationHint';\n+import { useComments } from './hooks/useComments';\n \n // @@@ Icon map with React Icons\n const iconMap = {\n@@ -135,12 +139,6 @@ export default function App() {\n \n   // @@@ Track local text per cell ID for IME composition\n   const [composingCells, setComposingCells] = useState<Set<string>>(new Set());\n-  const [groupPages, setGroupPages] = useState<Map<string, number>>(new Map());\n-  const [cursorPosition, setCursorPosition] = useState<number>(0);\n-  const [cursorCellId, setCursorCellId] = useState<string | null>(null);\n-\n-  // @@@ Mobile-specific: Track which comment is at cursor for popup display\n-  const [mobileActiveComment, setMobileActiveComment] = useState<Commentor | null>(null);\n \n   // @@@ Chat widget state\n   const [dropdownVisible, setDropdownVisible] = useState(false);\n@@ -169,24 +167,51 @@ export default function App() {\n   const lastUpdateTime = useRef<number>(0);\n   const voiceInputNewContent = useRef<string>('');\n \n-  const stopTalking = useRef(() => {setUserTalking(false)});\n-\n-  // @@@ Comment expansion state (for action toolbar + chat dropdown)\n-  const [expandedCommentId, setExpandedCommentId] = useState<string | null>(null);\n-  const [commentChatProcessing, setCommentChatProcessing] = useState<Set<string>>(new Set());\n+  const stopTalking = useRef(() => { setUserTalking(false) });\n \n-  // @@@ Writing suggestion state\n-  const [currentInspiration, setCurrentInspiration] = useState<VoiceInspiration | null>(null);\n-  const [inspirationDisappearing, setInspirationDisappearing] = useState(false);\n-  const prevInspirationRef = useRef<VoiceInspiration | null>(null);\n-  const [_suggestionSnapshot, setSuggestionSnapshot] = useState<string>('');  // Not used yet\n-  const suggestionTimerRef = useRef<number | null>(null);\n+  // @@@ Writing inspiration/suggestion state\n+  const {\n+    currentInspiration,\n+    isDisappearing: inspirationDisappearing,\n+    isAppearing: inspirationAppearing,\n+    onTextChange: onInspirationTextChange,\n+    setTextGetter: setInspirationTextGetter,\n+  } = useInspiration();\n+\n+  // @@@ Provide text getter to inspiration hook for validation\n+  useEffect(() => {\n+    setInspirationTextGetter(() => {\n+      if (!engineRef.current) return '';\n+      const cells = engineRef.current.getState().cells;\n+      return cells\n+        .filter(c => c.type === 'text')\n+        .map(c => (c as TextCell).content)\n+        .join('');\n+    });\n+  }, [setInspirationTextGetter]);\n \n-  // @@@ Detect if this is a new inspiration appearing (different from previous)\n-  // Only check appearing when NOT disappearing (to avoid conflict)\n-  const inspirationAppearing = !inspirationDisappearing &&\n-    currentInspiration !== null &&\n-    currentInspiration !== prevInspirationRef.current;\n+  // @@@ Comment management (grouping, navigation, chat)\n+  const {\n+    commentGroups,\n+    groupPages,\n+    handleGroupNavigate,\n+    expandedCommentId,\n+    setExpandedCommentId,\n+    mobileActiveComment,\n+    handleCursorChange,\n+    handleCommentStar,\n+    handleCommentKill,\n+    handleCommentChatSend,\n+    commentChatProcessing,\n+  } = useComments({\n+    state,\n+    textareaRefs,\n+    refsReady,\n+    selectedState,\n+    stateConfig,\n+    isMobile,\n+    engineRef,\n+  });\n \n   // @@@ CRITICAL: Resize textareas then restore scroll position\n   // Order matters: resize first (changes content height), then restore scroll\n@@ -227,32 +252,6 @@ export default function App() {\n   }, [selectedState]);\n \n \n-  // @@@ Handle inspiration disappearing animation\n-  useEffect(() => {\n-    if (inspirationDisappearing) {\n-      // Wait for animation to complete (800ms) then clear inspiration\n-      const timer = setTimeout(() => {\n-        setCurrentInspiration(null);\n-        setInspirationDisappearing(false);\n-      }, 800);\n-      return () => clearTimeout(timer);\n-    }\n-  }, [inspirationDisappearing]);\n-\n-  // @@@ Update prevInspiration ref after render to trigger appearing animation\n-  useEffect(() => {\n-    if (currentInspiration) {\n-      setInspirationDisappearing(false);\n-\n-      // Wait for next frame to allow CSS transition to detect the change\n-      requestAnimationFrame(() => {\n-        prevInspirationRef.current = currentInspiration;\n-        // @@@ Force re-render to show the appeared state (opacity 1)\n-        setRefsReady(prev => prev + 1);\n-      });\n-    }\n-  }, [currentInspiration]);\n-\n   // @@@ Fetch default voices from backend and load from deck system\n   useEffect(() => {\n     getDefaultVoices().then(async backendVoices => {\n@@ -392,232 +391,6 @@ export default function App() {\n     return () => window.clearTimeout(timer);\n   }, [state, refsReady]);\n \n-  // @@@ Group comments by 2-row blocks, accounting for widgets between cells\n-  const commentGroups = useMemo(() => {\n-    const groups = new Map<string, {\n-      comments: Commentor[];\n-      cellId: string;\n-      blockIndex: number;\n-      visualLineStart: number;\n-      visualLineEnd: number;\n-      maxLineWidth: number;\n-      centerY: number;\n-    }>();\n-\n-    if (!state) return groups;\n-\n-    // Get any available textarea ref for style calculations\n-    const anyTextarea = Array.from(textareaRefs.current.values())[0];\n-    if (!anyTextarea) return groups;\n-\n-    const maxTextareaWidth = 600;\n-\n-    const computedStyle = window.getComputedStyle(anyTextarea);\n-    const fontSize = parseFloat(computedStyle.fontSize) || 18;\n-    const lineHeightRatio = parseFloat(computedStyle.lineHeight) / fontSize || 1.8;\n-    const lineHeight = fontSize * lineHeightRatio;\n-\n-    const canvas = document.createElement('canvas');\n-    const ctx = canvas.getContext('2d');\n-    if (ctx) {\n-      const fontFamily = computedStyle.fontFamily || 'system-ui, -apple-system, sans-serif';\n-      ctx.font = `${fontSize}px ${fontFamily}`;\n-    }\n-\n-    // @@@ Process each text cell separately\n-    state.cells.forEach(cell => {\n-      if (cell.type !== 'text') return;\n-\n-      const textCell = cell as TextCell;\n-      const text = textCell.content;\n-\n-      // Calculate visual lines for this cell\n-      const charToVisualLine: number[] = new Array(text.length);\n-      let currentVisualLine = 0;\n-      let currentLineStartIndex = 0;\n-\n-      for (let i = 0; i < text.length; i++) {\n-        charToVisualLine[i] = currentVisualLine;\n-\n-        if (text[i] === '\\n') {\n-          currentVisualLine++;\n-          currentLineStartIndex = i + 1;\n-        } else {\n-          const currentLineText = text.substring(currentLineStartIndex, i + 1);\n-          const width = ctx ? ctx.measureText(currentLineText).width : currentLineText.length * (fontSize * 0.6);\n-\n-          if (width > maxTextareaWidth && i > currentLineStartIndex) {\n-            currentVisualLine++;\n-            currentLineStartIndex = i;\n-            charToVisualLine[i] = currentVisualLine;\n-          }\n-        }\n-      }\n-\n-      // Find comments in this cell\n-      state.commentors\n-        .filter(c => c.appliedAt)\n-        .forEach(commentor => {\n-          const index = findNormalizedPhrase(text, commentor.phrase);\n-          if (index === -1) return;\n-\n-          const visualLineNumber = charToVisualLine[index] || 0;\n-          const blockIndex = Math.floor(visualLineNumber / 2);\n-          const visualLineStart = blockIndex * 2;\n-          const visualLineEnd = visualLineStart + 1;\n-\n-          // Create unique group key per cell\n-          const groupKey = `${cell.id}-${blockIndex}`;\n-\n-          if (!groups.has(groupKey)) {\n-            let maxWidth = 0;\n-\n-            for (let i = 0; i < text.length; i++) {\n-              const vLine = charToVisualLine[i];\n-              if (vLine === visualLineStart || vLine === visualLineEnd) {\n-                let lineEnd = i;\n-                while (lineEnd < text.length && charToVisualLine[lineEnd] === vLine) {\n-                  lineEnd++;\n-                }\n-                const lineText = text.substring(i, lineEnd);\n-                const width = ctx ? ctx.measureText(lineText).width : lineText.length * (fontSize * 0.6);\n-                maxWidth = Math.max(maxWidth, Math.min(width, maxTextareaWidth));\n-                i = lineEnd - 1;\n-              }\n-            }\n-\n-            const centerY = (visualLineStart + 1) * lineHeight;\n-\n-            groups.set(groupKey, {\n-              comments: [],\n-              cellId: cell.id,\n-              blockIndex,\n-              visualLineStart,\n-              visualLineEnd,\n-              maxLineWidth: maxWidth,\n-              centerY\n-            });\n-          }\n-\n-          groups.get(groupKey)!.comments.push(commentor);\n-        });\n-    });\n-\n-    return groups;\n-  }, [state?.commentors, state, refsReady, selectedState]);\n-\n-  useEffect(() => {\n-    if (!commentGroups) return;\n-\n-    setGroupPages(prev => {\n-      const next = new Map(prev);\n-\n-      commentGroups.forEach((group, groupKey) => {\n-        if (group.comments.length === 0) {\n-          next.delete(groupKey);\n-          return;\n-        }\n-\n-        const currentPage = prev.get(groupKey) || 0;\n-        const maxPage = group.comments.length - 1;\n-\n-        if (group.comments.length > 1 && currentPage < maxPage) {\n-          next.set(groupKey, maxPage);\n-        } else if (currentPage > maxPage) {\n-          next.set(groupKey, maxPage);\n-        }\n-      });\n-\n-      prev.forEach((_, groupKey) => {\n-        if (!commentGroups.has(groupKey)) {\n-          next.delete(groupKey);\n-        }\n-      });\n-\n-      return next;\n-    });\n-  }, [commentGroups]);\n-\n-  const handleGroupNavigate = useCallback((groupKey: string, newIndex: number) => {\n-    const group = commentGroups.get(groupKey);\n-    if (!group) return;\n-\n-    setGroupPages(prev => {\n-      const next = new Map(prev);\n-      next.set(groupKey, newIndex);\n-      return next;\n-    });\n-\n-    // @@@ Update expanded comment ID ONLY if something in this group is already expanded\n-    // This keeps the card expanded while switching between comments\n-    const anyExpanded = group.comments.some(c => c.id === expandedCommentId);\n-    if (anyExpanded && group.comments[newIndex]) {\n-      setExpandedCommentId(group.comments[newIndex].id);\n-    }\n-  }, [commentGroups, expandedCommentId]);\n-\n-  // @@@ Cursor-based comment navigation (per-cell)\n-  useEffect(() => {\n-    if (!state || !cursorCellId) return;\n-\n-    // Get text for the cell where cursor is\n-    const cell = state.cells.find(c => c.id === cursorCellId);\n-    if (!cell || cell.type !== 'text') return;\n-\n-    const cellText = (cell as TextCell).content;\n-    const appliedComments = state.commentors.filter(c => c.appliedAt);\n-    if (appliedComments.length === 0) {\n-      // Clear mobile comment if no comments exist\n-      if (isMobile) setMobileActiveComment(null);\n-      return;\n-    }\n-\n-    // Find comment at cursor position within this cell's text\n-    let foundComment: Commentor | null = null;\n-    for (const comment of appliedComments) {\n-      const index = findNormalizedPhrase(cellText, comment.phrase);\n-      if (index !== -1) {\n-        const start = index;\n-        const end = index + comment.phrase.length;\n-\n-        if (cursorPosition >= start && cursorPosition <= end) {\n-          foundComment = comment;\n-          break;\n-        }\n-      }\n-    }\n-\n-    // @@@ Mobile: Set active comment for popup display\n-    if (isMobile) {\n-      setMobileActiveComment(foundComment);\n-    }\n-\n-    if (!foundComment) return;\n-\n-    // @@@ Desktop: Navigate to comment at cursor position\n-    if (!isMobile) {\n-      commentGroups.forEach((group, groupKey) => {\n-        // Only update groups in the current cell\n-        if (group.cellId !== cursorCellId) return;\n-\n-        const commentIndex = group.comments.findIndex(c => c.id === foundComment!.id);\n-        if (commentIndex !== -1) {\n-          // Don't navigate if a comment in this group is expanded\n-          const groupHasExpanded = group.comments.some(c => c.id === expandedCommentId);\n-          if (groupHasExpanded) return;\n-\n-          setGroupPages(prev => {\n-            const next = new Map(prev);\n-            if (next.get(groupKey) !== commentIndex) {\n-              next.set(groupKey, commentIndex);\n-            }\n-            return next;\n-          });\n-        }\n-      });\n-    }\n-  }, [cursorPosition, cursorCellId, state, commentGroups, isMobile, expandedCommentId]);\n-\n   // @@@ Per-cell text change handler\n   const handleTextChange = useCallback((cellId: string, newText: string) => {\n     setLocalTexts(prev => {\n@@ -626,17 +399,6 @@ export default function App() {\n       return next;\n     });\n \n-    // @@@ Trigger disappearing animation on typing (if inspiration exists)\n-    if (currentInspiration) {\n-      setInspirationDisappearing(true);\n-    }\n-\n-    // @@@ Clear existing suggestion timer\n-    if (suggestionTimerRef.current) {\n-      clearTimeout(suggestionTimerRef.current);\n-      suggestionTimerRef.current = null;\n-    }\n-\n     // @@@ Auto-resize textarea to prevent internal scrolling\n     const textarea = textareaRefs.current.get(cellId);\n     if (textarea) {\n@@ -656,46 +418,12 @@ export default function App() {\n       engineRef.current.updateTextCell(cellId, newText);\n     }\n \n-    // @@@ Start 2-second debounce timer for suggestions\n-    suggestionTimerRef.current = setTimeout(async () => {\n-      // Get all text from all text cells\n-      const allText = state?.cells\n-        .filter(c => c.type === 'text')\n-        .map(c => (c as TextCell).content)\n-        .join('') || '';\n-\n-      if (allText.trim().length < 10) {\n-        return;\n-      }\n-\n-      // Capture snapshot for validation\n-      const snapshot = allText;\n-      setSuggestionSnapshot(snapshot);\n-\n-      try {\n-        const metaPrompt = getMetaPrompt();\n-        const statePrompt = selectedState && stateConfig.states[selectedState]\n-          ? stateConfig.states[selectedState].prompt\n-          : '';\n-\n-        console.log('\ud83d\ude80 Calling getSuggestion API...');\n-        const suggestion = await getSuggestion(allText, metaPrompt, statePrompt);\n-\n-        // @@@ Validate text hasn't changed since request was sent\n-        const currentCells = engineRef.current?.getState().cells;\n-        const currentText = currentCells\n-          ?.filter(c => c.type === 'text')\n-          .map(c => (c as TextCell).content)\n-          .join('') || '';\n-\n-        if (suggestion && currentText === snapshot) {\n-          setCurrentInspiration(suggestion);\n-        }\n-      } catch (error) {\n-        console.error('Failed to get inspiration:', error);\n-      }\n-    }, 2000);\n-  }, [composingCells, dropdownVisible, dropdownTriggerCellId, state, selectedState, stateConfig]);\n+    const allText = state?.cells\n+      .filter(c => c.type === 'text')\n+      .map(c => (c as TextCell).content)\n+      .join('') || '';\n+    onInspirationTextChange(allText, selectedState);\n+  }, [composingCells, dropdownVisible, dropdownTriggerCellId, state, selectedState, onInspirationTextChange]);\n \n   // @@@ Per-cell composition handlers\n   const handleCompositionStart = useCallback((cellId: string) => {\n@@ -738,11 +466,6 @@ export default function App() {\n     }, 0);\n   }, []);\n \n-  const handleCursorChange = useCallback((cellId: string, e: React.SyntheticEvent<HTMLTextAreaElement>) => {\n-    setCursorPosition(e.currentTarget.selectionStart);\n-    setCursorCellId(cellId);\n-  }, []);\n-\n   const handleStartFresh = useCallback(() => {\n     setShowWarning(true);\n   }, []);\n@@ -1225,76 +948,6 @@ export default function App() {\n     setGuestMode(true);\n   }, []);\n \n-  // @@@ Comment interaction handlers\n-  const handleCommentStar = useCallback((commentId: string) => {\n-    if (!engineRef.current) return;\n-    const comment = engineRef.current.getComment(commentId);\n-    if (!comment) return;\n-\n-    // Toggle star (if already starred, unstar)\n-    const newFeedback = comment.feedback === 'star' ? undefined : 'star';\n-    engineRef.current.setCommentFeedback(commentId, newFeedback as any);\n-  }, []);\n-\n-  const handleCommentKill = useCallback((commentId: string) => {\n-    if (!engineRef.current) return;\n-    engineRef.current.setCommentFeedback(commentId, 'kill');\n-    // Close expansion after killing\n-    setExpandedCommentId(null);\n-  }, []);\n-\n-  const handleCommentChatSend = useCallback(async (commentId: string, message: string) => {\n-    if (!engineRef.current || !state) return;\n-\n-    const comment = engineRef.current.getComment(commentId);\n-    if (!comment) return;\n-\n-    // Add user message immediately\n-    engineRef.current.addCommentChatMessage(commentId, 'user', message);\n-    setCommentChatProcessing(prev => new Set(prev).add(commentId));\n-\n-    try {\n-      // Get all text from text cells\n-      const allText = state.cells\n-        .filter(c => c.type === 'text')\n-        .map(c => (c as TextCell).content)\n-        .join('');\n-\n-      // Get conversation history (excluding the message we just added)\n-      const chatHistory = comment.chatHistory?.slice(0, -1) || [];\n-\n-      const metaPrompt = getMetaPrompt();\n-      const statePrompt = selectedState && stateConfig.states[selectedState]\n-        ? stateConfig.states[selectedState].prompt\n-        : '';\n-\n-      // @@@ Use voiceId if available (new comments), fall back to voice name (old comments)\n-      // Backend loads voice config from database using user_id from JWT\n-      const voiceId = comment.voiceId || comment.voice;\n-\n-      const response = await chatWithVoice(\n-        voiceId,\n-        chatHistory,\n-        message,\n-        allText,\n-        metaPrompt,\n-        statePrompt\n-      );\n-\n-      // Add assistant response\n-      engineRef.current.addCommentChatMessage(commentId, 'assistant', response);\n-    } catch (error) {\n-      console.error('Comment chat failed:', error);\n-      engineRef.current.addCommentChatMessage(commentId, 'assistant', 'Sorry, I encountered an error.');\n-    } finally {\n-      setCommentChatProcessing(prev => {\n-        const next = new Set(prev);\n-        next.delete(commentId);\n-        return next;\n-      });\n-    }\n-  }, [state, voiceConfigs, selectedState, stateConfig]);\n-\n   // @@@ Handle @ key press for agent dropdown\n   const handleKeyDown = useCallback((cellId: string, e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n     if (e.key === '@' && !composingCells.has(cellId)) {\n@@ -1673,7 +1326,7 @@ export default function App() {\n           {/* New Session \"+\" button - top left (desktop only) */}\n           {!isMobile && (\n             <button\n-                onClick={handleNewSessionClick}\n+              onClick={handleNewSessionClick}\n               title=\"New Session\"\n               style={{\n                 position: 'fixed',\n@@ -1926,47 +1579,12 @@ export default function App() {\n                     return null;\n                   })}\n \n-                  {/* @@@ Inline Inspiration - appears after last text cell with icon and grey text */}\n-                  {currentInspiration && (\n-                    <div style={{\n-                      display: 'flex',\n-                      alignItems: 'center',\n-                      gap: '10px',\n-                      marginTop: '12px',\n-                      color: '#999',\n-                      fontSize: '16px',\n-                      fontStyle: 'italic',\n-                      pointerEvents: 'none',\n-                      transition: 'all 0.8s cubic-bezier(0.4, 0, 0.6, 1)',\n-                      // @@@ Appearing animation: reverse of disappearing (emerge from paper)\n-                      opacity: inspirationDisappearing ? 0 : (inspirationAppearing ? 0 : 1),\n-                      transform: inspirationDisappearing\n-                        ? 'scale(0.95) translateY(-3px)'\n-                        : (inspirationAppearing ? 'scale(0.95) translateY(-3px)' : 'scale(1) translateY(0)'),\n-                      filter: inspirationDisappearing\n-                        ? 'blur(2px)'\n-                        : (inspirationAppearing ? 'blur(2px)' : 'blur(0)'),\n-                    }}\n-                    >\n-                      {/* Voice Icon */}\n-                      <div style={{\n-                        fontSize: '24px',\n-                        flexShrink: 0,\n-                        color: '#666'\n-                      }}>\n-                        {React.createElement(iconMap[currentInspiration.icon as keyof typeof iconMap] || FaBrain)}\n-                      </div>\n-\n-                      {/* Inspiration Text */}\n-                      <div>\n-                        <span style={{ fontWeight: 'normal', color: '#888' }}>\n-                          {currentInspiration.voice}:\n-                        </span>\n-                        {' '}\n-                        {currentInspiration.inspiration}\n-                      </div>\n-                    </div>\n-                  )}\n+                  {/* @@@ Inline Inspiration */}\n+                  <InspirationHint\n+                    inspiration={currentInspiration}\n+                    isDisappearing={inspirationDisappearing}\n+                    isAppearing={inspirationAppearing}\n+                  />\n                 </div>\n \n                 {/* Comments layer (absolute positioned) - hide on mobile */}\n@@ -2003,51 +1621,51 @@ export default function App() {\n                     const lineWidthToUse = commentsAligned ? globalMaxLineWidth : group.maxLineWidth;\n                     const leftPosition = containerPadding + lineWidthToUse + gap + (lineHeight * 2);  // @@@ Move right 2 line heights\n \n-                  // @@@ Position using offsetTop (scroll-independent)\n-                  // centerY is already relative to cell's top, so just add:\n-                  // - cellOffsetTop: position relative to content container\n-                  // - 20px: scroll container top padding\n-                  // - 32px: StateChooser fixed height\n-                  // - 10.8px: StateChooser marginBottom\n-                  // - subtract lineHeight * 2: move up to top of 2-line block\n-                  // - subtract lineHeight / 3: additional upward adjustment\n-                  const topPosition = cellOffsetTop + group.centerY + 20 + 32 + 10.8 - lineHeight * 2 - (lineHeight / 3);\n-\n-                  // @@@ If expanded, use the expanded comment ID (stable), otherwise use current index\n-                  const isExpanded = group.comments.some(c => c.id === expandedCommentId);\n-                  const displayedComment = isExpanded\n-                    ? group.comments.find(c => c.id === expandedCommentId)!\n-                    : group.comments[currentIndex];\n-                  const displayedIndex = isExpanded\n-                    ? group.comments.findIndex(c => c.id === expandedCommentId)\n-                    : currentIndex;\n-\n-                  if (!displayedComment) return null;\n-\n-                  return (\n-                    <CommentGroupCard\n-                      key={groupKey}\n-                      comments={group.comments}\n-                      currentIndex={displayedIndex}\n-                      onNavigate={(idx) => handleGroupNavigate(groupKey, idx)}\n-                      position={{\n-                        top: topPosition,\n-                        left: leftPosition\n-                      }}\n-                      isExpanded={isExpanded}\n-                      onToggleExpand={() => {\n-                        setExpandedCommentId(prev => {\n-                          const anyExpanded = group.comments.some(c => c.id === prev);\n-                          if (anyExpanded) return null;\n-                          return displayedComment.id;\n-                        });\n-                      }}\n-                      onStar={() => handleCommentStar(displayedComment.id)}\n-                      onKill={() => handleCommentKill(displayedComment.id)}\n-                      onSendChatMessage={(msg) => handleCommentChatSend(displayedComment.id, msg)}\n-                      isChatProcessing={commentChatProcessing.has(displayedComment.id)}\n-                      voiceConfigs={voiceConfigs}\n-                    />\n+                    // @@@ Position using offsetTop (scroll-independent)\n+                    // centerY is already relative to cell's top, so just add:\n+                    // - cellOffsetTop: position relative to content container\n+                    // - 20px: scroll container top padding\n+                    // - 32px: StateChooser fixed height\n+                    // - 10.8px: StateChooser marginBottom\n+                    // - subtract lineHeight * 2: move up to top of 2-line block\n+                    // - subtract lineHeight / 3: additional upward adjustment\n+                    const topPosition = cellOffsetTop + group.centerY + 20 + 32 + 10.8 - lineHeight * 2 - (lineHeight / 3);\n+\n+                    // @@@ If expanded, use the expanded comment ID (stable), otherwise use current index\n+                    const isExpanded = group.comments.some(c => c.id === expandedCommentId);\n+                    const displayedComment = isExpanded\n+                      ? group.comments.find(c => c.id === expandedCommentId)!\n+                      : group.comments[currentIndex];\n+                    const displayedIndex = isExpanded\n+                      ? group.comments.findIndex(c => c.id === expandedCommentId)\n+                      : currentIndex;\n+\n+                    if (!displayedComment) return null;\n+\n+                    return (\n+                      <CommentGroupCard\n+                        key={groupKey}\n+                        comments={group.comments}\n+                        currentIndex={displayedIndex}\n+                        onNavigate={(idx) => handleGroupNavigate(groupKey, idx)}\n+                        position={{\n+                          top: topPosition,\n+                          left: leftPosition\n+                        }}\n+                        isExpanded={isExpanded}\n+                        onToggleExpand={() => {\n+                          setExpandedCommentId(prev => {\n+                            const anyExpanded = group.comments.some(c => c.id === prev);\n+                            if (anyExpanded) return null;\n+                            return displayedComment.id;\n+                          });\n+                        }}\n+                        onStar={() => handleCommentStar(displayedComment.id)}\n+                        onKill={() => handleCommentKill(displayedComment.id)}\n+                        onSendChatMessage={(msg) => handleCommentChatSend(displayedComment.id, msg)}\n+                        isChatProcessing={commentChatProcessing.has(displayedComment.id)}\n+                        voiceConfigs={voiceConfigs}\n+                      />\n                     );\n                   });\n                 })()}"
    },
    {
      "sha": "6bebdc9d9c6e9bafb42e8643377105ade6a7fcbb",
      "filename": "frontend/src/components/Editor/InspirationHint.tsx",
      "status": "added",
      "additions": 79,
      "deletions": 0,
      "changes": 79,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a5cc6080a1837a8688356eb468647ea2f0cd4d78/frontend%2Fsrc%2Fcomponents%2FEditor%2FInspirationHint.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a5cc6080a1837a8688356eb468647ea2f0cd4d78/frontend%2Fsrc%2Fcomponents%2FEditor%2FInspirationHint.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FEditor%2FInspirationHint.tsx?ref=a5cc6080a1837a8688356eb468647ea2f0cd4d78",
      "patch": "@@ -0,0 +1,79 @@\n+import {\n+  FaBrain, FaHeart, FaQuestion, FaCloud, FaTheaterMasks, FaEye,\n+  FaFistRaised, FaLightbulb, FaShieldAlt, FaWind, FaFire, FaCompass,\n+} from 'react-icons/fa';\n+import type { VoiceInspiration } from '../../api/voiceApi';\n+\n+const iconMap = {\n+  brain: FaBrain,\n+  heart: FaHeart,\n+  question: FaQuestion,\n+  cloud: FaCloud,\n+  masks: FaTheaterMasks,\n+  eye: FaEye,\n+  fist: FaFistRaised,\n+  lightbulb: FaLightbulb,\n+  shield: FaShieldAlt,\n+  wind: FaWind,\n+  fire: FaFire,\n+  compass: FaCompass,\n+};\n+\n+interface InspirationHintProps {\n+  inspiration: VoiceInspiration | null;\n+  isDisappearing: boolean;\n+  isAppearing: boolean;\n+}\n+\n+export function InspirationHint({\n+  inspiration,\n+  isDisappearing,\n+  isAppearing,\n+}: InspirationHintProps) {\n+  if (!inspiration) {\n+    return null;\n+  }\n+\n+  const Icon = iconMap[inspiration.icon as keyof typeof iconMap] || FaBrain;\n+\n+  return (\n+    <div\n+      style={{\n+        display: 'flex',\n+        alignItems: 'center',\n+        gap: '10px',\n+        marginTop: '12px',\n+        color: '#999',\n+        fontSize: '16px',\n+        fontStyle: 'italic',\n+        pointerEvents: 'none',\n+        transition: 'all 0.8s cubic-bezier(0.4, 0, 0.6, 1)',\n+        opacity: isDisappearing ? 0 : (isAppearing ? 0 : 1),\n+        transform: isDisappearing\n+          ? 'scale(0.95) translateY(-3px)'\n+          : (isAppearing ? 'scale(0.95) translateY(-3px)' : 'scale(1) translateY(0)'),\n+        filter: isDisappearing\n+          ? 'blur(2px)'\n+          : (isAppearing ? 'blur(2px)' : 'blur(0)'),\n+      }}\n+    >\n+      <div\n+        style={{\n+          fontSize: '24px',\n+          flexShrink: 0,\n+          color: '#666',\n+        }}\n+      >\n+        <Icon />\n+      </div>\n+\n+      <div>\n+        <span style={{ fontWeight: 'normal', color: '#888' }}>\n+          {inspiration.voice}:\n+        </span>\n+        {' '}\n+        {inspiration.inspiration}\n+      </div>\n+    </div>\n+  );\n+}"
    },
    {
      "sha": "8a7e76b75aebfdb7915396087ef44e0bbeea792c",
      "filename": "frontend/src/engine/EditorEngine.ts",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a5cc6080a1837a8688356eb468647ea2f0cd4d78/frontend%2Fsrc%2Fengine%2FEditorEngine.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a5cc6080a1837a8688356eb468647ea2f0cd4d78/frontend%2Fsrc%2Fengine%2FEditorEngine.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fengine%2FEditorEngine.ts?ref=a5cc6080a1837a8688356eb468647ea2f0cd4d78",
      "patch": "@@ -1,4 +1,5 @@\n /**\n+ * EditorEngine.ts\n  * Clean editor engine based on trace-based energy model\n  */\n \n@@ -650,7 +651,7 @@ export class EditorEngine {\n     // Always add if non-empty, or if this is the last cell (to allow continued writing)\n     const isLastCell = cellIndex === this.state.cells.length - 1;\n     const hasNextTextCell = cellIndex + 1 < this.state.cells.length &&\n-                           this.state.cells[cellIndex + 1].type === 'text';\n+      this.state.cells[cellIndex + 1].type === 'text';\n \n     if (afterText.length > 0 || (isLastCell && !hasNextTextCell)) {\n       replacementCells.push({"
    },
    {
      "sha": "5e00616485421f303615320bce3175e38ec2945b",
      "filename": "frontend/src/hooks/useComments.ts",
      "status": "added",
      "additions": 340,
      "deletions": 0,
      "changes": 340,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a5cc6080a1837a8688356eb468647ea2f0cd4d78/frontend%2Fsrc%2Fhooks%2FuseComments.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a5cc6080a1837a8688356eb468647ea2f0cd4d78/frontend%2Fsrc%2Fhooks%2FuseComments.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fhooks%2FuseComments.ts?ref=a5cc6080a1837a8688356eb468647ea2f0cd4d78",
      "patch": "@@ -0,0 +1,340 @@\n+import { useState, useEffect, useMemo, useCallback } from 'react';\n+import type { MutableRefObject, Dispatch, SetStateAction, SyntheticEvent } from 'react';\n+import type { EditorState, Commentor, TextCell, EditorEngine } from '../engine/EditorEngine';\n+import { findNormalizedPhrase } from '../utils/textNormalize';\n+import { getMetaPrompt, getStateConfig } from '../utils/voiceStorage';\n+import { chatWithVoice } from '../api/voiceApi';\n+\n+export interface CommentGroup {\n+  comments: Commentor[];\n+  cellId: string;\n+  blockIndex: number;\n+  visualLineStart: number;\n+  visualLineEnd: number;\n+  maxLineWidth: number;\n+  centerY: number;\n+}\n+\n+export interface UseCommentsOptions {\n+  state: EditorState | null;\n+  textareaRefs: MutableRefObject<Map<string, HTMLTextAreaElement>>;\n+  refsReady: number;\n+  selectedState: string | null;\n+  stateConfig: ReturnType<typeof getStateConfig>;\n+  isMobile: boolean;\n+  engineRef: MutableRefObject<EditorEngine | null>;\n+}\n+\n+export interface UseCommentsReturn {\n+  commentGroups: Map<string, CommentGroup>;\n+  groupPages: Map<string, number>;\n+  handleGroupNavigate: (groupKey: string, newIndex: number) => void;\n+  expandedCommentId: string | null;\n+  setExpandedCommentId: Dispatch<SetStateAction<string | null>>;\n+  mobileActiveComment: Commentor | null;\n+  cursorPosition: number;\n+  cursorCellId: string | null;\n+  handleCursorChange: (cellId: string, e: SyntheticEvent<HTMLTextAreaElement>) => void;\n+  handleCommentStar: (commentId: string) => void;\n+  handleCommentKill: (commentId: string) => void;\n+  handleCommentChatSend: (commentId: string, message: string) => Promise<void>;\n+  commentChatProcessing: Set<string>;\n+}\n+\n+// @@@ Comment management hook - groups, navigation, and chat handling\n+export function useComments({\n+  state,\n+  textareaRefs,\n+  refsReady,\n+  selectedState,\n+  stateConfig,\n+  isMobile,\n+  engineRef,\n+}: UseCommentsOptions): UseCommentsReturn {\n+  const [groupPages, setGroupPages] = useState<Map<string, number>>(new Map());\n+  const [cursorPosition, setCursorPosition] = useState<number>(0);\n+  const [cursorCellId, setCursorCellId] = useState<string | null>(null);\n+  const [mobileActiveComment, setMobileActiveComment] = useState<Commentor | null>(null);\n+  const [expandedCommentId, setExpandedCommentId] = useState<string | null>(null);\n+  const [commentChatProcessing, setCommentChatProcessing] = useState<Set<string>>(new Set());\n+\n+  const commentGroups = useMemo(() => {\n+    const groups = new Map<string, CommentGroup>();\n+\n+    if (!state) return groups;\n+\n+    const anyTextarea = Array.from(textareaRefs.current.values())[0];\n+    if (!anyTextarea) return groups;\n+\n+    const maxTextareaWidth = 600;\n+    const computedStyle = window.getComputedStyle(anyTextarea);\n+    const fontSize = parseFloat(computedStyle.fontSize) || 18;\n+    const lineHeightRatio = parseFloat(computedStyle.lineHeight) / fontSize || 1.8;\n+    const lineHeight = fontSize * lineHeightRatio;\n+\n+    const canvas = document.createElement('canvas');\n+    const ctx = canvas.getContext('2d');\n+    if (ctx) {\n+      const fontFamily = computedStyle.fontFamily || 'system-ui, -apple-system, sans-serif';\n+      ctx.font = `${fontSize}px ${fontFamily}`;\n+    }\n+\n+    state.cells.forEach(cell => {\n+      if (cell.type !== 'text') return;\n+\n+      const textCell = cell as TextCell;\n+      const text = textCell.content;\n+\n+      const charToVisualLine: number[] = new Array(text.length);\n+      let currentVisualLine = 0;\n+      let currentLineStartIndex = 0;\n+\n+      for (let i = 0; i < text.length; i++) {\n+        charToVisualLine[i] = currentVisualLine;\n+\n+        if (text[i] === '\\n') {\n+          currentVisualLine++;\n+          currentLineStartIndex = i + 1;\n+        } else {\n+          const currentLineText = text.substring(currentLineStartIndex, i + 1);\n+          const width = ctx ? ctx.measureText(currentLineText).width : currentLineText.length * (fontSize * 0.6);\n+\n+          if (width > maxTextareaWidth && i > currentLineStartIndex) {\n+            currentVisualLine++;\n+            currentLineStartIndex = i;\n+            charToVisualLine[i] = currentVisualLine;\n+          }\n+        }\n+      }\n+\n+      state.commentors\n+        .filter(c => c.appliedAt)\n+        .forEach(commentor => {\n+          const index = findNormalizedPhrase(text, commentor.phrase);\n+          if (index === -1) return;\n+\n+          const visualLineNumber = charToVisualLine[index] || 0;\n+          const blockIndex = Math.floor(visualLineNumber / 2);\n+          const visualLineStart = blockIndex * 2;\n+          const visualLineEnd = visualLineStart + 1;\n+          const groupKey = `${cell.id}-${blockIndex}`;\n+\n+          if (!groups.has(groupKey)) {\n+            let maxWidth = 0;\n+\n+            for (let i = 0; i < text.length; i++) {\n+              const vLine = charToVisualLine[i];\n+              if (vLine === visualLineStart || vLine === visualLineEnd) {\n+                let lineEnd = i;\n+                while (lineEnd < text.length && charToVisualLine[lineEnd] === vLine) {\n+                  lineEnd++;\n+                }\n+                const lineText = text.substring(i, lineEnd);\n+                const width = ctx ? ctx.measureText(lineText).width : lineText.length * (fontSize * 0.6);\n+                maxWidth = Math.max(maxWidth, Math.min(width, maxTextareaWidth));\n+                i = lineEnd - 1;\n+              }\n+            }\n+\n+            const centerY = (visualLineStart + 1) * lineHeight;\n+\n+            groups.set(groupKey, {\n+              comments: [],\n+              cellId: cell.id,\n+              blockIndex,\n+              visualLineStart,\n+              visualLineEnd,\n+              maxLineWidth: maxWidth,\n+              centerY\n+            });\n+          }\n+\n+          groups.get(groupKey)!.comments.push(commentor);\n+        });\n+    });\n+\n+    return groups;\n+  }, [state?.commentors, state, refsReady, selectedState]);\n+\n+  useEffect(() => {\n+    if (!commentGroups) return;\n+\n+    setGroupPages(prev => {\n+      const next = new Map(prev);\n+\n+      commentGroups.forEach((group, groupKey) => {\n+        if (group.comments.length === 0) {\n+          next.delete(groupKey);\n+          return;\n+        }\n+\n+        const currentPage = prev.get(groupKey) || 0;\n+        const maxPage = group.comments.length - 1;\n+\n+        if (group.comments.length > 1 && currentPage < maxPage) {\n+          next.set(groupKey, maxPage);\n+        } else if (currentPage > maxPage) {\n+          next.set(groupKey, maxPage);\n+        }\n+      });\n+\n+      prev.forEach((_, groupKey) => {\n+        if (!commentGroups.has(groupKey)) {\n+          next.delete(groupKey);\n+        }\n+      });\n+\n+      return next;\n+    });\n+  }, [commentGroups]);\n+\n+  const handleGroupNavigate = useCallback((groupKey: string, newIndex: number) => {\n+    const group = commentGroups.get(groupKey);\n+    if (!group) return;\n+\n+    setGroupPages(prev => {\n+      const next = new Map(prev);\n+      next.set(groupKey, newIndex);\n+      return next;\n+    });\n+\n+    const anyExpanded = group.comments.some(c => c.id === expandedCommentId);\n+    if (anyExpanded && group.comments[newIndex]) {\n+      setExpandedCommentId(group.comments[newIndex].id);\n+    }\n+  }, [commentGroups, expandedCommentId]);\n+\n+  useEffect(() => {\n+    if (!state || !cursorCellId) return;\n+\n+    const cell = state.cells.find(c => c.id === cursorCellId);\n+    if (!cell || cell.type !== 'text') return;\n+\n+    const cellText = (cell as TextCell).content;\n+    const appliedComments = state.commentors.filter(c => c.appliedAt);\n+    if (appliedComments.length === 0) {\n+      if (isMobile) setMobileActiveComment(null);\n+      return;\n+    }\n+\n+    let foundComment: Commentor | null = null;\n+    for (const comment of appliedComments) {\n+      const index = findNormalizedPhrase(cellText, comment.phrase);\n+      if (index !== -1) {\n+        const start = index;\n+        const end = index + comment.phrase.length;\n+\n+        if (cursorPosition >= start && cursorPosition <= end) {\n+          foundComment = comment;\n+          break;\n+        }\n+      }\n+    }\n+\n+    if (isMobile) {\n+      setMobileActiveComment(foundComment);\n+    }\n+\n+    if (!foundComment || isMobile) return;\n+\n+    commentGroups.forEach((group, groupKey) => {\n+      if (group.cellId !== cursorCellId) return;\n+\n+      const commentIndex = group.comments.findIndex(c => c.id === foundComment!.id);\n+      if (commentIndex !== -1) {\n+        const groupHasExpanded = group.comments.some(c => c.id === expandedCommentId);\n+        if (groupHasExpanded) return;\n+\n+        setGroupPages(prev => {\n+          const next = new Map(prev);\n+          if (next.get(groupKey) !== commentIndex) {\n+            next.set(groupKey, commentIndex);\n+          }\n+          return next;\n+        });\n+      }\n+    });\n+  }, [cursorPosition, cursorCellId, state, commentGroups, isMobile, expandedCommentId]);\n+\n+  const handleCursorChange = useCallback((cellId: string, e: SyntheticEvent<HTMLTextAreaElement>) => {\n+    setCursorPosition(e.currentTarget.selectionStart);\n+    setCursorCellId(cellId);\n+  }, []);\n+\n+  const handleCommentStar = useCallback((commentId: string) => {\n+    if (!engineRef.current) return;\n+    const comment = engineRef.current.getComment(commentId);\n+    if (!comment) return;\n+\n+    const newFeedback = comment.feedback === 'star' ? undefined : 'star';\n+    engineRef.current.setCommentFeedback(commentId, newFeedback as any);\n+  }, [engineRef]);\n+\n+  const handleCommentKill = useCallback((commentId: string) => {\n+    if (!engineRef.current) return;\n+    engineRef.current.setCommentFeedback(commentId, 'kill');\n+    setExpandedCommentId(null);\n+  }, [engineRef]);\n+\n+  const handleCommentChatSend = useCallback(async (commentId: string, message: string) => {\n+    if (!engineRef.current || !state) return;\n+\n+    const comment = engineRef.current.getComment(commentId);\n+    if (!comment) return;\n+\n+    engineRef.current.addCommentChatMessage(commentId, 'user', message);\n+    setCommentChatProcessing(prev => new Set(prev).add(commentId));\n+\n+    try {\n+      const allText = state.cells\n+        .filter(c => c.type === 'text')\n+        .map(c => (c as TextCell).content)\n+        .join('');\n+\n+      const chatHistory = comment.chatHistory?.slice(0, -1) || [];\n+\n+      const metaPrompt = getMetaPrompt();\n+      const statePrompt = selectedState && stateConfig.states[selectedState]\n+        ? stateConfig.states[selectedState].prompt\n+        : '';\n+\n+      const voiceId = comment.voiceId || comment.voice;\n+\n+      const response = await chatWithVoice(\n+        voiceId,\n+        chatHistory,\n+        message,\n+        allText,\n+        metaPrompt,\n+        statePrompt\n+      );\n+\n+      engineRef.current.addCommentChatMessage(commentId, 'assistant', response);\n+    } catch (error) {\n+      console.error('Comment chat failed:', error);\n+      engineRef.current.addCommentChatMessage(commentId, 'assistant', 'Sorry, I encountered an error.');\n+    } finally {\n+      setCommentChatProcessing(prev => {\n+        const next = new Set(prev);\n+        next.delete(commentId);\n+        return next;\n+      });\n+    }\n+  }, [state, selectedState, stateConfig, engineRef]);\n+\n+  return {\n+    commentGroups,\n+    groupPages,\n+    handleGroupNavigate,\n+    expandedCommentId,\n+    setExpandedCommentId,\n+    mobileActiveComment,\n+    cursorPosition,\n+    cursorCellId,\n+    handleCursorChange,\n+    handleCommentStar,\n+    handleCommentKill,\n+    handleCommentChatSend,\n+    commentChatProcessing,\n+  };\n+}"
    },
    {
      "sha": "b099c360bcaf441462eb96aa16aafbd0b96d7073",
      "filename": "frontend/src/hooks/useInspiration.ts",
      "status": "added",
      "additions": 131,
      "deletions": 0,
      "changes": 131,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/a5cc6080a1837a8688356eb468647ea2f0cd4d78/frontend%2Fsrc%2Fhooks%2FuseInspiration.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/a5cc6080a1837a8688356eb468647ea2f0cd4d78/frontend%2Fsrc%2Fhooks%2FuseInspiration.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fhooks%2FuseInspiration.ts?ref=a5cc6080a1837a8688356eb468647ea2f0cd4d78",
      "patch": "@@ -0,0 +1,131 @@\n+import { useState, useRef, useCallback, useEffect } from 'react';\n+import type { VoiceInspiration } from '../api/voiceApi';\n+import { getSuggestion } from '../api/voiceApi';\n+import { getMetaPrompt, getStateConfig } from '../utils/voiceStorage';\n+\n+interface UseInspirationOptions {\n+  debounceMs?: number;\n+  minTextLength?: number;\n+  animationDurationMs?: number;\n+}\n+\n+interface UseInspirationReturn {\n+  currentInspiration: VoiceInspiration | null;\n+  isDisappearing: boolean;\n+  isAppearing: boolean;\n+  onTextChange: (allText: string, selectedState: string | null) => void;\n+  clearInspiration: () => void;\n+  setTextGetter: (getter: () => string) => void;\n+}\n+\n+const DEFAULT_OPTIONS: Required<UseInspirationOptions> = {\n+  debounceMs: 2000,\n+  minTextLength: 10,\n+  animationDurationMs: 800,\n+};\n+\n+// @@@ Inspiration suggestion hook - handles debounce, appearance/disappearance animations, and result validation\n+export function useInspiration(options: UseInspirationOptions = {}): UseInspirationReturn {\n+  const config = { ...DEFAULT_OPTIONS, ...options };\n+\n+  const [currentInspiration, setCurrentInspiration] = useState<VoiceInspiration | null>(null);\n+  const [isDisappearing, setIsDisappearing] = useState(false);\n+  const [, forceRender] = useState(0);\n+\n+  const prevInspirationRef = useRef<VoiceInspiration | null>(null);\n+  const timerRef = useRef<number | null>(null);\n+  const snapshotRef = useRef<string>('');\n+  const textGetterRef = useRef<(() => string) | null>(null);\n+\n+  const isAppearing = !isDisappearing &&\n+    currentInspiration !== null &&\n+    currentInspiration !== prevInspirationRef.current;\n+\n+  useEffect(() => {\n+    if (isDisappearing) {\n+      const timer = window.setTimeout(() => {\n+        setCurrentInspiration(null);\n+        setIsDisappearing(false);\n+      }, config.animationDurationMs);\n+      return () => window.clearTimeout(timer);\n+    }\n+  }, [isDisappearing, config.animationDurationMs]);\n+\n+  useEffect(() => {\n+    if (currentInspiration) {\n+      setIsDisappearing(false);\n+      // Ensure a re-render after the ref update so the appearing animation can settle\n+      requestAnimationFrame(() => {\n+        prevInspirationRef.current = currentInspiration;\n+        forceRender(x => x + 1);\n+      });\n+    }\n+  }, [currentInspiration]);\n+\n+  useEffect(() => {\n+    return () => {\n+      if (timerRef.current) {\n+        window.clearTimeout(timerRef.current);\n+      }\n+    };\n+  }, []);\n+\n+  const setTextGetter = useCallback((getter: () => string) => {\n+    textGetterRef.current = getter;\n+  }, []);\n+\n+  const clearInspiration = useCallback(() => {\n+    if (timerRef.current) {\n+      window.clearTimeout(timerRef.current);\n+      timerRef.current = null;\n+    }\n+    setCurrentInspiration(null);\n+    setIsDisappearing(false);\n+    prevInspirationRef.current = null;\n+  }, []);\n+\n+  const onTextChange = useCallback((allText: string, selectedState: string | null) => {\n+    if (currentInspiration) {\n+      setIsDisappearing(true);\n+    }\n+\n+    if (timerRef.current) {\n+      window.clearTimeout(timerRef.current);\n+      timerRef.current = null;\n+    }\n+\n+    if (allText.trim().length < config.minTextLength) {\n+      return;\n+    }\n+\n+    timerRef.current = window.setTimeout(async () => {\n+      snapshotRef.current = allText;\n+\n+      try {\n+        const metaPrompt = getMetaPrompt();\n+        const stateConfig = getStateConfig();\n+        const statePrompt = selectedState && stateConfig.states[selectedState]\n+          ? stateConfig.states[selectedState].prompt\n+          : '';\n+\n+        const suggestion = await getSuggestion(allText, metaPrompt, statePrompt);\n+        const currentText = textGetterRef.current?.() ?? '';\n+\n+        if (suggestion && currentText === snapshotRef.current) {\n+          setCurrentInspiration(suggestion);\n+        }\n+      } catch (error) {\n+        console.error('Failed to get inspiration:', error);\n+      }\n+    }, config.debounceMs);\n+  }, [currentInspiration, config.minTextLength, config.debounceMs]);\n+\n+  return {\n+    currentInspiration,\n+    isDisappearing,\n+    isAppearing,\n+    onTextChange,\n+    clearInspiration,\n+    setTextGetter,\n+  };\n+}"
    }
  ]
}