commit 2138b508bd6aa039659a6211ff0ae411ab82f86a
Author: lexicalmathical <lexicalmathical@gmail.com>
Date:   Thu Oct 30 11:04:51 2025 +0800

    Add overlap feedback loop to prevent repetitive comment suggestions
    
    Frontend:
    - Track overlappedPhrases in EditorState (persistent across requests)
    - Add rejected phrases to state when overlap detected
    - Pass overlappedPhrases array to backend API calls
    - Add migration for old state (ensure field exists on load)
    
    Backend:
    - Accept overlapped_phrases parameter in analyze_text()
    - Pass through to stateless_analyzer
    - Add "REJECTED PHRASES" section to LLM prompt
    - Explicit warnings to avoid re-suggesting overlapping phrases
    
    This prevents the system from getting stuck in loops where it
    repeatedly suggests variations of the same phrase that were
    already rejected due to overlap (e.g., "worst model", "by far
    the worst model", etc.)
    
    ü§ñ Generated with [Claude Code](https://claude.com/claude-code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

diff --git a/backend/server.py b/backend/server.py
index 0ea204e..c14b2ec 100644
--- a/backend/server.py
+++ b/backend/server.py
@@ -125,7 +125,7 @@ User's current state:
     },
     category="Analysis"
 )
-def analyze_text(text: str, session_id: str, voices: dict = None, applied_comments: list = None, meta_prompt: str = "", state_prompt: str = ""):
+def analyze_text(text: str, session_id: str, voices: dict = None, applied_comments: list = None, meta_prompt: str = "", state_prompt: str = "", overlapped_phrases: list = None):
     """
     Stateless analysis - returns ONE new comment based on text and applied comments.
 
@@ -136,6 +136,7 @@ def analyze_text(text: str, session_id: str, voices: dict = None, applied_commen
         applied_comments: List of already applied comments (to avoid duplicates)
         meta_prompt: Additional instructions that apply to all voices
         state_prompt: User's current emotional state prompt
+        overlapped_phrases: Phrases that were rejected due to overlap (feedback loop)
 
     Returns:
         Dictionary with single new voice (or empty list)
@@ -144,6 +145,7 @@ def analyze_text(text: str, session_id: str, voices: dict = None, applied_commen
     print(f"üéØ Stateless analyze_text() called")
     print(f"   Text: {text[:100]}...")
     print(f"   Applied comments: {len(applied_comments or [])}")
+    print(f"   Overlapped phrases: {len(overlapped_phrases or [])}")
     print(f"   Meta prompt: {repr(meta_prompt)[:100]}")
     print(f"   State prompt: {repr(state_prompt)[:100]}")
     print(f"{'='*60}\n")
@@ -151,7 +153,7 @@ def analyze_text(text: str, session_id: str, voices: dict = None, applied_commen
     agent = PolyAgent(id="voice-analyzer")
 
     # Get voices from stateless analyzer
-    result = analyze_stateless(agent, text, applied_comments or [], voices, meta_prompt, state_prompt)
+    result = analyze_stateless(agent, text, applied_comments or [], voices, meta_prompt, state_prompt, overlapped_phrases or [])
 
     print(f"‚úÖ Returning {result['new_voices_added']} new voice(s)")
 
diff --git a/backend/stateless_analyzer.py b/backend/stateless_analyzer.py
index 67ab3aa..efdce36 100644
--- a/backend/stateless_analyzer.py
+++ b/backend/stateless_analyzer.py
@@ -16,7 +16,7 @@ class VoiceTrigger(BaseModel):
 class SingleVoiceAnalysis(BaseModel):
     voice: Optional[VoiceTrigger] = Field(description="Single voice trigger, or None if nothing to comment")
 
-def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict], voices: dict = None, meta_prompt: str = "", state_prompt: str = "") -> dict:
+def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict], voices: dict = None, meta_prompt: str = "", state_prompt: str = "", overlapped_phrases: List[str] = None) -> dict:
     """
     Stateless analysis - receives applied comments, returns ONE new comment.
 
@@ -27,10 +27,12 @@ def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict],
         voices: Voice configuration
         meta_prompt: Additional instructions that apply to all voices
         state_prompt: User's current emotional state prompt
+        overlapped_phrases: Phrases that were rejected due to overlap (feedback loop)
 
     Returns:
         Dict with single new voice (or empty list if none)
     """
+    overlapped_phrases = overlapped_phrases or []
     print(f"\n{'='*60}")
     print(f"üìä Stateless Analysis")
     print(f"   Text: {text[:100]}...")
@@ -58,6 +60,14 @@ def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict],
         existing_summary += f"\nüëâ These phrases are already highlighted: {highlighted_phrases}\n"
         existing_summary += "üëâ Choose a DIFFERENT phrase that does NOT overlap with any of these!\n"
 
+    # @@@ Add overlapped phrases feedback (phrases that were rejected due to overlap)
+    if overlapped_phrases:
+        existing_summary += f"\n\nREJECTED PHRASES (these overlapped with existing highlights):\n"
+        for phrase in overlapped_phrases:
+            existing_summary += f"- \"{phrase}\" (REJECTED - do NOT suggest this again)\n"
+        existing_summary += f"\n‚ö†Ô∏è AVOID these phrases: {overlapped_phrases}\n"
+        existing_summary += "‚ö†Ô∏è The system already tried these and rejected them - choose something completely different!\n"
+
     prompt = f"""You are analyzing internal dialogue as distinct inner voice personas.
 
 Analyze this text and identify ONE NEW voice that wants to comment:
diff --git a/frontend/src/api/voiceApi.ts b/frontend/src/api/voiceApi.ts
index 51d34f8..14b00aa 100644
--- a/frontend/src/api/voiceApi.ts
+++ b/frontend/src/api/voiceApi.ts
@@ -45,14 +45,14 @@ interface StatusResponse {
 /**
  * Trigger voice analysis session
  */
-export async function triggerAnalysis(text: string, sessionId: string, voices?: any, appliedComments?: any[], metaPrompt?: string, statePrompt?: string): Promise<string> {
+export async function triggerAnalysis(text: string, sessionId: string, voices?: any, appliedComments?: any[], metaPrompt?: string, statePrompt?: string, overlappedPhrases?: string[]): Promise<string> {
   console.log('üì§ Sending trigger request...');
   const response = await fetch(`${API_BASE}/api/trigger`, {
     method: 'POST',
     headers: { 'Content-Type': 'application/json' },
     body: JSON.stringify({
       session_id: 'analyze_text',
-      params: { text, session_id: sessionId, voices, applied_comments: appliedComments || [], meta_prompt: metaPrompt || '', state_prompt: statePrompt || '' }
+      params: { text, session_id: sessionId, voices, applied_comments: appliedComments || [], meta_prompt: metaPrompt || '', state_prompt: statePrompt || '', overlapped_phrases: overlappedPhrases || [] }
     })
   });
 
@@ -104,8 +104,8 @@ export async function getAnalysisResult(exec_id: string): Promise<StatusResponse
 /**
  * Analyze text and return voices with metadata (all-in-one)
  */
-export async function analyzeText(text: string, sessionId: string, voices?: any, appliedComments?: any[], metaPrompt?: string, statePrompt?: string) {
-  const exec_id = await triggerAnalysis(text, sessionId, voices, appliedComments, metaPrompt, statePrompt);
+export async function analyzeText(text: string, sessionId: string, voices?: any, appliedComments?: any[], metaPrompt?: string, statePrompt?: string, overlappedPhrases?: string[]) {
+  const exec_id = await triggerAnalysis(text, sessionId, voices, appliedComments, metaPrompt, statePrompt, overlappedPhrases);
   const result = await getAnalysisResult(exec_id);
   // @@@ Return both voices and new_voices_added for energy refund mechanism
   return {
diff --git a/frontend/src/engine/EditorEngine.ts b/frontend/src/engine/EditorEngine.ts
index d2103d9..e033445 100644
--- a/frontend/src/engine/EditorEngine.ts
+++ b/frontend/src/engine/EditorEngine.ts
@@ -11,6 +11,7 @@ export interface EditorState {
   commentors: Commentor[];
   tasks: Task[];
   weightPath: WeightEntry[];
+  overlappedPhrases: string[];  // @@@ Phrases rejected due to overlap (feedback to backend)
   sessionId: string;
   currentEntryId?: string;  // Track which calendar entry is being edited (for overwrite on save)
 }
@@ -126,6 +127,7 @@ export class EditorEngine {
       commentors: [],
       tasks: [],
       weightPath: [],
+      overlappedPhrases: [],
       sessionId
     };
   }
@@ -301,6 +303,10 @@ export class EditorEngine {
       }
 
       if (hasOverlap) {
+        // @@@ Track overlapped phrase for backend feedback
+        if (!this.state.overlappedPhrases.includes(commentor.phrase)) {
+          this.state.overlappedPhrases.push(commentor.phrase);
+        }
         skippedAny = true;
         continue;
       }
@@ -376,7 +382,7 @@ export class EditorEngine {
         ? stateConfig.states[selectedState].prompt
         : '';
 
-      const result = await analyzeText(text, this.state.sessionId, backendVoices, appliedCommentors, metaPrompt, statePrompt);
+      const result = await analyzeText(text, this.state.sessionId, backendVoices, appliedCommentors, metaPrompt, statePrompt, this.state.overlappedPhrases);
 
       // Backend returns at most ONE voice
       if (result.voices.length > 0) {
@@ -656,6 +662,10 @@ export class EditorEngine {
   // @@@ Load state from storage
   loadState(state: EditorState) {
     this.state = state;
+    // @@@ Ensure overlappedPhrases field exists (migration for old state)
+    if (!this.state.overlappedPhrases) {
+      this.state.overlappedPhrases = [];
+    }
     // Recompute used energy from applied commentors
     this.usedEnergy = this.state.commentors.filter(c => c.appliedAt).length * this.threshold;
     this.notifyChange();
