{
  "sha": "30be7c68037af9b5ba3bfc9993bcfc4c83fe7169",
  "node_id": "C_kwDOP2Zrm9oAKDMwYmU3YzY4MDM3YWY5YjViYTNiZmM5OTkzYmNmYzRjODNmZTcxNjk",
  "commit": {
    "author": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-12-09T12:16:55Z"
    },
    "committer": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-12-09T12:16:55Z"
    },
    "message": "session life cycle hook extraction",
    "tree": {
      "sha": "f2e9059d58b25a6ca41ff0aeffa4d48188d2621d",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/trees/f2e9059d58b25a6ca41ff0aeffa4d48188d2621d"
    },
    "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/commits/30be7c68037af9b5ba3bfc9993bcfc4c83fe7169",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/30be7c68037af9b5ba3bfc9993bcfc4c83fe7169",
  "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/30be7c68037af9b5ba3bfc9993bcfc4c83fe7169",
  "comments_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/30be7c68037af9b5ba3bfc9993bcfc4c83fe7169/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "4840c646362454db7fbdbce64000ff8b55459e2e",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/4840c646362454db7fbdbce64000ff8b55459e2e",
      "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/4840c646362454db7fbdbce64000ff8b55459e2e"
    }
  ],
  "stats": {
    "total": 1022,
    "additions": 549,
    "deletions": 473
  },
  "files": [
    {
      "sha": "8e8fb172359db064d70d6e566afb7156e6134204",
      "filename": "frontend/src/App.tsx",
      "status": "modified",
      "additions": 42,
      "deletions": 473,
      "changes": 515,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/30be7c68037af9b5ba3bfc9993bcfc4c83fe7169/frontend%2Fsrc%2FApp.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/30be7c68037af9b5ba3bfc9993bcfc4c83fe7169/frontend%2Fsrc%2FApp.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2FApp.tsx?ref=30be7c68037af9b5ba3bfc9993bcfc4c83fe7169",
      "patch": "@@ -1,7 +1,6 @@\n import React, { useState, useEffect, useLayoutEffect, useRef, useCallback, useMemo } from 'react';\n import { useTranslation } from 'react-i18next';\n-import { EditorEngine } from './engine/EditorEngine';\n-import type { EditorState, Commentor, TextCell } from './engine/EditorEngine';\n+import type { Commentor, EditorState, TextCell } from './engine/EditorEngine';\n import { ChatWidget } from './engine/ChatWidget';\n import type { ChatWidgetData } from './engine/ChatWidget';\n import './App.css';\n@@ -23,7 +22,7 @@ import AgentDropdown from './components/AgentDropdown';\n import ChatWidgetUI from './components/ChatWidgetUI';\n import StateChooser from './components/StateChooser';\n import type { VoiceConfig } from './api/voiceApi';\n-import { getVoices, getMetaPrompt, getStateConfig, saveMetaPrompt } from './utils/voiceStorage';\n+import { getVoices, getMetaPrompt, getStateConfig } from './utils/voiceStorage';\n import { getDefaultVoices, chatWithVoice, importLocalData, getSuggestion, loadVoicesFromDecks, type VoiceInspiration } from './api/voiceApi';\n import { useMobile } from './utils/mobileDetect';\n import { CommentGroupCard } from './components/CommentCard';\n@@ -33,13 +32,7 @@ import LoginForm from './components/Auth/LoginForm';\n import RegisterForm from './components/Auth/RegisterForm';\n import { STORAGE_KEYS } from './constants/storageKeys';\n import { getLocalDayKey, getTodayKeyInTimezone } from './utils/timezone';\n-\n-function createSessionId() {\n-  if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {\n-    return crypto.randomUUID();\n-  }\n-  return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n-}\n+import { useSessionLifecycle } from './hooks/useSessionLifecycle';\n \n // @@@ Left Toolbar Component - floating toolbelt within left margin\n function LeftToolbar({\n@@ -291,10 +284,38 @@ export default function App() {\n   const [timelineFriendToSelect, setTimelineFriendToSelect] = useState<number | null>(null);\n   const [voiceConfigs, setVoiceConfigs] = useState<Record<string, VoiceConfig>>({});\n \n-  const engineRef = useRef<EditorEngine | null>(null);\n-  const [state, setState] = useState<EditorState | null>(null);\n+  const browserTimezone = useMemo(() => {\n+    try {\n+      return Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';\n+    } catch {\n+      return 'UTC';\n+    }\n+  }, []);\n+  const [stateConfig, setStateConfig] = useState(() => getStateConfig());\n+\n+  const {\n+    engineRef,\n+    state,\n+    setState,\n+    localTexts,\n+    setLocalTexts,\n+    selectedState,\n+    setSelectedState,\n+    userTimezone,\n+    ensureStateForPersistence,\n+    getFirstLineFromState,\n+    saveSessionToDatabase,\n+    startDetachedBlankSession,\n+    handleNewSession,\n+    confirmStartFresh\n+  } = useSessionLifecycle({\n+    isAuthenticated,\n+    browserTimezone,\n+    setVoiceConfigs,\n+    setStateConfig\n+  });\n+\n   // @@@ Track local text per cell ID for IME composition\n-  const [localTexts, setLocalTexts] = useState<Map<string, string>>(new Map());\n   const [composingCells, setComposingCells] = useState<Set<string>>(new Set());\n   const [groupPages, setGroupPages] = useState<Map<string, number>>(new Map());\n   const [cursorPosition, setCursorPosition] = useState<number>(0);\n@@ -312,10 +333,6 @@ export default function App() {\n   // @@@ Warning dialog state\n   const [showWarning, setShowWarning] = useState(false);\n \n-  // @@@ State chooser (start with null, load from database or localStorage later)\n-  const [selectedState, setSelectedState] = useState<string | null>(null);\n-  const [stateConfig, setStateConfig] = useState(() => getStateConfig());\n-\n   // @@@ Per-cell textarea refs for positioning and style calculations\n   const textareaRefs = useRef<Map<string, HTMLTextAreaElement>>(new Map());\n   const scrollContainerRef = useRef<HTMLDivElement>(null);  // @@@ Track scroll container for position preservation\n@@ -346,79 +363,6 @@ export default function App() {\n   const prevInspirationRef = useRef<VoiceInspiration | null>(null);\n   const [_suggestionSnapshot, setSuggestionSnapshot] = useState<string>('');  // Not used yet\n   const suggestionTimerRef = useRef<number | null>(null);\n-  const browserTimezone = useMemo(() => {\n-    try {\n-      return Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';\n-    } catch {\n-      return 'UTC';\n-    }\n-  }, []);\n-  const timezoneSyncRef = useRef<string | null>(null);\n-  const [userTimezone, setUserTimezone] = useState(browserTimezone);\n-  const ensuredSessionForDayRef = useRef<string | null>(null);\n-  const userTimezoneRef = useRef(userTimezone);\n-\n-  useEffect(() => {\n-    userTimezoneRef.current = userTimezone;\n-  }, [userTimezone]);\n-\n-  const ensureStateForPersistence = useCallback((): EditorState | null => {\n-    if (engineRef.current) {\n-      const engineState = engineRef.current.getState();\n-      if (!engineState.createdAt) {\n-        engineState.createdAt = new Date().toISOString();\n-        setState({ ...engineState });\n-      }\n-      return engineState;\n-    }\n-\n-    if (state && !state.createdAt) {\n-      const nextState = { ...state, createdAt: new Date().toISOString() };\n-      setState(nextState);\n-      return nextState;\n-    }\n-\n-    if (state && !state.id) {\n-      throw new Error('Editor state is missing id');\n-    }\n-\n-    return state;\n-  }, [state]);\n-\n-  const getFirstLineFromState = useCallback((editorState: EditorState) => {\n-    const firstTextCell = editorState.cells.find(c => c.type === 'text') as TextCell | undefined;\n-    return firstTextCell?.content.split('\\n')[0].trim() || 'Untitled';\n-  }, []);\n-\n-  const saveSessionToDatabase = useCallback(async (editorState: EditorState, firstLine?: string) => {\n-    const line = firstLine ?? getFirstLineFromState(editorState);\n-    const { saveSession } = await import('./api/voiceApi');\n-    const idToSave = editorState.id || crypto.randomUUID();\n-    await saveSession(idToSave, editorState, line);\n-\n-    if (engineRef.current) {\n-      const liveId = engineRef.current.getState().id;\n-      const snapshotId = editorState.id;\n-      const isSafeToUpdate = liveId === idToSave || liveId === snapshotId;\n-\n-      if (isSafeToUpdate) {\n-        engineRef.current.setCurrentEntryId(idToSave);\n-      } else {\n-        console.warn(`\ud83d\udee1\ufe0f Race Condition Caught: Save finished for ${idToSave}, but editor is on ${liveId}. Skipping ID reset.`);\n-      }\n-    }\n-    return idToSave;\n-  }, [getFirstLineFromState]);\n-\n-  const persistSessionImmediately = useCallback(async (editorState: EditorState) => {\n-    if (!isAuthenticated) return;\n-    try {\n-      const firstLine = getFirstLineFromState(editorState);\n-      await saveSessionToDatabase(editorState, firstLine);\n-    } catch (error) {\n-      console.error('Failed to persist session immediately:', error);\n-    }\n-  }, [getFirstLineFromState, isAuthenticated, saveSessionToDatabase]);\n \n   // @@@ Detect if this is a new inspiration appearing (different from previous)\n   // Only check appearing when NOT disappearing (to avoid conflict)\n@@ -584,216 +528,6 @@ export default function App() {\n     checkMigration();\n   }, [isAuthenticated, isLoading]);\n \n-  useEffect(() => {\n-    const timezone = browserTimezone || 'UTC';\n-    if (!timezone) return;\n-\n-    if (!isAuthenticated) {\n-      setUserTimezone(timezone);\n-      timezoneSyncRef.current = timezone;\n-      return;\n-    }\n-\n-    if (timezoneSyncRef.current === timezone) return;\n-\n-    const syncTimezone = async () => {\n-      try {\n-        const { getPreferences, savePreferences } = await import('./api/voiceApi');\n-        const prefs = await getPreferences();\n-        if ((prefs?.timezone || 'UTC') !== timezone) {\n-          await savePreferences({ timezone });\n-          setUserTimezone(timezone);\n-        } else {\n-          setUserTimezone(prefs?.timezone || timezone);\n-        }\n-      } catch (error) {\n-        console.error('Failed to sync timezone preference:', error);\n-      } finally {\n-        timezoneSyncRef.current = timezone;\n-      }\n-    };\n-\n-    syncTimezone();\n-  }, [isAuthenticated, browserTimezone]);\n-\n-  // Initialize engine\n-  useEffect(() => {\n-    const sessionId = crypto.randomUUID ? crypto.randomUUID() : Date.now().toString();\n-    const engine = new EditorEngine(sessionId);\n-    engineRef.current = engine;\n-\n-    // @@@ Initialize createdAt for new session\n-    const initialState = engine.getState();\n-    if (!initialState.createdAt) {\n-      initialState.createdAt = new Date().toISOString();\n-      setState(initialState);\n-    }\n-\n-    engine.subscribe((newState) => {\n-      setState({ ...newState });\n-      // Only save to localStorage if not authenticated (guest mode)\n-      if (!isAuthenticated) {\n-        localStorage.setItem(STORAGE_KEYS.EDITOR_STATE, JSON.stringify(newState));\n-      }\n-    });\n-    const unsubscribeBlankReset = engine.onBlankReset(async () => {\n-      if (!isAuthenticated) return;\n-      const blankState = engine.getState();\n-      await persistSessionImmediately(blankState);\n-    });\n-\n-    // Load initial state\n-    const loadInitialState = async () => {\n-      if (isAuthenticated) {\n-        // @@@ Load from database if authenticated\n-        try {\n-          const { listSessions, getSession, getPreferences } = await import('./api/voiceApi');\n-\n-          // Get list of sessions\n-          const sessions = await listSessions();\n-\n-          // Load the most recent session or current session\n-          let sessionToLoad = null;\n-          let loadedSessionId: string | undefined = undefined;\n-          const currentSessionId = 'current-session';\n-          const currentSession = sessions.find(s => s.id === currentSessionId);\n-\n-          if (currentSession) {\n-            // Load current session\n-            const fullSession = await getSession(currentSessionId);\n-            sessionToLoad = fullSession.editor_state;\n-            loadedSessionId = currentSessionId;\n-          } else if (sessions.length > 0) {\n-            // Load most recent session ONLY if it's from today\n-            const mostRecent = sessions.sort((a, b) =>\n-              new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()\n-            )[0];\n-\n-            // @@@ Daily reset check - same logic as StateChooser\n-            const timezoneForDay = userTimezoneRef.current || 'UTC';\n-            const today = getTodayKeyInTimezone(timezoneForDay);\n-            const sessionDate = getLocalDayKey(mostRecent.updated_at, timezoneForDay);\n-\n-            if (sessionDate === today) {\n-              // Same day - load the session\n-              const fullSession = await getSession(mostRecent.id);\n-              sessionToLoad = fullSession.editor_state;\n-              loadedSessionId = mostRecent.id;\n-            } else {\n-              // New day - don't load old session, start fresh\n-              console.log(`\ud83d\udcc5 New day detected. Last session was from ${sessionDate}, today is ${today}. Starting fresh.`);\n-              sessionToLoad = null;\n-              loadedSessionId = undefined;\n-            }\n-          }\n-\n-          if (sessionToLoad && loadedSessionId) {\n-            const normalizedState: EditorState = {\n-              ...sessionToLoad,\n-              id: sessionToLoad.id || (sessionToLoad as any)?.currentEntryId || (sessionToLoad as any)?.sessionId || loadedSessionId\n-            };\n-            engine.loadState(normalizedState);\n-            setState(engine.getState());\n-\n-            // Initialize localTexts from loaded state\n-            const texts = new Map<string, string>();\n-            sessionToLoad.cells?.filter((c: any) => c.type === 'text').forEach((c: any) => {\n-              texts.set(c.id, c.content || '');\n-            });\n-            setLocalTexts(texts);\n-          } else {\n-            setState(engine.getState());\n-          }\n-\n-          // Load preferences\n-          try {\n-            const prefs = await getPreferences();\n-            if (prefs.voice_configs) {\n-              setVoiceConfigs(prefs.voice_configs);\n-            }\n-            if (prefs.meta_prompt) {\n-              saveMetaPrompt(prefs.meta_prompt);\n-            }\n-            if (prefs.state_config) {\n-              setStateConfig(prefs.state_config);\n-            }\n-            if (prefs.timezone) {\n-              setUserTimezone(prefs.timezone);\n-            }\n-\n-            // @@@ Load selectedState with daily reset check for authenticated users\n-            if (prefs.selected_state !== undefined && prefs.selected_state !== null) {\n-              const timezoneForDay = userTimezoneRef.current || 'UTC';\n-              const today = getTodayKeyInTimezone(timezoneForDay);\n-              const updatedAtDate = prefs.updated_at\n-                ? getLocalDayKey(prefs.updated_at, timezoneForDay)\n-                : null;\n-\n-              // Check if state was updated today\n-              if (updatedAtDate === today) {\n-                // Same day - load the state\n-                setSelectedState(prefs.selected_state);\n-              } else {\n-                // Different day or no timestamp - show cube for daily check-in\n-                setSelectedState(null);\n-              }\n-            }\n-          } catch (err) {\n-            console.log('No preferences found, using defaults');\n-          }\n-        } catch (error) {\n-          console.error('Failed to load from database:', error);\n-          setState(engine.getState());\n-        }\n-      } else {\n-        // Load from localStorage for guest mode\n-        const saved = localStorage.getItem(STORAGE_KEYS.EDITOR_STATE);\n-        if (saved) {\n-          try {\n-            const parsed = JSON.parse(saved);\n-            engine.loadState(parsed);\n-            setState(engine.getState());\n-\n-            // Initialize localTexts from loaded state\n-            const texts = new Map<string, string>();\n-            parsed.cells?.filter((c: any) => c.type === 'text').forEach((c: any) => {\n-              texts.set(c.id, c.content || '');\n-            });\n-            setLocalTexts(texts);\n-          } catch (e) {\n-            console.error('Failed to load saved state:', e);\n-          }\n-        } else {\n-          setState(engine.getState());\n-        }\n-\n-        // @@@ Load selectedState with daily reset check\n-        const savedState = localStorage.getItem(STORAGE_KEYS.SELECTED_STATE);\n-        const savedDate = localStorage.getItem('selected-state-date');\n-        const today = getTodayKeyInTimezone(userTimezoneRef.current || browserTimezone);\n-\n-        // Reset state if it's a new day\n-        if (savedState && savedDate === today) {\n-          setSelectedState(savedState);\n-        } else {\n-          // New day - clear the selection to show cube again\n-          localStorage.removeItem(STORAGE_KEYS.SELECTED_STATE);\n-          localStorage.removeItem('selected-state-date');\n-          setSelectedState(null);\n-        }\n-      }\n-      if (!isAuthenticated) {\n-        setUserTimezone(browserTimezone);\n-      }\n-    };\n-\n-    loadInitialState();\n-\n-    return () => {\n-      unsubscribeBlankReset();\n-    };\n-  }, [isAuthenticated, persistSessionImmediately]);\n-\n   // @@@ Sync localTexts from state when not composing\n   useEffect(() => {\n     if (state) {\n@@ -840,40 +574,6 @@ export default function App() {\n     return () => window.clearTimeout(timer);\n   }, [state, refsReady]);\n \n-  // @@@ Auto-save to database for authenticated users\n-  useEffect(() => {\n-    if (!isAuthenticated) return;\n-\n-    const autoSaveTimer = setTimeout(async () => {\n-      const stateSnapshot = ensureStateForPersistence();\n-      if (!stateSnapshot) return;\n-\n-      if (engineRef.current) {\n-        const liveId = engineRef.current.getState().id;\n-        const snapshotId = stateSnapshot.id;\n-        if (liveId && snapshotId && liveId !== snapshotId) {\n-          console.warn(`\u270b Auto-save aborted: timer captured ${snapshotId} but editor is now on ${liveId}`);\n-          return;\n-        }\n-      }\n-\n-      if (!stateSnapshot.id) {\n-        console.error('BUG: session id should always be defined after engine init');\n-        return;\n-      }\n-\n-      try {\n-        const firstLine = getFirstLineFromState(stateSnapshot);\n-        await saveSessionToDatabase(stateSnapshot, firstLine);\n-        console.log('Auto-saved to database');\n-      } catch (error) {\n-        console.error('Auto-save failed:', error);\n-      }\n-    }, 3000);\n-\n-    return () => clearTimeout(autoSaveTimer);\n-  }, [ensureStateForPersistence, getFirstLineFromState, isAuthenticated, saveSessionToDatabase, state]);\n-\n   // @@@ Group comments by 2-row blocks, accounting for widgets between cells\n   const commentGroups = useMemo(() => {\n     const groups = new Map<string, {\n@@ -1229,145 +929,14 @@ export default function App() {\n     setShowWarning(true);\n   }, []);\n \n-  interface BlankStateOptions {\n-    preserveSelectedState?: boolean;\n-    selectedStateOverride?: string | null;\n-  }\n-\n-  const buildBlankState = useCallback((options: BlankStateOptions = {}): EditorState => {\n-    const {\n-      preserveSelectedState = true,\n-      selectedStateOverride\n-    } = options;\n-    const resolvedSelectedState = selectedStateOverride !== undefined\n-      ? selectedStateOverride\n-      : (preserveSelectedState\n-        ? (engineRef.current?.getState().selectedState ?? selectedState ?? null)\n-        : null);\n-    const newSessionId = createSessionId();\n-    return {\n-      cells: [{ id: Math.random().toString(36).slice(2), type: 'text' as const, content: '' }],\n-      commentors: [],\n-      tasks: [],\n-      weightPath: [],\n-      overlappedPhrases: [],\n-      id: newSessionId,\n-      selectedState: resolvedSelectedState ?? undefined,\n-      createdAt: new Date().toISOString()\n-    };\n-  }, [selectedState]);\n-\n-  const startDetachedBlankSession = useCallback((persistImmediately: boolean = false) => {\n-    if (!engineRef.current) return;\n-    const blankState = buildBlankState();\n-\n-    engineRef.current.loadState(blankState);\n-    setState(blankState);\n-    setLocalTexts(new Map());\n-\n-    if (!isAuthenticated) {\n-      localStorage.setItem(STORAGE_KEYS.EDITOR_STATE, JSON.stringify(blankState));\n-    } else if (persistImmediately) {\n-      persistSessionImmediately(blankState);\n-    }\n-  }, [buildBlankState, isAuthenticated, persistSessionImmediately]);\n-\n-  useEffect(() => {\n-    if (!isAuthenticated) return;\n-    if (!engineRef.current) return;\n-    if (selectedState !== null) return;\n-    const todayKey = getTodayKeyInTimezone(userTimezone);\n-    if (!todayKey) return;\n-\n-    const currentState = engineRef.current.getState();\n-    const currentKey = currentState.createdAt\n-      ? getLocalDayKey(currentState.createdAt, userTimezone)\n-      : null;\n-\n-    if (currentKey === todayKey) return;\n-    if (ensuredSessionForDayRef.current === todayKey) return;\n-\n-    ensuredSessionForDayRef.current = todayKey;\n-    startDetachedBlankSession(true);\n-  }, [isAuthenticated, selectedState, startDetachedBlankSession, userTimezone]);\n-\n-  // @@@ New session: save current, then create fresh (no data loss, no warning)\n-  const handleNewSession = useCallback(async () => {\n-    if (!state || !engineRef.current) return;\n-\n-    // @@@ First, save current session if authenticated and has content\n-    console.log('\ud83d\udd04 Creating new session...');\n-    console.log('\ud83d\udcca isAuthenticated:', isAuthenticated);\n-\n-    if (isAuthenticated) {\n-      const hasContent = state.cells.some(c => c.type === 'text' && (c as TextCell).content.trim());\n-      console.log('\ud83d\udcdd Has content:', hasContent);\n-\n-      if (hasContent) {\n-        console.log('\ud83d\udcbe Saving current session before creating new one...');\n-        try {\n-          // @@@ Save with title only (no date prefix)\n-          const firstTextCell = state.cells.find(c => c.type === 'text') as TextCell | undefined;\n-          const firstLine = firstTextCell?.content.split('\\n')[0].trim() || 'Untitled';\n-\n-          const { saveSession } = await import('./api/voiceApi');\n-          const sessionId = state.id || crypto.randomUUID();\n-          console.log('\ud83d\udccb Saving session:', sessionId, 'with name:', firstLine);\n-          await saveSession(sessionId, state, firstLine);\n-          console.log('\u2705 Current session saved successfully');\n-        } catch (error) {\n-          console.error('\u274c Failed to save current session:', error);\n-        }\n-      } else {\n-        console.log('\u26a0\ufe0f No content to save, skipping');\n-      }\n-    } else {\n-      console.log('\u26a0\ufe0f Not authenticated, skipping save');\n-    }\n-\n-    const emptyState = buildBlankState({ preserveSelectedState: false });\n-\n-    // @@@ Load empty state directly into engine (immediate UI update)\n-    engineRef.current.loadState(emptyState);\n-    setState(emptyState);\n-    setLocalTexts(new Map());\n-\n-    // @@@ Don't save empty session - let auto-save handle it when user types\n-    // This ensures the session gets saved with content, not as empty\n-    if (!isAuthenticated) {\n-      // For guest users: clear localStorage\n-      localStorage.removeItem(STORAGE_KEYS.EDITOR_STATE);\n-      localStorage.removeItem(STORAGE_KEYS.SELECTED_STATE);\n-    }\n-    console.log('\ud83c\udd95 New session created (will be saved when you start typing)');\n-  }, [state, isAuthenticated, buildBlankState]);\n-\n-  const confirmStartFresh = useCallback(async () => {\n+  const handleConfirmStartFresh = useCallback(() => {\n     setShowWarning(false);\n+    confirmStartFresh();\n+  }, [confirmStartFresh]);\n \n-    if (!engineRef.current) return;\n-\n-    const emptyState = buildBlankState({ preserveSelectedState: false });\n-\n-    // @@@ Load empty state directly into engine (immediate UI update)\n-    engineRef.current.loadState(emptyState);\n-    setState(emptyState);\n-    setLocalTexts(new Map());\n-\n-    if (isAuthenticated) {\n-      // @@@ Save to database in background\n-      try {\n-        const { saveSession } = await import('./api/voiceApi');\n-        await saveSession(emptyState.id, emptyState);\n-      } catch (error) {\n-        console.error('Failed to save new session:', error);\n-      }\n-    } else {\n-      // For guest users: clear localStorage\n-      localStorage.removeItem(STORAGE_KEYS.EDITOR_STATE);\n-      localStorage.removeItem(STORAGE_KEYS.SELECTED_STATE);\n-    }\n-  }, [buildBlankState, isAuthenticated]);\n+  const handleNewSessionClick = useCallback(() => {\n+    handleNewSession(state);\n+  }, [handleNewSession, state]);\n \n   const handleSaveToday = useCallback(async () => {\n     if (!engineRef.current) return;\n@@ -2295,7 +1864,7 @@ export default function App() {\n           {/* New Session \"+\" button - top left (desktop only) */}\n           {!isMobile && (\n             <button\n-              onClick={handleNewSession}\n+                onClick={handleNewSessionClick}\n               title=\"New Session\"\n               style={{\n                 position: 'fixed',\n@@ -2971,7 +2540,7 @@ export default function App() {\n               justifyContent: 'space-between'\n             }}>\n               <button\n-                onClick={confirmStartFresh}\n+                onClick={handleConfirmStartFresh}\n                 style={{\n                   padding: '8px 20px',\n                   border: '1px solid #d44',"
    },
    {
      "sha": "7c8166ae9735ec96b8f3d7a4582a8eb659271cfa",
      "filename": "frontend/src/hooks/useSessionLifecycle.ts",
      "status": "added",
      "additions": 507,
      "deletions": 0,
      "changes": 507,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/30be7c68037af9b5ba3bfc9993bcfc4c83fe7169/frontend%2Fsrc%2Fhooks%2FuseSessionLifecycle.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/30be7c68037af9b5ba3bfc9993bcfc4c83fe7169/frontend%2Fsrc%2Fhooks%2FuseSessionLifecycle.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fhooks%2FuseSessionLifecycle.ts?ref=30be7c68037af9b5ba3bfc9993bcfc4c83fe7169",
      "patch": "@@ -0,0 +1,507 @@\n+import { useCallback, useEffect, useRef, useState } from 'react';\n+import { EditorEngine } from '../engine/EditorEngine';\n+import type { EditorState, TextCell } from '../engine/EditorEngine';\n+import { STORAGE_KEYS } from '../constants/storageKeys';\n+import { getLocalDayKey, getTodayKeyInTimezone } from '../utils/timezone';\n+import { saveMetaPrompt, getStateConfig as loadStateConfig } from '../utils/voiceStorage';\n+import type { VoiceConfig } from '../api/voiceApi';\n+\n+function createSessionId() {\n+  if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {\n+    return crypto.randomUUID();\n+  }\n+  return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n+}\n+\n+type SetVoiceConfigs = React.Dispatch<React.SetStateAction<Record<string, VoiceConfig>>>;\n+type SetStateConfig = React.Dispatch<React.SetStateAction<any>>;\n+\n+interface UseSessionLifecycleParams {\n+  isAuthenticated: boolean;\n+  browserTimezone: string;\n+  setVoiceConfigs: SetVoiceConfigs;\n+  setStateConfig: SetStateConfig;\n+}\n+\n+export function useSessionLifecycle({\n+  isAuthenticated,\n+  browserTimezone,\n+  setVoiceConfigs,\n+  setStateConfig\n+}: UseSessionLifecycleParams) {\n+  const engineRef = useRef<EditorEngine | null>(null);\n+  const [state, setState] = useState<EditorState | null>(null);\n+  const [localTexts, setLocalTexts] = useState<Map<string, string>>(new Map());\n+  const [selectedState, setSelectedState] = useState<string | null>(null);\n+  const [userTimezone, setUserTimezone] = useState(browserTimezone);\n+\n+  const ensuredSessionForDayRef = useRef<string | null>(null);\n+  const userTimezoneRef = useRef(userTimezone);\n+  const timezoneSyncRef = useRef<string | null>(null);\n+\n+  useEffect(() => {\n+    userTimezoneRef.current = userTimezone;\n+  }, [userTimezone]);\n+\n+  const ensureStateForPersistence = useCallback((): EditorState | null => {\n+    if (!state) {\n+      console.error('Editor state is missing, cannot persist');\n+      return null;\n+    }\n+\n+    if (state && !state.id) {\n+      throw new Error('Editor state is missing id');\n+    }\n+\n+    return state;\n+  }, [state]);\n+\n+  const getFirstLineFromState = useCallback((editorState: EditorState) => {\n+    const firstTextCell = editorState.cells.find(c => c.type === 'text') as TextCell | undefined;\n+    return firstTextCell?.content.split('\\n')[0].trim() || 'Untitled';\n+  }, []);\n+\n+  const saveSessionToDatabase = useCallback(async (editorState: EditorState, firstLine?: string) => {\n+    const line = firstLine ?? getFirstLineFromState(editorState);\n+    const { saveSession } = await import('../api/voiceApi');\n+    const idToSave = editorState.id || createSessionId();\n+    await saveSession(idToSave, editorState, line);\n+\n+    if (engineRef.current) {\n+      const liveId = engineRef.current.getState().id;\n+      const snapshotId = editorState.id;\n+      const isSafeToUpdate = liveId === idToSave || liveId === snapshotId;\n+\n+      if (isSafeToUpdate) {\n+        engineRef.current.setCurrentEntryId(idToSave);\n+      } else {\n+        console.warn(`\ud83d\udee1\ufe0f Race Condition Caught: Save finished for ${idToSave}, but editor is on ${liveId}. Skipping ID reset.`);\n+      }\n+    }\n+    return idToSave;\n+  }, [getFirstLineFromState]);\n+\n+  const persistSessionImmediately = useCallback(async (editorState: EditorState) => {\n+    if (!isAuthenticated) return;\n+    try {\n+      const firstLine = getFirstLineFromState(editorState);\n+      await saveSessionToDatabase(editorState, firstLine);\n+    } catch (error) {\n+      console.error('Failed to persist session immediately:', error);\n+    }\n+  }, [getFirstLineFromState, isAuthenticated, saveSessionToDatabase]);\n+\n+  const buildBlankState = useCallback((options: { preserveSelectedState?: boolean; selectedStateOverride?: string | null } = {}): EditorState => {\n+    const {\n+      preserveSelectedState = true,\n+      selectedStateOverride\n+    } = options;\n+    const resolvedSelectedState = selectedStateOverride !== undefined\n+      ? selectedStateOverride\n+      : (preserveSelectedState\n+        ? (engineRef.current?.getState().selectedState ?? selectedState ?? null)\n+        : null);\n+    const newSessionId = createSessionId();\n+    return {\n+      cells: [{ id: Math.random().toString(36).slice(2), type: 'text' as const, content: '' }],\n+      commentors: [],\n+      tasks: [],\n+      weightPath: [],\n+      overlappedPhrases: [],\n+      id: newSessionId,\n+      selectedState: resolvedSelectedState ?? undefined,\n+      createdAt: new Date().toISOString()\n+    };\n+  }, [selectedState]);\n+\n+  const startDetachedBlankSession = useCallback((persistImmediately: boolean = false) => {\n+    if (!engineRef.current) return;\n+    const blankState = buildBlankState();\n+\n+    engineRef.current.loadState(blankState);\n+    setState(blankState);\n+    setLocalTexts(new Map());\n+\n+    if (!isAuthenticated) {\n+      localStorage.setItem(STORAGE_KEYS.EDITOR_STATE, JSON.stringify(blankState));\n+    } else if (persistImmediately) {\n+      persistSessionImmediately(blankState);\n+    }\n+  }, [buildBlankState, isAuthenticated, persistSessionImmediately]);\n+\n+  const handleNewSession = useCallback(async (currentState?: EditorState | null) => {\n+    const workingState = currentState ?? state;\n+    if (!workingState || !engineRef.current) return;\n+\n+    if (isAuthenticated) {\n+      const hasContent = workingState.cells.some(c => c.type === 'text' && (c as TextCell).content.trim());\n+\n+      if (hasContent) {\n+        try {\n+          const firstTextCell = workingState.cells.find(c => c.type === 'text') as TextCell | undefined;\n+          const firstLine = firstTextCell?.content.split('\\n')[0].trim() || 'Untitled';\n+\n+          const { saveSession } = await import('../api/voiceApi');\n+          const sessionId = workingState.id || createSessionId();\n+          await saveSession(sessionId, workingState, firstLine);\n+        } catch (error) {\n+          console.error('\u274c Failed to save current session:', error);\n+        }\n+      }\n+    }\n+\n+    const emptyState = buildBlankState({ preserveSelectedState: false });\n+    engineRef.current.loadState(emptyState);\n+    setState(emptyState);\n+    setLocalTexts(new Map());\n+\n+    if (!isAuthenticated) {\n+      localStorage.removeItem(STORAGE_KEYS.EDITOR_STATE);\n+      localStorage.removeItem(STORAGE_KEYS.SELECTED_STATE);\n+    }\n+  }, [buildBlankState, isAuthenticated, state]);\n+\n+  const confirmStartFresh = useCallback(async () => {\n+    if (!engineRef.current) return;\n+\n+    const emptyState = buildBlankState({ preserveSelectedState: false });\n+    engineRef.current.loadState(emptyState);\n+    setState(emptyState);\n+    setLocalTexts(new Map());\n+\n+    if (isAuthenticated) {\n+      try {\n+        const { saveSession } = await import('../api/voiceApi');\n+        await saveSession(emptyState.id, emptyState);\n+      } catch (error) {\n+        console.error('Failed to save new session:', error);\n+      }\n+    } else {\n+      localStorage.removeItem(STORAGE_KEYS.EDITOR_STATE);\n+      localStorage.removeItem(STORAGE_KEYS.SELECTED_STATE);\n+    }\n+  }, [buildBlankState, isAuthenticated]);\n+\n+  const handleSaveToday = useCallback(async () => {\n+    if (!engineRef.current) return;\n+    if (!isAuthenticated) {\n+      const toast = document.createElement('div');\n+      toast.textContent = 'Please sign in to save';\n+      toast.style.cssText = `\n+        position: fixed;\n+        top: 70px;\n+        right: 20px;\n+        background: #f44336;\n+        color: white;\n+        padding: 12px 20px;\n+        borderRadius: 6px;\n+        fontSize: 14px;\n+        fontFamily: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto;\n+        zIndex: 10000;\n+        boxShadow: 0 4px 12px rgba(0,0,0,0.15);\n+      `;\n+      document.body.appendChild(toast);\n+      setTimeout(() => {\n+        toast.style.opacity = '0';\n+        toast.style.transition = 'opacity 0.3s';\n+        setTimeout(() => document.body.removeChild(toast), 300);\n+      }, 2000);\n+      return;\n+    }\n+    const currentState = ensureStateForPersistence();\n+    if (!currentState) return;\n+\n+    try {\n+      const firstLine = getFirstLineFromState(currentState);\n+      const savedSessionId = await saveSessionToDatabase(currentState, firstLine);\n+      engineRef.current.setCurrentEntryId(savedSessionId);\n+      const toast = document.createElement('div');\n+      toast.textContent = 'Saved';\n+      toast.style.cssText = `\n+        position: fixed;\n+        top: 70px;\n+        right: 20px;\n+        background: #4CAF50;\n+        color: white;\n+        padding: 12px 20px;\n+        borderRadius: 6px;\n+        fontSize: 14px;\n+        fontFamily: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto;\n+        zIndex: 10000;\n+        boxShadow: 0 4px 12px rgba(0,0,0,0.15);\n+      `;\n+      document.body.appendChild(toast);\n+      setTimeout(() => {\n+        toast.style.opacity = '0';\n+        toast.style.transition = 'opacity 0.3s';\n+        setTimeout(() => document.body.removeChild(toast), 300);\n+      }, 1200);\n+    } catch (error) {\n+      console.error('Failed to save session:', error);\n+    }\n+  }, [ensureStateForPersistence, getFirstLineFromState, isAuthenticated, saveSessionToDatabase]);\n+\n+  useEffect(() => {\n+    if (!isAuthenticated) {\n+      setUserTimezone(browserTimezone);\n+      return;\n+    }\n+\n+    if (timezoneSyncRef.current === browserTimezone) {\n+      return;\n+    }\n+\n+    const syncTimezone = async () => {\n+      try {\n+        const timezone = browserTimezone || 'UTC';\n+        const { getPreferences, savePreferences } = await import('../api/voiceApi');\n+        const prefs = await getPreferences();\n+        if ((prefs?.timezone || 'UTC') !== timezone) {\n+          await savePreferences({ timezone });\n+          setUserTimezone(timezone);\n+        } else {\n+          setUserTimezone(prefs?.timezone || timezone);\n+        }\n+      } catch (error) {\n+        console.error('Failed to sync timezone preference:', error);\n+      } finally {\n+        timezoneSyncRef.current = browserTimezone;\n+      }\n+    };\n+\n+    syncTimezone();\n+  }, [browserTimezone, isAuthenticated]);\n+\n+  useEffect(() => {\n+    const sessionId = createSessionId();\n+    const engine = new EditorEngine(sessionId);\n+    engineRef.current = engine;\n+\n+    const initialState = engine.getState();\n+    if (!initialState.createdAt) {\n+      initialState.createdAt = new Date().toISOString();\n+      setState(initialState);\n+    }\n+\n+    engine.subscribe((newState) => {\n+      setState({ ...newState });\n+      if (!isAuthenticated) {\n+        localStorage.setItem(STORAGE_KEYS.EDITOR_STATE, JSON.stringify(newState));\n+      }\n+    });\n+    const unsubscribeBlankReset = engine.onBlankReset(async () => {\n+      if (!isAuthenticated) return;\n+      const blankState = engine.getState();\n+      await persistSessionImmediately(blankState);\n+    });\n+\n+    return () => {\n+      unsubscribeBlankReset();\n+    };\n+  }, [isAuthenticated, persistSessionImmediately]);\n+\n+  useEffect(() => {\n+    const loadInitialState = async () => {\n+      if (isAuthenticated) {\n+        try {\n+          const { listSessions, getSession, getPreferences } = await import('../api/voiceApi');\n+\n+          const sessions = await listSessions(userTimezoneRef.current);\n+\n+          let sessionToLoad = null;\n+          let loadedSessionId: string | undefined = undefined;\n+          const currentSessionId = 'current-session';\n+          const currentSession = sessions.find(s => s.id === currentSessionId);\n+\n+          if (currentSession) {\n+            const fullSession = await getSession(currentSessionId);\n+            sessionToLoad = fullSession.editor_state;\n+            loadedSessionId = currentSessionId;\n+          } else if (sessions.length > 0) {\n+            const mostRecent = sessions.sort((a, b) =>\n+              new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()\n+            )[0];\n+\n+            const timezoneForDay = userTimezoneRef.current || 'UTC';\n+            const today = getTodayKeyInTimezone(timezoneForDay);\n+            const sessionDate = getLocalDayKey(mostRecent.updated_at, timezoneForDay);\n+\n+            if (sessionDate === today) {\n+              const fullSession = await getSession(mostRecent.id);\n+              sessionToLoad = fullSession.editor_state;\n+              loadedSessionId = mostRecent.id;\n+            } else {\n+              console.log(`\ud83d\udcc5 New day detected. Last session was from ${sessionDate}, today is ${today}. Starting fresh.`);\n+              sessionToLoad = null;\n+              loadedSessionId = undefined;\n+            }\n+          }\n+\n+          if (sessionToLoad && loadedSessionId) {\n+            const normalizedState: EditorState = {\n+              ...sessionToLoad,\n+              id: sessionToLoad.id || (sessionToLoad as any)?.currentEntryId || (sessionToLoad as any)?.sessionId || loadedSessionId\n+            };\n+            engineRef.current?.loadState(normalizedState);\n+            setState(engineRef.current?.getState() || normalizedState);\n+\n+            const texts = new Map<string, string>();\n+            sessionToLoad.cells?.filter((c: any) => c.type === 'text').forEach((c: any) => {\n+              texts.set(c.id, c.content || '');\n+            });\n+            setLocalTexts(texts);\n+          } else {\n+            setState(engineRef.current?.getState() || null);\n+          }\n+\n+          try {\n+            const prefs = await getPreferences();\n+            if (prefs.voice_configs) {\n+              setVoiceConfigs(prefs.voice_configs);\n+            }\n+            if (prefs.meta_prompt) {\n+              saveMetaPrompt(prefs.meta_prompt);\n+            }\n+            if (prefs.state_config) {\n+              setStateConfig(prefs.state_config);\n+            }\n+            if (prefs.timezone) {\n+              setUserTimezone(prefs.timezone);\n+            }\n+\n+            if (prefs.selected_state !== undefined && prefs.selected_state !== null) {\n+              const timezoneForDay = userTimezoneRef.current || 'UTC';\n+              const today = getTodayKeyInTimezone(timezoneForDay);\n+              const updatedAtDate = prefs.updated_at\n+                ? getLocalDayKey(prefs.updated_at, timezoneForDay)\n+                : null;\n+\n+              if (updatedAtDate === today) {\n+                setSelectedState(prefs.selected_state);\n+              } else {\n+                setSelectedState(null);\n+              }\n+            }\n+          } catch (err) {\n+            console.log('No preferences found, using defaults');\n+          }\n+        } catch (error) {\n+          console.error('Failed to load from database:', error);\n+          setState(engineRef.current?.getState() || null);\n+        }\n+      } else {\n+        const saved = localStorage.getItem(STORAGE_KEYS.EDITOR_STATE);\n+        if (saved) {\n+          try {\n+            const parsed = JSON.parse(saved);\n+            engineRef.current?.loadState(parsed);\n+            setState(engineRef.current?.getState() || parsed);\n+\n+            const texts = new Map<string, string>();\n+            parsed.cells?.filter((c: any) => c.type === 'text').forEach((c: any) => {\n+              texts.set(c.id, c.content || '');\n+            });\n+            setLocalTexts(texts);\n+          } catch (e) {\n+            console.error('Failed to load saved state:', e);\n+          }\n+        } else {\n+          setState(engineRef.current?.getState() || null);\n+        }\n+\n+        const savedState = localStorage.getItem(STORAGE_KEYS.SELECTED_STATE);\n+        const savedDate = localStorage.getItem('selected-state-date');\n+        const today = getTodayKeyInTimezone(userTimezoneRef.current || browserTimezone);\n+\n+        if (savedState && savedDate === today) {\n+          setSelectedState(savedState);\n+        } else {\n+          localStorage.removeItem(STORAGE_KEYS.SELECTED_STATE);\n+          localStorage.removeItem('selected-state-date');\n+          setSelectedState(null);\n+        }\n+      }\n+      if (!isAuthenticated) {\n+        setUserTimezone(browserTimezone);\n+      }\n+    };\n+\n+    loadInitialState();\n+  }, [browserTimezone, isAuthenticated, setStateConfig, setVoiceConfigs]);\n+\n+  useEffect(() => {\n+    if (!isAuthenticated) return;\n+    if (!engineRef.current) return;\n+    if (selectedState !== null) return;\n+    const todayKey = getTodayKeyInTimezone(userTimezone);\n+    if (!todayKey) return;\n+\n+    const currentState = engineRef.current.getState();\n+    const currentKey = currentState.createdAt\n+      ? getLocalDayKey(currentState.createdAt, userTimezone)\n+      : null;\n+\n+    if (currentKey === todayKey) return;\n+    if (ensuredSessionForDayRef.current === todayKey) return;\n+\n+    ensuredSessionForDayRef.current = todayKey;\n+    startDetachedBlankSession(true);\n+  }, [isAuthenticated, selectedState, startDetachedBlankSession, userTimezone]);\n+\n+  useEffect(() => {\n+    if (!isAuthenticated) return;\n+\n+    const autoSaveTimer = setTimeout(async () => {\n+      const stateSnapshot = ensureStateForPersistence();\n+      if (!stateSnapshot) return;\n+\n+      if (engineRef.current) {\n+        const liveId = engineRef.current.getState().id;\n+        const snapshotId = stateSnapshot.id;\n+        if (liveId && snapshotId && liveId !== snapshotId) {\n+          console.warn(`\u270b Auto-save aborted: timer captured ${snapshotId} but editor is now on ${liveId}`);\n+          return;\n+        }\n+      }\n+\n+      if (!stateSnapshot.id) {\n+        console.error('BUG: session id should always be defined after engine init');\n+        return;\n+      }\n+\n+      try {\n+        const firstLine = getFirstLineFromState(stateSnapshot);\n+        await saveSessionToDatabase(stateSnapshot, firstLine);\n+        console.log('Auto-saved to database');\n+      } catch (error) {\n+        console.error('Auto-save failed:', error);\n+      }\n+    }, 3000);\n+\n+    return () => clearTimeout(autoSaveTimer);\n+  }, [ensureStateForPersistence, getFirstLineFromState, isAuthenticated, saveSessionToDatabase, state]);\n+\n+  useEffect(() => {\n+    setStateConfig(loadStateConfig());\n+  }, [setStateConfig]);\n+\n+  return {\n+    engineRef,\n+    state,\n+    setState,\n+    localTexts,\n+    setLocalTexts,\n+    selectedState,\n+    setSelectedState,\n+    userTimezone,\n+    setUserTimezone,\n+    ensureStateForPersistence,\n+    getFirstLineFromState,\n+    saveSessionToDatabase,\n+    persistSessionImmediately,\n+    startDetachedBlankSession,\n+    handleNewSession,\n+    confirmStartFresh,\n+    handleSaveToday\n+  };\n+}"
    }
  ]
}