commit a1e1a0b7f8fa00b8fc5cfa1d2ed600a525c9dea1
Author: lexicalmathical <lexicalmathical@gmail.com>
Date:   Sun Nov 30 22:39:35 2025 +0800

    removed proxy

diff --git a/README.md b/README.md
index 8c64504..def0e8f 100644
--- a/README.md
+++ b/README.md
@@ -93,6 +93,7 @@ Runs at `http://localhost:5173`.
 ## Roadmap
 - **Per-user timeline scheduling** ‚Äì Scheduler currently runs once per day using a single timezone; we now store `timezone` in preferences and will move to per-user cadence.
 - **Friend timezone awareness** ‚Äì Friend timelines will eventually display which timezone their entries use once per-user scheduling lands.
+- **Visitor ‚Äúshadow accounts‚Äù** ‚Äì Reintroduce visitor mode by minting anonymous user records per browser session (UUID + JWT) so visitors hit the exact same backend paths with restricted quotas. No localStorage divergences.
 - **Open-source polish** ‚Äì Document control-plane endpoints, linting, and seed data for new deployments.
 
 ---
diff --git a/backend/server.py b/backend/server.py
index 3b2aed9..bb6dc1a 100644
--- a/backend/server.py
+++ b/backend/server.py
@@ -4,8 +4,8 @@
 import os
 import time
 
-os.environ.setdefault('TZ', 'UTC')
-if hasattr(time, 'tzset'):
+os.environ.setdefault("TZ", "UTC")
+if hasattr(time, "tzset"):
     time.tzset()
 
 import asyncio
@@ -18,7 +18,6 @@ from polycli import PolyAgent
 from stateless_analyzer import analyze_stateless
 from speech_recognition import init_speech_recognition
 import config
-from proxy_config import get_image_api_proxies
 from typing import Optional
 from pydantic import BaseModel
 
@@ -29,6 +28,7 @@ import auth
 SUPPORTED_LANGUAGES = {"en", "zh"}
 DEFAULT_LANGUAGE = "en"
 
+
 def normalize_language_code(language: Optional[str]) -> str:
     if not language:
         return DEFAULT_LANGUAGE
@@ -37,6 +37,7 @@ def normalize_language_code(language: Optional[str]) -> str:
         return "zh"
     return "en"
 
+
 def resolve_language(_user_id: int, requested_language: Optional[str] = None) -> str:
     """Return a supported language code, falling back to default."""
     if requested_language:
@@ -45,6 +46,7 @@ def resolve_language(_user_id: int, requested_language: Optional[str] = None) ->
             return code
     return DEFAULT_LANGUAGE
 
+
 def language_instruction(language_code: str, detail: str = "") -> str:
     if language_code == "zh":
         base = "ËØ∑‰ΩøÁî®ÁÆÄ‰Ωì‰∏≠ÊñáËæìÂá∫ÊâÄÊúâÂÜÖÂÆπ„ÄÇ"
@@ -54,8 +56,10 @@ def language_instruction(language_code: str, detail: str = "") -> str:
         return f"{base} {detail}".strip()
     return base
 
+
 # ========== Session Definitions (PolyCLI) ==========
 
+
 @session_def(
     name="Get Writing Suggestion",
     description="Get AI-powered writing inspiration from a voice persona",
@@ -63,16 +67,18 @@ def language_instruction(language_code: str, detail: str = "") -> str:
         "text": {"type": "str"},
         "user_id": {"type": "int"},
         "meta_prompt": {"type": "str"},
-        "state_prompt": {"type": "str"}
+        "state_prompt": {"type": "str"},
     },
-    category="Writing"
+    category="Writing",
 )
-def get_writing_suggestion(text: str, user_id: int, meta_prompt: str = "", state_prompt: str = ""):
+def get_writing_suggestion(
+    text: str, user_id: int, meta_prompt: str = "", state_prompt: str = ""
+):
     """Generate writing inspiration from a random voice persona."""
-    print(f"\n{'='*60}")
+    print(f"\n{'=' * 60}")
     print(f"‚úçÔ∏è  get_writing_suggestion() called")
     print(f"   Text length: {len(text)} chars")
-    print(f"{'='*60}\n")
+    print(f"{'=' * 60}\n")
 
     if not text or len(text.strip()) < 10:
         return {"success": False, "error": "Text too short"}
@@ -95,8 +101,8 @@ def get_writing_suggestion(text: str, user_id: int, meta_prompt: str = "", state
     agent = PolyAgent(id="writing-suggester")
 
     # Build system prompt - voice gives inspiration, not continuation
-    system_prompt = f"""You are {voice_info['name']}, an inner voice persona.
-Your role: {voice_info.get('systemPrompt', '')}
+    system_prompt = f"""You are {voice_info["name"]}, an inner voice persona.
+Your role: {voice_info.get("systemPrompt", "")}
 
 Read what the user just wrote and offer a VERY SHORT, gentle nudge about what to write next.
 
@@ -120,7 +126,7 @@ Examples of GOOD suggestions:
 - "I'm curious about the details..."
 - "How did that moment change things?"
 
-Speak in {voice_info['name']}'s characteristic style, but keep it brief and inspiring."""
+Speak in {voice_info["name"]}'s characteristic style, but keep it brief and inspiring."""
 
     if state_prompt:
         system_prompt += f"\n\nEmotional context: {state_prompt}"
@@ -136,7 +142,13 @@ Give them ONE very short, gentle nudge about what to write next (max 15 words)."
 
     # Generate inspiration
     print(f"üì§ Calling agent.run() with model='claude-haiku-4.5'...")
-    result = agent.run(user_prompt, system_prompt=system_prompt, model='claude-haiku-4.5', cli="no-tools", tracked=True)
+    result = agent.run(
+        user_prompt,
+        system_prompt=system_prompt,
+        model="claude-haiku-4.5",
+        cli="no-tools",
+        tracked=True,
+    )
 
     if not result.is_success or not result.content:
         print(f"‚ö†Ô∏è  Failed to generate inspiration")
@@ -150,12 +162,13 @@ Give them ONE very short, gentle nudge about what to write next (max 15 words)."
     return {
         "success": True,
         "inspiration": inspiration,
-        "voice": voice_info['name'],
+        "voice": voice_info["name"],
         "voice_key": voice_key,
-        "icon": voice_info['icon'],
-        "color": voice_info['color']
+        "icon": voice_info["icon"],
+        "color": voice_info["color"],
     }
 
+
 @session_def(
     name="Chat with Voice",
     description="Have a conversation with a specific inner voice persona",
@@ -166,13 +179,21 @@ Give them ONE very short, gentle nudge about what to write next (max 15 words)."
         "user_message": {"type": "str"},
         "original_text": {"type": "str"},
         "meta_prompt": {"type": "str"},
-        "state_prompt": {"type": "str"}
+        "state_prompt": {"type": "str"},
     },
-    category="Chat"
+    category="Chat",
 )
-def chat_with_voice(voice_id: str, user_id: int, conversation_history: list, user_message: str, original_text: str = "", meta_prompt: str = "", state_prompt: str = ""):
+def chat_with_voice(
+    voice_id: str,
+    user_id: int,
+    conversation_history: list,
+    user_message: str,
+    original_text: str = "",
+    meta_prompt: str = "",
+    state_prompt: str = "",
+):
     """Chat with a specific voice persona."""
-    print(f"\n{'='*60}")
+    print(f"\n{'=' * 60}")
     print(f"üí¨ chat_with_voice() called")
     print(f"   Voice ID: {voice_id}")
     print(f"   User ID: {user_id}")
@@ -180,7 +201,7 @@ def chat_with_voice(voice_id: str, user_id: int, conversation_history: list, use
     print(f"   History length: {len(conversation_history)}")
     print(f"   Meta prompt: {repr(meta_prompt)[:100]}")
     print(f"   State prompt: {repr(state_prompt)[:100]}")
-    print(f"{'='*60}\n")
+    print(f"{'=' * 60}\n")
 
     # @@@ Load voices from user's enabled decks (deck system)
     voices = database.load_voices_from_user_decks(user_id)
@@ -188,13 +209,13 @@ def chat_with_voice(voice_id: str, user_id: int, conversation_history: list, use
     # @@@ Get voice config for this specific voice
     if voice_id in voices:
         voice_config = voices[voice_id]
-        voice_name = voice_config.get('name', voice_id)
+        voice_name = voice_config.get("name", voice_id)
         print(f"üìö Loaded voice from deck system: {voice_id} ({voice_name})")
     else:
         # Fallback: voice might be disabled or not in user's decks
         return {
             "success": False,
-            "error": f"Voice {voice_id} not found in your enabled decks. Please enable it in the Decks tab."
+            "error": f"Voice {voice_id} not found in your enabled decks. Please enable it in the Decks tab.",
         }
 
     agent = PolyAgent(id=f"voice-chat-{voice_name.lower()}")
@@ -202,7 +223,7 @@ def chat_with_voice(voice_id: str, user_id: int, conversation_history: list, use
     # Build system prompt for this voice
     system_prompt = f"""You are {voice_name}, an inner voice archetype from Disco Elysium.
 
-Your character: {voice_config.get('systemPrompt', '')}
+Your character: {voice_config.get("systemPrompt", "")}
 
 Respond in character as {voice_name}. Be concise (1-3 sentences). Stay true to your archetype.
 Use the conversation context but focus on your unique perspective."""
@@ -253,10 +274,8 @@ User's current state:
 
     print(f"‚úÖ Got response: {response[:100]}...")
 
-    return {
-        "response": response,
-        "voice_name": voice_name
-    }
+    return {"response": response, "voice_name": voice_name}
+
 
 @session_def(
     name="Analyze Voices",
@@ -268,13 +287,21 @@ User's current state:
         "applied_comments": {"type": "list"},
         "meta_prompt": {"type": "str"},
         "state_prompt": {"type": "str"},
-        "overlapped_phrases": {"type": "list"}
+        "overlapped_phrases": {"type": "list"},
     },
-    category="Analysis"
+    category="Analysis",
 )
-def analyze_text(text: str, editor_session_id: str, user_id: int, applied_comments: list = None, meta_prompt: str = "", state_prompt: str = "", overlapped_phrases: list = None):
+def analyze_text(
+    text: str,
+    editor_session_id: str,
+    user_id: int,
+    applied_comments: list = None,
+    meta_prompt: str = "",
+    state_prompt: str = "",
+    overlapped_phrases: list = None,
+):
     """Stateless analysis - returns ONE new comment based on text and applied comments."""
-    print(f"\n{'='*60}")
+    print(f"\n{'=' * 60}")
     print(f"üéØ Stateless analyze_text() called")
     print(f"   User ID: {user_id}")
     print(f"   Text: {text[:100]}...")
@@ -282,43 +309,54 @@ def analyze_text(text: str, editor_session_id: str, user_id: int, applied_commen
     print(f"   Overlapped phrases: {len(overlapped_phrases or [])}")
     print(f"   Meta prompt: {repr(meta_prompt)[:100]}")
     print(f"   State prompt: {repr(state_prompt)[:100]}")
-    print(f"{'='*60}\n")
+    print(f"{'=' * 60}\n")
 
     # @@@ Load voices from user's enabled decks (deck system)
     voices = database.load_voices_from_user_decks(user_id)
-    print(f"üìö Loaded {len(voices)} enabled voices from deck system: {list(voices.keys()) if voices else 'None (will use defaults)'}")
+    print(
+        f"üìö Loaded {len(voices)} enabled voices from deck system: {list(voices.keys()) if voices else 'None (will use defaults)'}"
+    )
 
     agent = PolyAgent(id="voice-analyzer")
 
     # Get voices from stateless analyzer
-    result = analyze_stateless(agent, text, applied_comments or [], voices, meta_prompt, state_prompt, overlapped_phrases or [])
+    result = analyze_stateless(
+        agent,
+        text,
+        applied_comments or [],
+        voices,
+        meta_prompt,
+        state_prompt,
+        overlapped_phrases or [],
+    )
 
     print(f"‚úÖ Returning {result['new_voices_added']} new voice(s)")
 
     return {
         "voices": result["voices"],
         "new_voices_added": result["new_voices_added"],
-        "status": "completed"
+        "status": "completed",
     }
 
+
 @session_def(
     name="Analyze Echoes",
     description="Find recurring themes and topics in all user notes",
     params={
         "all_notes": {"type": "str"},
         "user_id": {"type": "int"},
-        "language": {"type": "str"}
+        "language": {"type": "str"},
     },
-    category="Analysis"
+    category="Analysis",
 )
 def analyze_echoes(all_notes: str, user_id: int, language: str = "en"):
     """Analyze recurring themes and topics across all notes."""
-    print(f"\n{'='*60}")
+    print(f"\n{'=' * 60}")
     print(f"üîÑ analyze_echoes() called")
     print(f"   Notes length: {len(all_notes)} chars")
     language_code = normalize_language_code(language)
     print(f"   Language: {language_code}")
-    print(f"{'='*60}\n")
+    print(f"{'=' * 60}\n")
 
     agent = PolyAgent(id="echoes-analyzer")
 
@@ -350,29 +388,31 @@ Return ONLY the JSON array, no other text."""
 
     try:
         import json
+
         echoes = json.loads(result.content.strip())
         return {"echoes": echoes}
     except:
         return {"echoes": []}
 
+
 @session_def(
     name="Analyze Traits",
     description="Identify personality traits and characteristics from user notes",
     params={
         "all_notes": {"type": "str"},
         "user_id": {"type": "int"},
-        "language": {"type": "str"}
+        "language": {"type": "str"},
     },
-    category="Analysis"
+    category="Analysis",
 )
 def analyze_traits(all_notes: str, user_id: int, language: str = "en"):
     """Analyze personality traits from all notes."""
-    print(f"\n{'='*60}")
+    print(f"\n{'=' * 60}")
     print(f"üë§ analyze_traits() called")
     print(f"   Notes length: {len(all_notes)} chars")
     language_code = normalize_language_code(language)
     print(f"   Language: {language_code}")
-    print(f"{'='*60}\n")
+    print(f"{'=' * 60}\n")
 
     agent = PolyAgent(id="traits-analyzer")
 
@@ -404,29 +444,31 @@ Return ONLY the JSON array, no other text."""
 
     try:
         import json
+
         traits = json.loads(result.content.strip())
         return {"traits": traits}
     except:
         return {"traits": []}
 
+
 @session_def(
     name="Analyze Patterns",
     description="Identify behavioral patterns and habits from user notes",
     params={
         "all_notes": {"type": "str"},
         "user_id": {"type": "int"},
-        "language": {"type": "str"}
+        "language": {"type": "str"},
     },
-    category="Analysis"
+    category="Analysis",
 )
 def analyze_patterns(all_notes: str, user_id: int, language: str = "en"):
     """Analyze behavioral patterns from all notes."""
-    print(f"\n{'='*60}")
+    print(f"\n{'=' * 60}")
     print(f"üîç analyze_patterns() called")
     print(f"   Notes length: {len(all_notes)} chars")
     language_code = normalize_language_code(language)
     print(f"   Language: {language_code}")
-    print(f"{'='*60}\n")
+    print(f"{'=' * 60}\n")
 
     agent = PolyAgent(id="patterns-analyzer")
 
@@ -458,20 +500,22 @@ Return ONLY the JSON array, no other text."""
 
     try:
         import json
+
         patterns = json.loads(result.content.strip())
         return {"patterns": patterns}
     except:
         return {"patterns": []}
 
+
 @session_def(
     name="Generate Daily Picture",
     description="Generate an artistic image based on user's daily notes",
     params={
         "all_notes": {"type": "str"},
         "user_id": {"type": "int"},
-        "target_date": {"type": "str"}  # Optional: YYYY-MM-DD format
+        "target_date": {"type": "str"},  # Optional: YYYY-MM-DD format
     },
-    category="Creative"
+    category="Creative",
 )
 def generate_daily_picture(all_notes: str, user_id: int, target_date: str = None):
     """Generate an image based on the essence of user's daily notes.
@@ -484,13 +528,13 @@ def generate_daily_picture(all_notes: str, user_id: int, target_date: str = None
     from datetime import datetime
 
     if target_date is None:
-        target_date = datetime.now().strftime('%Y-%m-%d')
+        target_date = datetime.now().strftime("%Y-%m-%d")
 
-    print(f"\n{'='*60}")
+    print(f"\n{'=' * 60}")
     print(f"üé® generate_daily_picture() called")
     print(f"   Notes length: {len(all_notes)} chars")
     print(f"   Target date: {target_date}")
-    print(f"{'='*60}\n")
+    print(f"{'=' * 60}\n")
 
     import requests
 
@@ -500,7 +544,7 @@ def generate_daily_picture(all_notes: str, user_id: int, target_date: str = None
         db = database.get_db()
         recent_prompts = db.execute(
             "SELECT prompt FROM daily_pictures WHERE user_id = ? ORDER BY date DESC LIMIT 5",
-            (user_id,)
+            (user_id,),
         ).fetchall()
         db.close()
 
@@ -513,7 +557,9 @@ def generate_daily_picture(all_notes: str, user_id: int, target_date: str = None
                 recent_prompts_text += "\n‚ö†Ô∏è IMPORTANT: Create something COMPLETELY DIFFERENT from all previous descriptions above!\n"
                 recent_prompts_text += "‚ö†Ô∏è Use different: setting, objects, style, mood, time of day, colors, composition.\n"
                 recent_prompts_text += "‚ö†Ô∏è Be creative and avoid repetition!\n"
-                print(f"üìã Found {len(recent_prompts_list)} recent prompts to avoid duplication")
+                print(
+                    f"üìã Found {len(recent_prompts_list)} recent prompts to avoid duplication"
+                )
     except Exception as e:
         print(f"‚ö†Ô∏è Could not fetch recent prompts: {e}")
 
@@ -553,29 +599,30 @@ Return ONLY the minimal image description, no other text."""
 
     print("üß† Creating image description from notes with Claude Haiku...")
 
-    # Use proxy for GFW bypass (if configured)
-    proxies = get_image_api_proxies()
-
     claude_response = requests.post(
         f"{config.IMAGE_API_ENDPOINT}/chat/completions",
         headers={
             "Authorization": f"Bearer {config.IMAGE_API_KEY}",
-            "Content-Type": "application/json"
+            "Content-Type": "application/json",
         },
         json={
             "model": config.IMAGE_DESCRIPTION_MODEL,
             "messages": [{"role": "user", "content": description_prompt}],
-            "max_tokens": config.IMAGE_DESCRIPTION_MAX_TOKENS
+            "max_tokens": config.IMAGE_DESCRIPTION_MAX_TOKENS,
         },
-        proxies=proxies,
-        timeout=config.IMAGE_DESCRIPTION_TIMEOUT
+        timeout=config.IMAGE_DESCRIPTION_TIMEOUT,
     )
 
     if claude_response.status_code != 200:
         return {"image_base64": None, "error": "Failed to create image description"}
 
     claude_data = claude_response.json()
-    image_description = claude_data.get('choices', [{}])[0].get('message', {}).get('content', '').strip()
+    image_description = (
+        claude_data.get("choices", [{}])[0]
+        .get("message", {})
+        .get("content", "")
+        .strip()
+    )
 
     if not image_description:
         return {"image_base64": None, "error": "Failed to create image description"}
@@ -586,32 +633,38 @@ Return ONLY the minimal image description, no other text."""
     url = f"{config.IMAGE_API_ENDPOINT}/chat/completions"
     headers = {
         "Authorization": f"Bearer {config.IMAGE_API_KEY}",
-        "Content-Type": "application/json"
+        "Content-Type": "application/json",
     }
 
     payload = {
         "model": config.IMAGE_GENERATION_MODEL,
-        "messages": [
-            {
-                "role": "user",
-                "content": image_description
-            }
-        ],
-        "max_tokens": config.IMAGE_MAX_TOKENS
+        "messages": [{"role": "user", "content": image_description}],
+        "max_tokens": config.IMAGE_MAX_TOKENS,
     }
 
     # Retry logic with increasing timeouts
     for attempt in range(1, config.IMAGE_RETRY_MAX_ATTEMPTS + 1):
         try:
-            timeout_seconds = config.IMAGE_RETRY_BASE_TIMEOUT + (attempt - 1) * config.IMAGE_RETRY_TIMEOUT_INCREMENT
-            print(f"üé® Generating image (attempt {attempt}/{config.IMAGE_RETRY_MAX_ATTEMPTS}, timeout={timeout_seconds}s)...")
-            response = requests.post(url, headers=headers, json=payload, proxies=proxies, timeout=timeout_seconds)
+            timeout_seconds = (
+                config.IMAGE_RETRY_BASE_TIMEOUT
+                + (attempt - 1) * config.IMAGE_RETRY_TIMEOUT_INCREMENT
+            )
+            print(
+                f"üé® Generating image (attempt {attempt}/{config.IMAGE_RETRY_MAX_ATTEMPTS}, timeout={timeout_seconds}s)..."
+            )
+            response = requests.post(
+                url,
+                headers=headers,
+                json=payload,
+                timeout=timeout_seconds,
+            )
 
             if response.status_code != 200:
                 print(f"‚ùå Error: {response.status_code}")
                 if attempt < config.IMAGE_RETRY_MAX_ATTEMPTS:
                     print(f"‚è≥ Retrying in 2 seconds...")
                     import time
+
                     time.sleep(2)
                     continue
                 return {"image_base64": None, "error": "Image generation failed"}
@@ -619,16 +672,16 @@ Return ONLY the minimal image description, no other text."""
             data = response.json()
 
             # Extract image from response
-            if 'choices' in data and len(data['choices']) > 0:
-                message = data['choices'][0].get('message', {})
-                images = message.get('images', [])
+            if "choices" in data and len(data["choices"]) > 0:
+                message = data["choices"][0].get("message", {})
+                images = message.get("images", [])
 
                 if images:
-                    image_data = images[0].get('image_url', {}).get('url', '')
+                    image_data = images[0].get("image_url", {}).get("url", "")
 
-                    if image_data.startswith('data:image/png;base64,'):
+                    if image_data.startswith("data:image/png;base64,"):
                         # Extract base64 data (without the data URI prefix)
-                        base64_data = image_data.split(',', 1)[1]
+                        base64_data = image_data.split(",", 1)[1]
 
                         # @@@ Convert to JPEG and create thumbnail
                         try:
@@ -641,9 +694,9 @@ Return ONLY the minimal image description, no other text."""
                             img = Image.open(BytesIO(img_bytes))
 
                             # Convert to RGB (JPEG doesn't support transparency)
-                            if img.mode in ('RGBA', 'LA', 'P'):
-                                rgb_img = Image.new('RGB', img.size, (255, 255, 255))
-                                if img.mode == 'RGBA':
+                            if img.mode in ("RGBA", "LA", "P"):
+                                rgb_img = Image.new("RGB", img.size, (255, 255, 255))
+                                if img.mode == "RGBA":
                                     rgb_img.paste(img, mask=img.split()[-1])
                                 else:
                                     rgb_img.paste(img)
@@ -651,39 +704,54 @@ Return ONLY the minimal image description, no other text."""
 
                             # Full JPEG (quality 85)
                             full_output = BytesIO()
-                            img.save(full_output, format='JPEG', quality=85, optimize=True)
-                            full_jpeg = base64.b64encode(full_output.getvalue()).decode('utf-8')
+                            img.save(
+                                full_output, format="JPEG", quality=85, optimize=True
+                            )
+                            full_jpeg = base64.b64encode(full_output.getvalue()).decode(
+                                "utf-8"
+                            )
 
                             # Thumbnail JPEG (400px width, quality 60)
                             thumb_width = 400
                             thumb_height = int(img.height * (thumb_width / img.width))
-                            thumb_img = img.resize((thumb_width, thumb_height), Image.Resampling.LANCZOS)
+                            thumb_img = img.resize(
+                                (thumb_width, thumb_height), Image.Resampling.LANCZOS
+                            )
 
                             thumb_output = BytesIO()
-                            thumb_img.save(thumb_output, format='JPEG', quality=60, optimize=True)
-                            thumb_jpeg = base64.b64encode(thumb_output.getvalue()).decode('utf-8')
+                            thumb_img.save(
+                                thumb_output, format="JPEG", quality=60, optimize=True
+                            )
+                            thumb_jpeg = base64.b64encode(
+                                thumb_output.getvalue()
+                            ).decode("utf-8")
 
                             print(f"‚úÖ Image generated successfully")
                             print(f"   Original PNG: {len(base64_data)} chars")
-                            print(f"   Full JPEG: {len(full_jpeg)} chars ({100 * len(full_jpeg) / len(base64_data):.1f}%)")
-                            print(f"   Thumbnail: {len(thumb_jpeg)} chars ({100 * len(thumb_jpeg) / len(base64_data):.1f}%)")
+                            print(
+                                f"   Full JPEG: {len(full_jpeg)} chars ({100 * len(full_jpeg) / len(base64_data):.1f}%)"
+                            )
+                            print(
+                                f"   Thumbnail: {len(thumb_jpeg)} chars ({100 * len(thumb_jpeg) / len(base64_data):.1f}%)"
+                            )
 
                             return {
                                 "image_base64": full_jpeg,
                                 "thumbnail_base64": thumb_jpeg,
-                                "prompt": image_description
+                                "prompt": image_description,
                             }
                         except Exception as e:
                             print(f"‚ö†Ô∏è JPEG conversion failed: {e}, using original PNG")
                             return {
                                 "image_base64": base64_data,
                                 "thumbnail_base64": base64_data,  # Fallback to full image
-                                "prompt": image_description
+                                "prompt": image_description,
                             }
 
             if attempt < config.IMAGE_RETRY_MAX_ATTEMPTS:
                 print(f"‚ö†Ô∏è No image in response, retrying...")
                 import time
+
                 time.sleep(2)
                 continue
             return {"image_base64": None, "error": "No image in response"}
@@ -693,18 +761,20 @@ Return ONLY the minimal image description, no other text."""
             if attempt < config.IMAGE_RETRY_MAX_ATTEMPTS:
                 print(f"‚è≥ Retrying in 2 seconds...")
                 import time
+
                 time.sleep(2)
                 continue
             return {"image_base64": None, "error": str(e)}
 
     return {"image_base64": None, "error": "All retry attempts failed"}
 
+
 # ========== FastAPI Application ==========
 
 app = FastAPI(
     title="Ink & Memory API",
     description="Voice analysis and creative generation API",
-    version="2.0.0"
+    version="2.0.0",
 )
 
 # Add CORS middleware
@@ -724,30 +794,32 @@ import scheduler as timeline_scheduler
 # Create scheduler instance
 timeline_gen_scheduler = AsyncIOScheduler()
 
+
 @app.on_event("startup")
 async def startup_scheduler():
     """Start the timeline auto-generation scheduler on app startup."""
-    print("\n" + "="*60)
+    print("\n" + "=" * 60)
     print("üìÖ Starting Timeline Auto-Generation Scheduler")
     print("   Schedule: Daily at 00:00 (midnight, Asia/Shanghai timezone)")
     print("   Generates timeline images for previous day")
-    print("="*60 + "\n")
+    print("=" * 60 + "\n")
 
     # @@@ asyncio.run() creates new event loop for scheduler thread
     timeline_gen_scheduler.add_job(
         lambda: asyncio.run(timeline_scheduler.daily_generation_job()),
-        'cron',
+        "cron",
         hour=0,
         minute=0,
-        timezone='Asia/Shanghai',
-        id='daily_timeline_generation',
-        name='Generate timeline images for yesterday',
-        replace_existing=True
+        timezone="Asia/Shanghai",
+        id="daily_timeline_generation",
+        name="Generate timeline images for yesterday",
+        replace_existing=True,
     )
 
     timeline_gen_scheduler.start()
     print("‚úÖ Scheduler started - next run at midnight (00:00 Asia/Shanghai)\n")
 
+
 @app.on_event("shutdown")
 async def shutdown_scheduler():
     """Shutdown the scheduler gracefully."""
@@ -755,21 +827,26 @@ async def shutdown_scheduler():
     timeline_gen_scheduler.shutdown(wait=False)
     print("‚úÖ Scheduler shutdown complete\n")
 
+
 # ========== Request/Response Models ==========
 
+
 class RegisterRequest(BaseModel):
     email: str
     password: str
     display_name: Optional[str] = None
 
+
 class LoginRequest(BaseModel):
     email: str
     password: str
 
+
 class TokenResponse(BaseModel):
     token: str
     user: dict
 
+
 class ImportDataRequest(BaseModel):
     currentSession: Optional[str] = None
     calendarEntries: Optional[str] = None
@@ -781,8 +858,10 @@ class ImportDataRequest(BaseModel):
     analysisReports: Optional[str] = None
     oldDocument: Optional[str] = None
 
+
 # ========== Auth Dependency ==========
 
+
 def get_current_user(authorization: Optional[str] = Header(None)) -> dict:
     """
     Dependency to extract and verify JWT token from Authorization header.
@@ -800,8 +879,10 @@ def get_current_user(authorization: Optional[str] = Header(None)) -> dict:
 
     return user_data
 
+
 # ========== Custom API Endpoints (Clean Interface) ==========
 
+
 @app.get("/")
 def root():
     """Root endpoint"""
@@ -809,11 +890,13 @@ def root():
         "service": "Ink & Memory API",
         "version": "2.0.0",
         "docs": "/docs",
-        "control_panel": "/polycli"
+        "control_panel": "/polycli",
     }
 
+
 # ========== Auth Endpoints ==========
 
+
 @app.post("/api/register", response_model=TokenResponse)
 def register(request: RegisterRequest):
     """
@@ -826,14 +909,18 @@ def register(request: RegisterRequest):
         raise HTTPException(status_code=400, detail="Email and password required")
 
     if len(request.password) < 6:
-        raise HTTPException(status_code=400, detail="Password must be at least 6 characters")
+        raise HTTPException(
+            status_code=400, detail="Password must be at least 6 characters"
+        )
 
     # Hash password
     password_hash = auth.hash_password(request.password)
 
     # Create user
     try:
-        user_id = database.create_user(request.email, password_hash, request.display_name)
+        user_id = database.create_user(
+            request.email, password_hash, request.display_name
+        )
     except ValueError as e:
         raise HTTPException(status_code=400, detail=str(e))
 
@@ -848,10 +935,11 @@ def register(request: RegisterRequest):
         "user": {
             "id": user_id,
             "email": request.email,
-            "display_name": request.display_name
-        }
+            "display_name": request.display_name,
+        },
     }
 
+
 @app.post("/api/login", response_model=TokenResponse)
 def login(request: LoginRequest):
     """
@@ -865,26 +953,27 @@ def login(request: LoginRequest):
         raise HTTPException(status_code=401, detail="Invalid email or password")
 
     # Verify password
-    if not auth.verify_password(request.password, user['password_hash']):
+    if not auth.verify_password(request.password, user["password_hash"]):
         raise HTTPException(status_code=401, detail="Invalid email or password")
 
     # @@@ Auto-fork system decks if user has no decks yet (handles existing users)
-    user_decks = database.get_user_decks(user['id'])
+    user_decks = database.get_user_decks(user["id"])
     if len(user_decks) == 0:
-        database.auto_fork_system_decks(user['id'])
+        database.auto_fork_system_decks(user["id"])
 
     # Generate token
-    token = auth.create_access_token(user['id'], user['email'])
+    token = auth.create_access_token(user["id"], user["email"])
 
     return {
         "token": token,
         "user": {
-            "id": user['id'],
-            "email": user['email'],
-            "display_name": user['display_name']
-        }
+            "id": user["id"],
+            "email": user["email"],
+            "display_name": user["display_name"],
+        },
     }
 
+
 @app.get("/api/me")
 def get_current_user_info(current_user: dict = Depends(get_current_user)):
     """
@@ -892,19 +981,22 @@ def get_current_user_info(current_user: dict = Depends(get_current_user)):
 
     Requires Authorization header with Bearer token.
     """
-    user = database.get_user_by_id(current_user['user_id'])
+    user = database.get_user_by_id(current_user["user_id"])
     if not user:
         raise HTTPException(status_code=404, detail="User not found")
 
     return {
-        "id": user['id'],
-        "email": user['email'],
-        "display_name": user['display_name'],
-        "created_at": user['created_at']
+        "id": user["id"],
+        "email": user["email"],
+        "display_name": user["display_name"],
+        "created_at": user["created_at"],
     }
 
+
 @app.post("/api/import-local-data")
-def import_local_data(request: ImportDataRequest, current_user: dict = Depends(get_current_user)):
+def import_local_data(
+    request: ImportDataRequest, current_user: dict = Depends(get_current_user)
+):
     """
     Import localStorage data to database on first login.
 
@@ -912,13 +1004,21 @@ def import_local_data(request: ImportDataRequest, current_user: dict = Depends(g
     """
     import json
 
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
 
     print(f"\nüîç Migration request for user {user_id}:")
-    print(f"  - currentSession: {len(request.currentSession) if request.currentSession else 0} chars")
-    print(f"  - calendarEntries: {len(request.calendarEntries) if request.calendarEntries else 0} chars")
-    print(f"  - dailyPictures: {len(request.dailyPictures) if request.dailyPictures else 0} chars")
-    print(f"  - oldDocument: {len(request.oldDocument) if request.oldDocument else 0} chars")
+    print(
+        f"  - currentSession: {len(request.currentSession) if request.currentSession else 0} chars"
+    )
+    print(
+        f"  - calendarEntries: {len(request.calendarEntries) if request.calendarEntries else 0} chars"
+    )
+    print(
+        f"  - dailyPictures: {len(request.dailyPictures) if request.dailyPictures else 0} chars"
+    )
+    print(
+        f"  - oldDocument: {len(request.oldDocument) if request.oldDocument else 0} chars"
+    )
 
     # Extract sessions
     sessions = []
@@ -927,11 +1027,13 @@ def import_local_data(request: ImportDataRequest, current_user: dict = Depends(g
     if request.currentSession:
         try:
             current = json.loads(request.currentSession)
-            sessions.append({
-                'id': 'current-session',
-                'name': 'Current Session',
-                'editor_state': current
-            })
+            sessions.append(
+                {
+                    "id": "current-session",
+                    "name": "Current Session",
+                    "editor_state": current,
+                }
+            )
             print(f"‚úÖ Imported current session ({len(str(current))} chars)")
         except Exception as e:
             print(f"‚ùå Failed to parse current session: {e}")
@@ -945,26 +1047,33 @@ def import_local_data(request: ImportDataRequest, current_user: dict = Depends(g
             for date, entries in calendar.items():
                 print(f"  - {date}: {len(entries)} entries")
                 for entry in entries:
-                    sessions.append({
-                        'id': entry['id'],
-                        'name': f"{date} - {entry.get('firstLine', 'Untitled')}",
-                        'editor_state': entry['state']
-                    })
+                    sessions.append(
+                        {
+                            "id": entry["id"],
+                            "name": f"{date} - {entry.get('firstLine', 'Untitled')}",
+                            "editor_state": entry["state"],
+                        }
+                    )
         except Exception as e:
             print(f"‚ùå Failed to parse calendar entries: {e}")
             import traceback
+
             traceback.print_exc()
 
     # 3. Old document (if exists)
     if request.oldDocument:
         try:
             old_doc = json.loads(request.oldDocument)
-            if old_doc and old_doc.get('document'):
-                sessions.append({
-                    'id': 'old-document',
-                    'name': 'Old Document (migrated)',
-                    'editor_state': {'cells': [{'type': 'text', 'content': str(old_doc)}]}
-                })
+            if old_doc and old_doc.get("document"):
+                sessions.append(
+                    {
+                        "id": "old-document",
+                        "name": "Old Document (migrated)",
+                        "editor_state": {
+                            "cells": [{"type": "text", "content": str(old_doc)}]
+                        },
+                    }
+                )
         except:
             pass
 
@@ -974,11 +1083,13 @@ def import_local_data(request: ImportDataRequest, current_user: dict = Depends(g
         try:
             pics = json.loads(request.dailyPictures)
             for pic in pics:
-                pictures.append({
-                    'date': pic['date'],
-                    'image_base64': pic['base64'],
-                    'prompt': pic.get('prompt', '')
-                })
+                pictures.append(
+                    {
+                        "date": pic["date"],
+                        "image_base64": pic["base64"],
+                        "prompt": pic.get("prompt", ""),
+                    }
+                )
         except:
             pass
 
@@ -986,21 +1097,21 @@ def import_local_data(request: ImportDataRequest, current_user: dict = Depends(g
     preferences = {}
     if request.voiceCustomizations:
         try:
-            preferences['voice_configs'] = json.loads(request.voiceCustomizations)
+            preferences["voice_configs"] = json.loads(request.voiceCustomizations)
         except:
             pass
 
     if request.metaPrompt:
-        preferences['meta_prompt'] = request.metaPrompt
+        preferences["meta_prompt"] = request.metaPrompt
 
     if request.stateConfig:
         try:
-            preferences['state_config'] = json.loads(request.stateConfig)
+            preferences["state_config"] = json.loads(request.stateConfig)
         except:
             pass
 
     if request.selectedState:
-        preferences['selected_state'] = request.selectedState
+        preferences["selected_state"] = request.selectedState
 
     # Extract reports
     reports = []
@@ -1008,12 +1119,14 @@ def import_local_data(request: ImportDataRequest, current_user: dict = Depends(g
         try:
             report_list = json.loads(request.analysisReports)
             for report in report_list:
-                reports.append({
-                    'type': report.get('type', 'unknown'),
-                    'data': report.get('data', {}),
-                    'allNotes': report.get('allNotes', ''),
-                    'timestamp': report.get('timestamp', '')
-                })
+                reports.append(
+                    {
+                        "type": report.get("type", "unknown"),
+                        "data": report.get("data", {}),
+                        "allNotes": report.get("allNotes", ""),
+                        "timestamp": report.get("timestamp", ""),
+                    }
+                )
         except:
             pass
 
@@ -1026,17 +1139,16 @@ def import_local_data(request: ImportDataRequest, current_user: dict = Depends(g
             "sessions": len(sessions),
             "pictures": len(pictures),
             "preferences": len([k for k, v in preferences.items() if v]),
-            "reports": len(reports)
-        }
+            "reports": len(reports),
+        },
     }
 
+
 # ========== Session Storage Endpoints ==========
 
+
 @app.post("/api/sessions")
-def save_session(
-    request: dict,
-    current_user: dict = Depends(get_current_user)
-):
+def save_session(request: dict, current_user: dict = Depends(get_current_user)):
     """
     Save or update a session.
 
@@ -1047,22 +1159,24 @@ def save_session(
         "editor_state": {...}
     }
     """
-    user_id = current_user['user_id']
-    session_id = request.get('session_id')
-    editor_state = request.get('editor_state')
-    name = request.get('name')
+    user_id = current_user["user_id"]
+    session_id = request.get("session_id")
+    editor_state = request.get("editor_state")
+    name = request.get("name")
 
     if not session_id or not editor_state:
-        raise HTTPException(status_code=400, detail="session_id and editor_state required")
+        raise HTTPException(
+            status_code=400, detail="session_id and editor_state required"
+        )
 
     database.save_session(user_id, session_id, editor_state, name)
 
     return {"success": True}
 
+
 @app.post("/api/import-calendar-recovery")
 def import_calendar_recovery(
-    request: dict,
-    current_user: dict = Depends(get_current_user)
+    request: dict, current_user: dict = Depends(get_current_user)
 ):
     """
     Recovery endpoint to import calendar entries that were missed in initial migration.
@@ -1074,8 +1188,8 @@ def import_calendar_recovery(
     """
     import json
 
-    user_id = current_user['user_id']
-    calendar_json = request.get('calendarEntries')
+    user_id = current_user["user_id"]
+    calendar_json = request.get("calendarEntries")
 
     if not calendar_json:
         raise HTTPException(status_code=400, detail="calendarEntries required")
@@ -1087,26 +1201,27 @@ def import_calendar_recovery(
         for date, entries in calendar.items():
             print(f"  - {date}: {len(entries)} entries")
             for entry in entries:
-                sessions.append({
-                    'id': entry['id'],
-                    'name': f"{date} - {entry.get('firstLine', 'Untitled')}",
-                    'editor_state': entry['state']
-                })
+                sessions.append(
+                    {
+                        "id": entry["id"],
+                        "name": f"{date} - {entry.get('firstLine', 'Untitled')}",
+                        "editor_state": entry["state"],
+                    }
+                )
     except Exception as e:
         print(f"‚ùå Failed to parse calendar: {e}")
         import traceback
+
         traceback.print_exc()
-        raise HTTPException(status_code=400, detail=f"Failed to parse calendar: {str(e)}")
+        raise HTTPException(
+            status_code=400, detail=f"Failed to parse calendar: {str(e)}"
+        )
 
     # Import to database
     database.import_user_data(user_id, sessions, [], {}, [])
 
-    return {
-        "success": True,
-        "imported": {
-            "sessions": len(sessions)
-        }
-    }
+    return {"success": True, "imported": {"sessions": len(sessions)}}
+
 
 @app.get("/api/sessions")
 def list_sessions(current_user: dict = Depends(get_current_user)):
@@ -1115,10 +1230,11 @@ def list_sessions(current_user: dict = Depends(get_current_user)):
 
     Returns: Array of session metadata (without full editor state)
     """
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     sessions = database.list_sessions(user_id)
     return {"sessions": sessions}
 
+
 @app.get("/api/sessions/{session_id}")
 def get_session(session_id: str, current_user: dict = Depends(get_current_user)):
     """
@@ -1126,7 +1242,7 @@ def get_session(session_id: str, current_user: dict = Depends(get_current_user))
 
     Returns: Full session including editor_state
     """
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     session = database.get_session(user_id, session_id)
 
     if not session:
@@ -1134,42 +1250,42 @@ def get_session(session_id: str, current_user: dict = Depends(get_current_user))
 
     return session
 
+
 @app.delete("/api/sessions/{session_id}")
-def delete_session_endpoint(session_id: str, current_user: dict = Depends(get_current_user)):
+def delete_session_endpoint(
+    session_id: str, current_user: dict = Depends(get_current_user)
+):
     """Delete a session."""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     database.delete_session(user_id, session_id)
     return {"success": True}
 
+
 # ========== Pictures Endpoints ==========
 
+
 @app.get("/api/pictures")
-def get_pictures(
-    limit: int = 30,
-    current_user: dict = Depends(get_current_user)
-):
+def get_pictures(limit: int = 30, current_user: dict = Depends(get_current_user)):
     """
     Get recent daily pictures for current user (thumbnails only for fast loading).
 
     Query params:
     - limit: Max number of pictures to return (default 30)
     """
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     pictures = database.get_daily_pictures(user_id, limit)
     return {"pictures": pictures}
 
+
 @app.get("/api/pictures/{date}/full")
-def get_picture_full(
-    date: str,
-    current_user: dict = Depends(get_current_user)
-):
+def get_picture_full(date: str, current_user: dict = Depends(get_current_user)):
     """
     Get full resolution image for a specific date (on-demand loading).
 
     Path params:
     - date: Date in YYYY-MM-DD format
     """
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     full_image = database.get_daily_picture_full(user_id, date)
 
     if not full_image:
@@ -1180,24 +1296,22 @@ def get_picture_full(
 
 @app.get("/api/friends/{friend_id}/pictures/{date}/full")
 def get_friend_picture_full_endpoint(
-    friend_id: int,
-    date: str,
-    current_user: dict = Depends(get_current_user)
+    friend_id: int, date: str, current_user: dict = Depends(get_current_user)
 ):
     """Get full resolution image for a friend's specific date (only if users are friends)."""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     full_image = database.get_friend_picture_full(user_id, friend_id, date)
 
     if not full_image:
-        raise HTTPException(status_code=404, detail="Picture not found or not accessible")
+        raise HTTPException(
+            status_code=404, detail="Picture not found or not accessible"
+        )
 
     return {"image_base64": full_image}
 
+
 @app.post("/api/pictures")
-def save_picture(
-    request: dict,
-    current_user: dict = Depends(get_current_user)
-):
+def save_picture(request: dict, current_user: dict = Depends(get_current_user)):
     """
     Save a daily picture.
 
@@ -1208,11 +1322,11 @@ def save_picture(
         "prompt": "optional prompt"
     }
     """
-    user_id = current_user['user_id']
-    date = request.get('date')
-    image_base64 = request.get('image_base64')
-    thumbnail_base64 = request.get('thumbnail_base64')
-    prompt = request.get('prompt', '')
+    user_id = current_user["user_id"]
+    date = request.get("date")
+    image_base64 = request.get("image_base64")
+    thumbnail_base64 = request.get("thumbnail_base64")
+    prompt = request.get("prompt", "")
 
     if not date or not image_base64:
         raise HTTPException(status_code=400, detail="date and image_base64 required")
@@ -1220,19 +1334,21 @@ def save_picture(
     database.save_daily_picture(user_id, date, image_base64, prompt, thumbnail_base64)
     return {"success": True}
 
+
 # ========== Preferences Endpoints ==========
 
+
 @app.get("/api/preferences")
 def get_preferences(current_user: dict = Depends(get_current_user)):
     """Get user preferences."""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     preferences = database.get_preferences(user_id)
     return preferences or {}
 
+
 @app.post("/api/preferences")
 def save_preferences_endpoint(
-    request: dict,
-    current_user: dict = Depends(get_current_user)
+    request: dict, current_user: dict = Depends(get_current_user)
 ):
     """
     Save user preferences.
@@ -1243,48 +1359,47 @@ def save_preferences_endpoint(
     - state_config: dict
     - selected_state: str
     """
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
 
     database.save_preferences(
         user_id,
-        voice_configs=request.get('voice_configs'),
-        meta_prompt=request.get('meta_prompt'),
-        state_config=request.get('state_config'),
-        selected_state=request.get('selected_state'),
-        timezone=request.get('timezone')
+        voice_configs=request.get("voice_configs"),
+        meta_prompt=request.get("meta_prompt"),
+        state_config=request.get("state_config"),
+        selected_state=request.get("selected_state"),
+        timezone=request.get("timezone"),
     )
 
     return {"success": True}
 
+
 # @@@ Removed /api/suggest wrapper - frontend now calls /polycli/api/trigger-sync directly
 
+
 @app.post("/api/mark-first-login-completed")
 def mark_first_login_completed(current_user: dict = Depends(get_current_user)):
     """
     Mark user's first login as completed.
     Called after migration dialog is shown (migrate or skip).
     """
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     database.set_first_login_completed(user_id)
     return {"success": True}
 
+
 # ========== Analysis Reports Endpoints ==========
 
+
 @app.get("/api/reports")
-def get_reports(
-    limit: int = 10,
-    current_user: dict = Depends(get_current_user)
-):
+def get_reports(limit: int = 10, current_user: dict = Depends(get_current_user)):
     """Get recent analysis reports."""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     reports = database.get_analysis_reports(user_id, limit)
     return {"reports": reports}
 
+
 @app.post("/api/reports")
-def save_report(
-    request: dict,
-    current_user: dict = Depends(get_current_user)
-):
+def save_report(request: dict, current_user: dict = Depends(get_current_user)):
     """
     Save an analysis report.
 
@@ -1295,24 +1410,30 @@ def save_report(
         "all_notes_text": "optional text"
     }
     """
-    user_id = current_user['user_id']
-    report_type = request.get('report_type')
-    report_data = request.get('report_data')
-    all_notes_text = request.get('all_notes_text', '')
+    user_id = current_user["user_id"]
+    report_type = request.get("report_type")
+    report_data = request.get("report_data")
+    all_notes_text = request.get("all_notes_text", "")
 
     if not report_type or not report_data:
-        raise HTTPException(status_code=400, detail="report_type and report_data required")
+        raise HTTPException(
+            status_code=400, detail="report_type and report_data required"
+        )
 
     database.save_analysis_report(user_id, report_type, report_data, all_notes_text)
     return {"success": True}
 
+
 @app.get("/api/default-voices")
 def get_default_voices():
     """Get default voice configurations"""
     return config.VOICE_ARCHETYPES
 
+
 @app.post("/api/admin/trigger-timeline-generation")
-async def trigger_timeline_generation(date: str = None, timezone: str = 'Asia/Shanghai'):
+async def trigger_timeline_generation(
+    date: str = None, timezone: str = "Asia/Shanghai"
+):
     """
     Manually trigger timeline image generation for a specific date (testing/admin).
 
@@ -1329,25 +1450,20 @@ async def trigger_timeline_generation(date: str = None, timezone: str = 'Asia/Sh
     print(f"üîß Manual trigger: Generating timeline images for {date}")
 
     try:
-        result = await timeline_scheduler.generate_timeline_images_for_date(date, timezone)
-        return {
-            "success": True,
-            "date": date,
-            "timezone": timezone,
-            **result
-        }
+        result = await timeline_scheduler.generate_timeline_images_for_date(
+            date, timezone
+        )
+        return {"success": True, "date": date, "timezone": timezone, **result}
     except Exception as e:
         import traceback
+
         traceback.print_exc()
-        return {
-            "success": False,
-            "error": str(e),
-            "date": date,
-            "timezone": timezone
-        }
+        return {"success": False, "error": str(e), "date": date, "timezone": timezone}
+
 
 # ========== Deck & Voice Management ==========
 
+
 class DeckCreateRequest(BaseModel):
     name: str
     description: str = None
@@ -1358,6 +1474,7 @@ class DeckCreateRequest(BaseModel):
     icon: str = None
     color: str = None
 
+
 class DeckUpdateRequest(BaseModel):
     name: str = None
     description: str = None
@@ -1370,6 +1487,7 @@ class DeckUpdateRequest(BaseModel):
     enabled: bool = None
     order_index: int = None
 
+
 class VoiceCreateRequest(BaseModel):
     deck_id: str
     name: str
@@ -1379,6 +1497,7 @@ class VoiceCreateRequest(BaseModel):
     icon: str = None
     color: str = None
 
+
 class VoiceUpdateRequest(BaseModel):
     name: str = None
     system_prompt: str = None
@@ -1389,17 +1508,22 @@ class VoiceUpdateRequest(BaseModel):
     enabled: bool = None
     order_index: int = None
 
+
 class VoiceForkRequest(BaseModel):
     target_deck_id: str
 
+
 # ========== Friend System Models ==========
 
+
 class UseInviteCodeRequest(BaseModel):
     code: str
 
+
 class FriendRequestActionRequest(BaseModel):
     pass  # No body needed, just request_id in URL
 
+
 @app.get("/api/decks")
 def list_decks(published: bool = False, current_user: dict = Depends(get_current_user)):
     """Get decks - either user's own or published community decks"""
@@ -1408,23 +1532,27 @@ def list_decks(published: bool = False, current_user: dict = Depends(get_current
         decks = database.get_published_decks()
     else:
         # Get user's own decks
-        user_id = current_user['user_id']
+        user_id = current_user["user_id"]
         decks = database.get_user_decks(user_id)
     return {"decks": decks}
 
+
 @app.get("/api/decks/{deck_id}")
 def get_deck(deck_id: str, current_user: dict = Depends(get_current_user)):
     """Get deck with all voices"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     deck = database.get_deck_with_voices(user_id, deck_id)
     if not deck:
         raise HTTPException(status_code=404, detail="Deck not found")
     return deck
 
+
 @app.post("/api/decks")
-def create_deck(request: DeckCreateRequest, current_user: dict = Depends(get_current_user)):
+def create_deck(
+    request: DeckCreateRequest, current_user: dict = Depends(get_current_user)
+):
     """Create a new user deck"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     deck_id = database.create_deck(
         user_id,
         name=request.name,
@@ -1434,36 +1562,47 @@ def create_deck(request: DeckCreateRequest, current_user: dict = Depends(get_cur
         description_zh=request.description_zh,
         description_en=request.description_en,
         icon=request.icon,
-        color=request.color
+        color=request.color,
     )
     return {"deck_id": deck_id}
 
+
 @app.put("/api/decks/{deck_id}")
-def update_deck(deck_id: str, request: DeckUpdateRequest, current_user: dict = Depends(get_current_user)):
+def update_deck(
+    deck_id: str,
+    request: DeckUpdateRequest,
+    current_user: dict = Depends(get_current_user),
+):
     """Update a user deck"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
 
     # Convert request to dict, exclude None values
     updates = {k: v for k, v in request.dict().items() if v is not None}
 
     success = database.update_deck(user_id, deck_id, updates)
     if not success:
-        raise HTTPException(status_code=404, detail="Deck not found or permission denied")
+        raise HTTPException(
+            status_code=404, detail="Deck not found or permission denied"
+        )
     return {"success": True}
 
+
 @app.delete("/api/decks/{deck_id}")
 def delete_deck(deck_id: str, current_user: dict = Depends(get_current_user)):
     """Delete a user deck (cascades to voices)"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     success = database.delete_deck(user_id, deck_id)
     if not success:
-        raise HTTPException(status_code=404, detail="Deck not found or permission denied")
+        raise HTTPException(
+            status_code=404, detail="Deck not found or permission denied"
+        )
     return {"success": True}
 
+
 @app.post("/api/decks/{deck_id}/fork")
 def fork_deck(deck_id: str, current_user: dict = Depends(get_current_user)):
     """Fork a deck (system or published community deck) to create user's own copy"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     try:
         new_deck_id = database.fork_deck(user_id, deck_id)
         # @@@ Increment install count if forking from published deck
@@ -1472,21 +1611,24 @@ def fork_deck(deck_id: str, current_user: dict = Depends(get_current_user)):
     except ValueError as e:
         raise HTTPException(status_code=404, detail=str(e))
 
+
 @app.post("/api/decks/{deck_id}/publish")
 def publish_deck(deck_id: str, current_user: dict = Depends(get_current_user)):
     """
     Publish/unpublish a deck to community store.
     @@@ Warning: Publishing breaks parent_id chain (deck becomes standalone)
     """
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     try:
         # Check if deck is currently published
         deck = database.get_deck_with_voices(user_id, deck_id)
         if not deck:
-            raise HTTPException(status_code=404, detail="Deck not found or not owned by user")
+            raise HTTPException(
+                status_code=404, detail="Deck not found or not owned by user"
+            )
 
         # Toggle published status
-        if deck.get('published'):
+        if deck.get("published"):
             database.unpublish_deck(deck_id, user_id)
             return {"success": True, "published": False}
         else:
@@ -1495,20 +1637,24 @@ def publish_deck(deck_id: str, current_user: dict = Depends(get_current_user)):
     except Exception as e:
         raise HTTPException(status_code=500, detail=str(e))
 
+
 @app.post("/api/decks/{deck_id}/sync")
 def sync_deck(deck_id: str, current_user: dict = Depends(get_current_user)):
     """Sync user's forked deck with parent template (force overwrites local changes)"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     try:
         result = database.sync_deck_with_parent(user_id, deck_id, force=True)
         return result
     except ValueError as e:
         raise HTTPException(status_code=400, detail=str(e))
 
+
 @app.post("/api/voices")
-def create_voice(request: VoiceCreateRequest, current_user: dict = Depends(get_current_user)):
+def create_voice(
+    request: VoiceCreateRequest, current_user: dict = Depends(get_current_user)
+):
     """Create a new voice in a user deck"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     try:
         voice_id = database.create_voice(
             user_id,
@@ -1518,107 +1664,139 @@ def create_voice(request: VoiceCreateRequest, current_user: dict = Depends(get_c
             name_zh=request.name_zh,
             name_en=request.name_en,
             icon=request.icon,
-            color=request.color
+            color=request.color,
         )
         return {"voice_id": voice_id}
     except ValueError as e:
         raise HTTPException(status_code=400, detail=str(e))
 
+
 @app.put("/api/voices/{voice_id}")
-def update_voice(voice_id: str, request: VoiceUpdateRequest, current_user: dict = Depends(get_current_user)):
+def update_voice(
+    voice_id: str,
+    request: VoiceUpdateRequest,
+    current_user: dict = Depends(get_current_user),
+):
     """Update a user voice"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
 
     # Convert request to dict, exclude None values
     updates = {k: v for k, v in request.dict().items() if v is not None}
 
     success = database.update_voice(user_id, voice_id, updates)
     if not success:
-        raise HTTPException(status_code=404, detail="Voice not found or permission denied")
+        raise HTTPException(
+            status_code=404, detail="Voice not found or permission denied"
+        )
     return {"success": True}
 
+
 @app.delete("/api/voices/{voice_id}")
 def delete_voice(voice_id: str, current_user: dict = Depends(get_current_user)):
     """Delete a user voice"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     success = database.delete_voice(user_id, voice_id)
     if not success:
-        raise HTTPException(status_code=404, detail="Voice not found or permission denied")
+        raise HTTPException(
+            status_code=404, detail="Voice not found or permission denied"
+        )
     return {"success": True}
 
+
 @app.post("/api/voices/{voice_id}/fork")
-def fork_voice(voice_id: str, request: VoiceForkRequest, current_user: dict = Depends(get_current_user)):
+def fork_voice(
+    voice_id: str,
+    request: VoiceForkRequest,
+    current_user: dict = Depends(get_current_user),
+):
     """Fork a voice to a user deck"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     try:
         new_voice_id = database.fork_voice(user_id, voice_id, request.target_deck_id)
         return {"voice_id": new_voice_id}
     except ValueError as e:
         raise HTTPException(status_code=400, detail=str(e))
 
+
 # ========== Friend System Endpoints ==========
 
+
 @app.post("/api/friends/invite/generate")
 def generate_friend_invite(current_user: dict = Depends(get_current_user)):
     """Generate a new friend invite code (6 chars, 7 days validity)"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     result = database.generate_invite_code(user_id)
     return result
 
+
 @app.post("/api/friends/invite/use")
-def use_friend_invite(request: UseInviteCodeRequest, current_user: dict = Depends(get_current_user)):
+def use_friend_invite(
+    request: UseInviteCodeRequest, current_user: dict = Depends(get_current_user)
+):
     """Use an invite code to send a friend request"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     result = database.use_invite_code(request.code, user_id)
-    if not result.get('success'):
-        raise HTTPException(status_code=400, detail=result.get('error'))
+    if not result.get("success"):
+        raise HTTPException(status_code=400, detail=result.get("error"))
     return result
 
+
 @app.get("/api/friends/requests")
 def get_friend_requests(current_user: dict = Depends(get_current_user)):
     """Get all pending friend requests for current user"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     requests = database.get_friend_requests(user_id)
     return {"requests": requests}
 
+
 @app.post("/api/friends/requests/{request_id}/accept")
-def accept_friend_request(request_id: int, current_user: dict = Depends(get_current_user)):
+def accept_friend_request(
+    request_id: int, current_user: dict = Depends(get_current_user)
+):
     """Accept a friend request"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     result = database.accept_friend_request(request_id, user_id)
-    if not result.get('success'):
-        raise HTTPException(status_code=400, detail=result.get('error'))
+    if not result.get("success"):
+        raise HTTPException(status_code=400, detail=result.get("error"))
     return result
 
+
 @app.post("/api/friends/requests/{request_id}/reject")
-def reject_friend_request(request_id: int, current_user: dict = Depends(get_current_user)):
+def reject_friend_request(
+    request_id: int, current_user: dict = Depends(get_current_user)
+):
     """Reject a friend request"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     result = database.reject_friend_request(request_id, user_id)
-    if not result.get('success'):
-        raise HTTPException(status_code=400, detail=result.get('error'))
+    if not result.get("success"):
+        raise HTTPException(status_code=400, detail=result.get("error"))
     return result
 
+
 @app.get("/api/friends")
 def get_friends(current_user: dict = Depends(get_current_user)):
     """Get all accepted friends for current user"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     friends = database.get_friends(user_id)
     return {"friends": friends}
 
+
 @app.delete("/api/friends/{friend_id}")
 def remove_friend(friend_id: int, current_user: dict = Depends(get_current_user)):
     """Remove a friend"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     result = database.remove_friend(user_id, friend_id)
-    if not result.get('success'):
-        raise HTTPException(status_code=400, detail=result.get('error'))
+    if not result.get("success"):
+        raise HTTPException(status_code=400, detail=result.get("error"))
     return result
 
+
 @app.get("/api/friends/{friend_id}/timeline")
-def get_friend_timeline(friend_id: int, limit: int = 30, current_user: dict = Depends(get_current_user)):
+def get_friend_timeline(
+    friend_id: int, limit: int = 30, current_user: dict = Depends(get_current_user)
+):
     """Get a friend's timeline pictures (only if friends)"""
-    user_id = current_user['user_id']
+    user_id = current_user["user_id"]
     timeline = database.get_friend_timeline(user_id, friend_id, limit)
     if timeline is None:
         raise HTTPException(status_code=403, detail="Not friends or friend not found")
@@ -1630,7 +1808,6 @@ async def speech_recognition(websocket: WebSocket):
     await websocket.accept()
     await init_speech_recognition(websocket)
 
-
 # @@@ Removed /api/analyze wrapper - frontend now calls /polycli/api/trigger-sync directly
 
 # @@@ Removed /api/chat wrapper - frontend now calls /polycli/api/trigger-sync directly
@@ -1644,16 +1821,18 @@ async def speech_recognition(websocket: WebSocket):
 
 registry = get_registry()
 # @@@ Pass auth_callback to enable authentication for /polycli/api/trigger-sync
-mount_control_panel(app, registry, prefix="/polycli", auth_callback=auth.verify_access_token)
+mount_control_panel(
+    app, registry, prefix="/polycli", auth_callback=auth.verify_access_token
+)
 
 # ========== Main ==========
 
 if __name__ == "__main__":
     import uvicorn
 
-    print("\n" + "="*60)
+    print("\n" + "=" * 60)
     print("üé≠ Ink & Memory FastAPI Server")
-    print("="*60)
+    print("=" * 60)
     print("\nüìö API Endpoints:")
     print("  Auth & User:")
     print("    POST /api/register        - Register new user")
@@ -1703,6 +1882,6 @@ if __name__ == "__main__":
     print("                 generate_daily_picture")
     print("\n  Documentation:")
     print("    /docs                     - Auto-generated API docs")
-    print("="*60 + "\n")
+    print("=" * 60 + "\n")
 
     uvicorn.run(app, host="127.0.0.1", port=8765)
