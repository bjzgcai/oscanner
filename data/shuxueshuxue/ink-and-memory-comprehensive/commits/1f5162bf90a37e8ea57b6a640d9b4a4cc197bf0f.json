{
  "sha": "1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f",
  "node_id": "C_kwDOP2Zrm9oAKDFmNTE2MmJmOTBhMzdlOGVhNTdiNmE2NDBkOWI0YTRjYzE5N2JmMGY",
  "commit": {
    "author": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-12-10T06:23:49Z"
    },
    "committer": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-12-10T06:23:49Z"
    },
    "message": "timeline dynamic loading",
    "tree": {
      "sha": "fec461820f63350ca73c407f768fd9b8b8d8bf2a",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/trees/fec461820f63350ca73c407f768fd9b8b8d8bf2a"
    },
    "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/commits/1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f",
  "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f",
  "comments_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "459d3941359e1e2a8ff26e0828b33e3dd386c0aa",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/459d3941359e1e2a8ff26e0828b33e3dd386c0aa",
      "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/459d3941359e1e2a8ff26e0828b33e3dd386c0aa"
    }
  ],
  "stats": {
    "total": 651,
    "additions": 452,
    "deletions": 199
  },
  "files": [
    {
      "sha": "da0898fd8534855807a3e65ff2ba006ff983101f",
      "filename": "backend/database.py",
      "status": "modified",
      "additions": 68,
      "deletions": 0,
      "changes": 68,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f/backend%2Fdatabase.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f/backend%2Fdatabase.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fdatabase.py?ref=1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f",
      "patch": "@@ -1141,6 +1141,49 @@ def list_sessions(user_id: int):\n     finally:\n         db.close()\n \n+def list_sessions_in_range(user_id: int, start_date: Optional[str], end_date: Optional[str]):\n+    \"\"\"\n+    List sessions within an optional date range (UTC timestamps stored in DB).\n+    Dates are strings YYYY-MM-DD and compared against created_at/updated_at dates.\n+    \"\"\"\n+    db = get_db()\n+    try:\n+        rows = db.execute(f\"\"\"\n+        SELECT id, name, editor_state_json, created_at, updated_at\n+        FROM user_sessions\n+        WHERE user_id = ?\n+          AND (? IS NULL OR date(COALESCE(created_at, updated_at)) >= ?)\n+          AND (? IS NULL OR date(COALESCE(created_at, updated_at)) <= ?)\n+        ORDER BY updated_at DESC\n+        \"\"\", (user_id, start_date, start_date, end_date, end_date)).fetchall()\n+\n+        results = []\n+        for row in rows:\n+            first_line = \"\"\n+            try:\n+                state = json.loads(row[\"editor_state_json\"])\n+                first_text = next(\n+                    (c.get(\"content\", \"\").strip() for c in state.get(\"cells\", []) if c.get(\"type\") == \"text\" and c.get(\"content\")),\n+                    \"\"\n+                )\n+                if first_text:\n+                    first_line = first_text.split(\"\\n\")[0][:30]\n+            except Exception:\n+                first_line = \"\"\n+\n+            results.append(\n+                {\n+                    \"id\": row[\"id\"],\n+                    \"name\": row[\"name\"],\n+                    \"created_at\": row[\"created_at\"],\n+                    \"updated_at\": row[\"updated_at\"],\n+                    \"first_line\": first_line,\n+                }\n+            )\n+        return results\n+    finally:\n+        db.close()\n+\n def get_all_sessions_with_text(user_id: int) -> list[dict]:\n     \"\"\"\n     Get all sessions for a user with text extracted from text cells.\n@@ -1890,6 +1933,31 @@ def get_friend_timeline(user_id: int, friend_id: int, limit: int = 30) -> list:\n     finally:\n         db.close()\n \n+def get_daily_pictures_range(user_id: int, start_date: Optional[str], end_date: Optional[str], limit: int = 30) -> list[dict]:\n+    \"\"\"\n+    Get daily pictures within a date range (thumbnails preferred). Limits results.\n+    \"\"\"\n+    db = get_db()\n+    try:\n+        rows = db.execute(\"\"\"\n+        SELECT date, COALESCE(thumbnail_base64, image_base64) as base64, prompt, created_at\n+        FROM daily_pictures\n+        WHERE user_id = ?\n+          AND (? IS NULL OR date(date) >= ?)\n+          AND (? IS NULL OR date(date) <= ?)\n+        ORDER BY date DESC\n+        LIMIT ?\n+        \"\"\", (user_id, start_date, start_date, end_date, end_date, limit)).fetchall()\n+\n+        return [{\n+            \"date\": row['date'],\n+            \"base64\": row['base64'],\n+            \"prompt\": row['prompt'],\n+            \"created_at\": row['created_at']\n+        } for row in rows]\n+    finally:\n+        db.close()\n+\n if __name__ == \"__main__\":\n     # Initialize database\n     init_db()"
    },
    {
      "sha": "299d7c7e104c552febc241c773434b30efd92c87",
      "filename": "backend/server.py",
      "status": "modified",
      "additions": 49,
      "deletions": 1,
      "changes": 50,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f/backend%2Fserver.py",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f/backend%2Fserver.py",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/backend%2Fserver.py?ref=1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f",
      "patch": "@@ -1279,14 +1279,46 @@ def list_sessions(timezone: str = \"Asia/Shanghai\", current_user: dict = Depends(\n     List all sessions for current user.\n     Returns: Array of session metadata (without full editor state) plus local day key + first line.\n     \"\"\"\n+    return list_sessions_with_range(None, None, timezone, current_user)\n+\n+def _validate_date_str(value: Optional[str]) -> Optional[str]:\n+    if value is None:\n+        return None\n+    value = value.strip()\n+    if not value:\n+        return None\n+    try:\n+        datetime.fromisoformat(value)\n+    except Exception:\n+        raise HTTPException(status_code=400, detail=\"Invalid date format, expected YYYY-MM-DD\")\n+    if len(value) != 10:\n+        raise HTTPException(status_code=400, detail=\"Invalid date format, expected YYYY-MM-DD\")\n+    return value\n+\n+@app.get(\"/api/sessions/range\")\n+def list_sessions_with_range(\n+    start_date: Optional[str] = None,\n+    end_date: Optional[str] = None,\n+    timezone: str = \"Asia/Shanghai\",\n+    current_user: dict = Depends(get_current_user)\n+):\n+    \"\"\"\n+    List sessions within an optional date range.\n+    \"\"\"\n     user_id = current_user[\"user_id\"]\n+    start_date = _validate_date_str(start_date)\n+    end_date = _validate_date_str(end_date)\n     try:\n         from zoneinfo import ZoneInfo\n         tz = ZoneInfo(timezone)\n     except Exception:\n         raise HTTPException(status_code=400, detail=\"Invalid timezone\")\n \n-    sessions = database.list_sessions(user_id)\n+    if start_date or end_date:\n+        sessions = database.list_sessions_in_range(user_id, start_date, end_date)\n+    else:\n+        sessions = database.list_sessions(user_id)\n+\n     enriched = []\n     for s in sessions:\n         dt = _clean_timestamp(s.get(\"created_at\") or s.get(\"updated_at\"))\n@@ -1416,6 +1448,22 @@ def get_pictures(limit: int = 30, current_user: dict = Depends(get_current_user)\n     pictures = database.get_daily_pictures(user_id, limit)\n     return {\"pictures\": pictures}\n \n+@app.get(\"/api/pictures/range\")\n+def get_pictures_range(\n+    start_date: Optional[str] = None,\n+    end_date: Optional[str] = None,\n+    limit: int = 30,\n+    current_user: dict = Depends(get_current_user)\n+):\n+    \"\"\"\n+    Get daily pictures within an optional date range.\n+    \"\"\"\n+    user_id = current_user[\"user_id\"]\n+    start_date = _validate_date_str(start_date)\n+    end_date = _validate_date_str(end_date)\n+    pictures = database.get_daily_pictures_range(user_id, start_date, end_date, limit)\n+    return {\"pictures\": pictures}\n+\n \n @app.get(\"/api/pictures/{date}/full\")\n def get_picture_full(date: str, current_user: dict = Depends(get_current_user)):"
    },
    {
      "sha": "0ac62b07f05b37fdd7a38607365900dfcf843afa",
      "filename": "frontend/src/api/voiceApi.ts",
      "status": "modified",
      "additions": 31,
      "deletions": 9,
      "changes": 40,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f/frontend%2Fsrc%2Fapi%2FvoiceApi.ts",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f/frontend%2Fsrc%2Fapi%2FvoiceApi.ts",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fapi%2FvoiceApi.ts?ref=1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f",
      "patch": "@@ -389,15 +389,24 @@ export async function saveSession(sessionId: string, editorState: any, name?: st\n   }\n }\n \n+type SessionRangeOptions = {\n+  startDate?: string;\n+  endDate?: string;\n+  limit?: number;\n+};\n+\n /**\n- * List all sessions (metadata only). If timezone is provided, the backend will include a local-day key.\n+ * List sessions metadata, optionally scoped to a date range.\n  */\n-export async function listSessions(timezone?: string): Promise<any[]> {\n-  const url = timezone\n-    ? `${API_BASE}/api/sessions?timezone=${encodeURIComponent(timezone)}`\n-    : `${API_BASE}/api/sessions`;\n-\n-  const response = await fetch(url, {\n+export async function listSessions(timezone?: string, options: SessionRangeOptions = {}): Promise<any[]> {\n+  const params = new URLSearchParams();\n+  if (timezone) params.append('timezone', timezone);\n+  if (options.startDate) params.append('start_date', options.startDate);\n+  if (options.endDate) params.append('end_date', options.endDate);\n+  const endpoint = options.startDate || options.endDate ? '/api/sessions/range' : '/api/sessions';\n+  const query = params.toString();\n+\n+  const response = await fetch(`${API_BASE}${endpoint}${query ? `?${query}` : ''}`, {\n     headers: getAuthHeaders()\n   });\n \n@@ -503,8 +512,21 @@ export async function saveDailyPicture(date: string, imageBase64: string, prompt\n /**\n  * Get daily pictures (thumbnails only for fast timeline loading)\n  */\n-export async function getDailyPictures(limit: number = 30): Promise<any[]> {\n-  const response = await fetch(`${API_BASE}/api/pictures?limit=${limit}`, {\n+type PictureRangeOptions = {\n+  startDate?: string;\n+  endDate?: string;\n+  limit?: number;\n+};\n+\n+export async function getDailyPictures(limit: number = 30, options: PictureRangeOptions = {}): Promise<any[]> {\n+  const params = new URLSearchParams();\n+  params.append('limit', String(options.limit ?? limit));\n+  if (options.startDate) params.append('start_date', options.startDate);\n+  if (options.endDate) params.append('end_date', options.endDate);\n+  const endpoint = options.startDate || options.endDate ? '/api/pictures/range' : '/api/pictures';\n+  const query = params.toString();\n+\n+  const response = await fetch(`${API_BASE}${endpoint}${query ? `?${query}` : ''}`, {\n     headers: getAuthHeaders()\n   });\n "
    },
    {
      "sha": "bb520cd0dc86d6b10146296976a88cb3715755c3",
      "filename": "frontend/src/components/CollectionsView.tsx",
      "status": "modified",
      "additions": 304,
      "deletions": 189,
      "changes": 493,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx?ref=1f5162bf90a37e8ea57b6a640d9b4a4cc197bf0f",
      "patch": "@@ -1,4 +1,4 @@\n-import { useState, useEffect, useLayoutEffect, useRef, useMemo } from 'react';\n+import { useState, useEffect, useLayoutEffect, useRef, useMemo, useCallback } from 'react';\n import { useTranslation } from 'react-i18next';\n import type { Commentor } from '../engine/EditorEngine';\n import { findNormalizedPhrase } from '../utils/textNormalize';\n@@ -130,45 +130,41 @@ function formatDate(date: Date | string, locale: string): string {\n   });\n }\n \n-// @@@ Generate timeline days (7 past + today + 7 future)\n-function generateTimelineDays(): TimelineDay[] {\n-  const today = new Date();\n-  const todayStr = getLocalDateString(today);\n-  const allTimelineDays: TimelineDay[] = [];\n-\n-  for (let i = 10; i >= 1; i--) {\n-    const pastDate = new Date(today);\n-    pastDate.setDate(today.getDate() - i);\n-    allTimelineDays.push({\n-      date: getLocalDateString(pastDate),\n-      isPast: true,\n-      isFuture: false,\n-      isToday: false,\n-      daysOffset: -i\n-    });\n-  }\n+// @@@ Date helpers for dynamic timeline\n+function startOfDay(date: Date): Date {\n+  const d = new Date(date);\n+  d.setHours(0, 0, 0, 0);\n+  return d;\n+}\n \n-  allTimelineDays.push({\n-    date: todayStr,\n-    isPast: false,\n-    isFuture: false,\n-    isToday: true,\n-    daysOffset: 0\n-  });\n+function addDays(date: Date, delta: number): Date {\n+  const d = new Date(date);\n+  d.setDate(d.getDate() + delta);\n+  return d;\n+}\n \n-  for (let i = 1; i <= 10; i++) {\n-    const futureDate = new Date(today);\n-    futureDate.setDate(today.getDate() + i);\n-    allTimelineDays.push({\n-      date: getLocalDateString(futureDate),\n-      isPast: false,\n-      isFuture: true,\n-      isToday: false,\n-      daysOffset: i\n-    });\n-  }\n+function makeTimelineDay(date: Date): TimelineDay {\n+  const today = startOfDay(new Date());\n+  const day = startOfDay(date);\n+  const diff = Math.round((day.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));\n+  return {\n+    date: getLocalDateString(day),\n+    isPast: diff < 0,\n+    isFuture: diff > 0,\n+    isToday: diff === 0,\n+    daysOffset: diff\n+  };\n+}\n \n-  return allTimelineDays;\n+function buildDayRange(startDate: Date, endDate: Date): TimelineDay[] {\n+  const days: TimelineDay[] = [];\n+  const cursor = startOfDay(startDate);\n+  const end = startOfDay(endDate);\n+  while (cursor.getTime() <= end.getTime()) {\n+    days.push(makeTimelineDay(cursor));\n+    cursor.setDate(cursor.getDate() + 1);\n+  }\n+  return days;\n }\n \n // @@@ Extract and truncate beginning of text for timeline preview\n@@ -196,6 +192,14 @@ function getTextPreview(text: string, maxLength: number = 60): string {\n // @@@ Card height for overlap calculation\n const CARD_HEIGHT = 100;\n const CARD_OVERLAP = 30; // 30% overlap for zigzag effect\n+const SLOT_HEIGHT = CARD_HEIGHT - CARD_OVERLAP;\n+const INITIAL_PAST_DAYS = 10;\n+const INITIAL_FUTURE_DAYS = 10;\n+const CHUNK_SIZE = 14;\n+const MAX_PAST_DAYS = 365;\n+const MAX_FUTURE_DAYS = 365;\n+const LOAD_THRESHOLD_PX = 200;\n+const VIRTUAL_BUFFER = 5;\n \n interface TimelineCardProps {\n   day: TimelineDay;\n@@ -396,107 +400,121 @@ interface TimelinePageProps {\n function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: TimelinePageProps) {\n   const { t } = useTranslation();\n   const { isAuthenticated } = useAuth();\n-  const [starredComments, setStarredComments] = useState<Commentor[]>([]);\n+  const [days, setDays] = useState<TimelineDay[]>([]);\n+  const [sessionSummaries, setSessionSummaries] = useState<Map<string, SessionSummary>>(new Map());\n+  const [datesWithSessions, setDatesWithSessions] = useState<Set<string>>(new Set());\n   const [allCommentsByDate, setAllCommentsByDate] = useState<Map<string, Commentor[]>>(new Map());\n   const [textByDate, setTextByDate] = useState<Map<string, string>>(new Map());\n   const [firstLineByDate, setFirstLineByDate] = useState<Map<string, string>>(new Map());\n-  const [pictures, setPictures] = useState<TimelinePicture[]>([]);\n-  const [sessionSummaries, setSessionSummaries] = useState<SessionSummary[]>([]);\n-  const [datesWithSessions, setDatesWithSessions] = useState<Set<string>>(new Set());\n+  const [picturesByDate, setPicturesByDate] = useState<Map<string, TimelinePicture>>(new Map());\n   const [generatingForDate, setGeneratingForDate] = useState<string | null>(null);\n   const [viewingImage, setViewingImage] = useState<{ base64: string; full_base64?: string; prompt: string; date: string; } | null>(null);\n   const [initialLoading, setInitialLoading] = useState(true);\n   const [loadingCommentsForDate, setLoadingCommentsForDate] = useState<string | null>(null);\n+  const [loadingPast, setLoadingPast] = useState(false);\n+  const [loadingFuture, setLoadingFuture] = useState(false);\n+  const [hasMorePast, setHasMorePast] = useState(true);\n+  const [hasMoreFuture, setHasMoreFuture] = useState(true);\n+  const [scrollTopValue, setScrollTopValue] = useState(0);\n+  const [viewportHeight, setViewportHeight] = useState(0);\n+  const [pendingInitialScroll, setPendingInitialScroll] = useState(true);\n   const scrollContainerRef = useRef<HTMLDivElement | null>(null);\n-  const allTimelineDays = useMemo(() => generateTimelineDays(), []);\n+  const loadedRangesRef = useRef<Set<string>>(new Set());\n \n-  useEffect(() => {\n-    let cancelled = false;\n-\n-    const loadTimelineData = async () => {\n-      setInitialLoading(true);\n-      setStarredComments([]);\n-      setAllCommentsByDate(new Map());\n-      setTextByDate(new Map());\n-      setFirstLineByDate(new Map());\n-      setDatesWithSessions(new Set());\n-      setPictures([]);\n+  const mergeSessions = useCallback((sessions: SessionSummary[]) => {\n+    setSessionSummaries(prev => {\n+      const next = new Map(prev);\n+      sessions.forEach((s) => next.set(s.id, s));\n+      return next;\n+    });\n+    setDatesWithSessions(prev => {\n+      const next = new Set(prev);\n+      sessions.forEach(s => {\n+        if (s.date_key) next.add(s.date_key);\n+      });\n+      return next;\n+    });\n+    setFirstLineByDate(prev => {\n+      const next = new Map(prev);\n+      sessions.forEach(s => {\n+        if (s.date_key && (s.first_line || s.name) && !next.has(s.date_key)) {\n+          next.set(s.date_key, s.first_line || s.name || 'Untitled');\n+        }\n+      });\n+      return next;\n+    });\n+  }, []);\n+\n+  const mergePictures = useCallback((pictures: any[]) => {\n+    setPicturesByDate(prev => {\n+      const next = new Map(prev);\n+      pictures.forEach((p: any) => {\n+        next.set(p.date, {\n+          date: p.date,\n+          base64: p.base64,\n+          prompt: p.prompt || ''\n+        });\n+      });\n+      return next;\n+    });\n+  }, []);\n \n-      if (isAuthenticated) {\n-        try {\n-          const { listSessions, getDailyPictures } = await import('../api/voiceApi');\n-          const sessions: SessionSummary[] = await listSessions(timezone);\n-          if (cancelled) return;\n-\n-          setSessionSummaries(sessions);\n-\n-          const firstLineMap = new Map<string, string>();\n-          const dates = new Set<string>();\n-          sessions.forEach((session) => {\n-            const dateKey = session.date_key;\n-            if (dateKey) {\n-              dates.add(dateKey);\n-              if (!firstLineMap.has(dateKey)) {\n-                const line = session.first_line || session.name || 'Untitled';\n-                firstLineMap.set(dateKey, line);\n-              }\n-            }\n-          });\n+  const loadRange = useCallback(async (rangeStart: Date, rangeEnd: Date) => {\n+    if (!isAuthenticated) return;\n+    const startKey = getLocalDateString(rangeStart);\n+    const endKey = getLocalDateString(rangeEnd);\n+    const cacheKey = `${startKey}|${endKey}|${timezone}`;\n+    if (loadedRangesRef.current.has(cacheKey)) return;\n+    loadedRangesRef.current.add(cacheKey);\n \n-          if (!cancelled) {\n-            setFirstLineByDate(firstLineMap);\n-            setDatesWithSessions(dates);\n-          }\n+    try {\n+      const { listSessions, getDailyPictures } = await import('../api/voiceApi');\n+      const [sessions, pictures] = await Promise.all([\n+        listSessions(timezone, { startDate: startKey, endDate: endKey }),\n+        getDailyPictures(CHUNK_SIZE * 2, { startDate: startKey, endDate: endKey })\n+      ]);\n+      mergeSessions(sessions);\n+      mergePictures(pictures);\n+    } catch (error) {\n+      loadedRangesRef.current.delete(cacheKey);\n+      console.error('Failed to load range:', error);\n+    }\n+  }, [isAuthenticated, mergePictures, mergeSessions, timezone]);\n \n-          try {\n-            const dbPictures = await getDailyPictures(30);\n-            if (!cancelled) {\n-              const formattedPictures = dbPictures.map((p: any) => ({\n-                date: p.date,\n-                base64: p.base64,\n-                prompt: p.prompt || ''\n-              }));\n-              setPictures(formattedPictures);\n-            }\n-          } catch (error) {\n-            console.error('Failed to load pictures from database:', error);\n-            if (!cancelled) {\n-              const savedPictures = localStorage.getItem(STORAGE_KEYS.DAILY_PICTURES);\n-              if (savedPictures) {\n-                try {\n-                  const parsed = JSON.parse(savedPictures);\n-                  const thumbnailsOnly = parsed.map((p: any) => ({\n-                    date: p.date,\n-                    base64: p.base64,\n-                    prompt: p.prompt\n-                  }));\n-                  setPictures(thumbnailsOnly);\n-                } catch (e) {\n-                  console.error('Failed to load pictures:', e);\n-                }\n-              }\n-            }\n-          }\n-        } catch (error) {\n-          console.error('Failed to load timeline data:', error);\n-          setSessionSummaries([]);\n-        }\n+  useEffect(() => {\n+    let cancelled = false;\n+    const today = new Date();\n+    const start = addDays(today, -INITIAL_PAST_DAYS);\n+    const end = addDays(today, INITIAL_FUTURE_DAYS);\n+\n+    setInitialLoading(true);\n+    setLoadingPast(false);\n+    setLoadingFuture(false);\n+    setHasMorePast(true);\n+    setHasMoreFuture(true);\n+    setPendingInitialScroll(true);\n+    setDays(buildDayRange(start, end));\n+    setSessionSummaries(new Map());\n+    setDatesWithSessions(new Set());\n+    setAllCommentsByDate(new Map());\n+    setTextByDate(new Map());\n+    setFirstLineByDate(new Map());\n+    setPicturesByDate(new Map());\n+    loadedRangesRef.current.clear();\n+\n+    const run = async () => {\n+      if (isAuthenticated) {\n+        await loadRange(start, end);\n       } else {\n-        setSessionSummaries([]);\n         const savedState = localStorage.getItem(STORAGE_KEYS.EDITOR_STATE);\n         if (savedState) {\n           try {\n             const state = JSON.parse(savedState);\n-            const starred = state.commentors?.filter((c: Commentor) => c.feedback === 'star') || [];\n-            setStarredComments(starred);\n-\n-            const today = formatDate(new Date(), dateLocale);\n-            const allComments = state.commentors?.filter((c: Commentor) => c.appliedAt) || [];\n-            const commentsByDate = new Map<string, Commentor[]>();\n-            if (allComments.length > 0) {\n-              commentsByDate.set(today, allComments);\n+            const todayKey = formatDate(new Date(), dateLocale);\n+            const comments = state.commentors?.filter((c: Commentor) => c.appliedAt) || [];\n+            if (comments.length > 0) {\n+              setAllCommentsByDate(new Map([[todayKey, comments]]));\n             }\n-            setAllCommentsByDate(commentsByDate);\n \n             const guestTextMap = new Map<string, string>();\n             const guestFirstLineMap = new Map<string, string>();\n@@ -510,31 +528,24 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n \n               if (combined) {\n                 guestTextMap.set(dateKey, combined);\n+                guestFirstLineMap.set(dateKey, extractFirstLine(state));\n               }\n-              guestFirstLineMap.set(dateKey, extractFirstLine(state));\n             }\n             setTextByDate(guestTextMap);\n             setFirstLineByDate(guestFirstLineMap);\n-          } catch (e) {\n-            console.error('Failed to load comments:', e);\n+            setDatesWithSessions(new Set(Array.from(guestTextMap.keys())));\n+          } catch (error) {\n+            console.error('Failed to load guest state:', error);\n           }\n-        } else {\n-          setTextByDate(new Map());\n-          setFirstLineByDate(new Map());\n         }\n \n         const savedPictures = localStorage.getItem(STORAGE_KEYS.DAILY_PICTURES);\n         if (savedPictures) {\n           try {\n             const parsed = JSON.parse(savedPictures);\n-            const thumbnailsOnly = parsed.map((p: any) => ({\n-              date: p.date,\n-              base64: p.base64,\n-              prompt: p.prompt\n-            }));\n-            setPictures(thumbnailsOnly);\n-          } catch (e) {\n-            console.error('Failed to load pictures:', e);\n+            mergePictures(parsed);\n+          } catch (error) {\n+            console.error('Failed to load pictures:', error);\n           }\n         }\n       }\n@@ -544,12 +555,88 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n       }\n     };\n \n-    loadTimelineData();\n+    run();\n \n     return () => {\n       cancelled = true;\n     };\n-  }, [isAuthenticated, timezone, dateLocale, allTimelineDays]);\n+  }, [isAuthenticated, timezone, dateLocale, mergePictures, loadRange]);\n+\n+  const loadPastChunk = useCallback(async () => {\n+    if (loadingPast || !hasMorePast || days.length === 0) return;\n+    setLoadingPast(true);\n+    const firstDay = days[0];\n+    const firstDate = startOfDay(new Date(firstDay.date));\n+    const desiredStart = addDays(firstDate, -CHUNK_SIZE);\n+    const minDate = addDays(startOfDay(new Date()), -MAX_PAST_DAYS);\n+    const actualStart = desiredStart < minDate ? minDate : desiredStart;\n+    const actualEnd = addDays(firstDate, -1);\n+\n+    if (actualEnd.getTime() < actualStart.getTime()) {\n+      setHasMorePast(false);\n+      setLoadingPast(false);\n+      return;\n+    }\n+\n+    const newDays = buildDayRange(actualStart, actualEnd);\n+    const container = scrollContainerRef.current;\n+    const prevScroll = container?.scrollTop ?? 0;\n+    const addedCount = newDays.length;\n+\n+    setDays(prev => {\n+      const existing = new Set(prev.map(d => d.date));\n+      const merged = [...newDays.filter(d => !existing.has(d.date)), ...prev];\n+      return merged;\n+    });\n+\n+    requestAnimationFrame(() => {\n+      if (container) {\n+        container.scrollTop = prevScroll + addedCount * SLOT_HEIGHT;\n+        setScrollTopValue(container.scrollTop);\n+      }\n+    });\n+\n+    if (isAuthenticated) {\n+      await loadRange(actualStart, actualEnd);\n+    }\n+\n+    const reachedMin = actualStart.getTime() <= minDate.getTime();\n+    setHasMorePast(!reachedMin);\n+    setLoadingPast(false);\n+  }, [days, hasMorePast, isAuthenticated, loadRange, loadingPast]);\n+\n+  const loadFutureChunk = useCallback(async () => {\n+    if (loadingFuture || !hasMoreFuture || days.length === 0) return;\n+    setLoadingFuture(true);\n+    const lastDay = days[days.length - 1];\n+    const lastDate = startOfDay(new Date(lastDay.date));\n+    const desiredEnd = addDays(lastDate, CHUNK_SIZE);\n+    const maxDate = addDays(startOfDay(new Date()), MAX_FUTURE_DAYS);\n+    const actualEnd = desiredEnd > maxDate ? maxDate : desiredEnd;\n+    const actualStart = addDays(lastDate, 1);\n+\n+    if (actualStart.getTime() > actualEnd.getTime()) {\n+      setHasMoreFuture(false);\n+      setLoadingFuture(false);\n+      return;\n+    }\n+\n+    const newDays = buildDayRange(actualStart, actualEnd);\n+\n+    setDays(prev => {\n+      const existing = new Set(prev.map(d => d.date));\n+      const merged = [...prev, ...newDays.filter(d => !existing.has(d.date))];\n+      return merged;\n+    });\n+\n+    if (isAuthenticated) {\n+      await loadRange(actualStart, actualEnd);\n+    }\n+\n+    const reachedMax = actualEnd.getTime() >= maxDate.getTime();\n+    setHasMoreFuture(!reachedMax);\n+    setLoadingFuture(false);\n+  }, [days, hasMoreFuture, isAuthenticated, loadRange, loadingFuture]);\n \n   // @@@ Group items by date\n   const timelineByDate = useMemo(() => {\n@@ -567,57 +654,83 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n       map.set(date, entry);\n     });\n \n-    starredComments.forEach(comment => {\n-      const commentDate = new Date(comment.appliedAt || comment.computedAt);\n-      const date = getLocalDateString(commentDate);\n-      const hasFullComments = allCommentsByDate.has(date);\n-      if (!map.has(date)) {\n-        map.set(date, { comments: [] });\n-      }\n-      if (!hasFullComments) {\n-        map.get(date)!.comments.push(comment);\n-      }\n+    picturesByDate.forEach((pic, date) => {\n+      const entry = map.get(date) || { comments: [] };\n+      entry.picture = pic;\n+      map.set(date, entry);\n     });\n \n-    pictures.forEach(pic => {\n-      const date = pic.date;\n-      if (!map.has(date)) {\n-        map.set(date, { comments: [] });\n+    return map;\n+  }, [datesWithSessions, allCommentsByDate, picturesByDate]);\n+\n+  useEffect(() => {\n+    const container = scrollContainerRef.current;\n+    if (!container) return;\n+\n+    const handleScroll = () => {\n+      const top = container.scrollTop;\n+      setScrollTopValue(top);\n+\n+      if (top < LOAD_THRESHOLD_PX) {\n+        loadPastChunk();\n       }\n-      map.get(date)!.picture = pic;\n-    });\n+      if (top + container.clientHeight > container.scrollHeight - LOAD_THRESHOLD_PX) {\n+        loadFutureChunk();\n+      }\n+    };\n \n-    return map;\n-  }, [datesWithSessions, allCommentsByDate, starredComments, pictures]);\n+    const handleResize = () => {\n+      setViewportHeight(container.clientHeight);\n+    };\n+\n+    container.addEventListener('scroll', handleScroll);\n+    window.addEventListener('resize', handleResize);\n+    handleResize();\n+\n+    return () => {\n+      container.removeEventListener('scroll', handleScroll);\n+      window.removeEventListener('resize', handleResize);\n+    };\n+  }, [loadFutureChunk, loadPastChunk]);\n \n   // @@@ Set initial scroll position to show today's row centered\n   useLayoutEffect(() => {\n-    if (!isVisible || initialLoading || !scrollContainerRef.current) return;\n-\n+    if (!isVisible || initialLoading || !scrollContainerRef.current || !pendingInitialScroll) return;\n     const container = scrollContainerRef.current;\n     const todayStr = getLocalDateString();\n+    const todayIndex = days.findIndex(d => d.date === todayStr);\n+    if (todayIndex === -1) return;\n \n     requestAnimationFrame(() => {\n-      requestAnimationFrame(() => {\n-        const todayElement = container.querySelector(`[data-date=\"${todayStr}\"]`) as HTMLElement | null;\n-        if (todayElement) {\n-          const containerHeight = container.clientHeight;\n-          const elementTop = todayElement.offsetTop;\n-          const elementHeight = todayElement.offsetHeight;\n-          const scrollTarget = elementTop - (containerHeight / 2) + (elementHeight / 2);\n-          container.scrollTop = Math.max(0, scrollTarget);\n-        }\n-      });\n+      const target = todayIndex * SLOT_HEIGHT - (container.clientHeight / 2) + (CARD_HEIGHT / 2) + 32;\n+      container.scrollTop = Math.max(0, target);\n+      setScrollTopValue(container.scrollTop);\n+      setPendingInitialScroll(false);\n     });\n-  }, [isVisible, initialLoading, allTimelineDays]);\n+  }, [days, initialLoading, isVisible, pendingInitialScroll]);\n+\n+  const visibleMetrics = useMemo(() => {\n+    const effectiveScroll = Math.max(0, scrollTopValue - 32);\n+    const firstVisibleIndex = Math.floor(effectiveScroll / SLOT_HEIGHT);\n+    const visibleCount = Math.ceil((viewportHeight || 0) / SLOT_HEIGHT) + 1;\n+    const renderStart = Math.max(0, firstVisibleIndex - VIRTUAL_BUFFER);\n+    const renderEnd = Math.min(days.length - 1, firstVisibleIndex + visibleCount + VIRTUAL_BUFFER);\n+    return { renderStart, renderEnd };\n+  }, [days.length, scrollTopValue, viewportHeight]);\n+\n+  const { renderStart, renderEnd } = visibleMetrics;\n+  const renderedDays = days.slice(renderStart, renderEnd + 1);\n+  const totalHeight = days.length > 0\n+    ? (days.length - 1) * SLOT_HEIGHT + CARD_HEIGHT + 32\n+    : 0;\n \n   // @@@ Reload comments for a specific date from backend\n   const reloadCommentsForDate = async (dateStr: string) => {\n     setLoadingCommentsForDate(dateStr);\n \n     try {\n       if (isAuthenticated) {\n-        const sessionsForDate = sessionSummaries.filter(session => session.date_key === dateStr);\n+        const sessionsForDate = Array.from(sessionSummaries.values()).filter(session => session.date_key === dateStr);\n \n         if (sessionsForDate.length === 0) {\n           setAllCommentsByDate(prev => {\n@@ -659,25 +772,28 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n   };\n \n   const handleImageClick = async (picture: TimelinePicture) => {\n-    setViewingImage({ ...picture });\n+    const stored = picturesByDate.get(picture.date) || picture;\n+    setViewingImage({ ...stored });\n \n-    if (!picture.full_base64 && isAuthenticated) {\n+    if (!stored.full_base64 && isAuthenticated) {\n       try {\n         const { getDailyPictureFull } = await import('../api/voiceApi');\n-        const fullImage = await getDailyPictureFull(picture.date);\n+        const fullImage = await getDailyPictureFull(stored.date);\n \n-        const updatedPicture = { ...picture, full_base64: fullImage };\n+        const updatedPicture = { ...stored, full_base64: fullImage };\n         setViewingImage(updatedPicture);\n \n-        setPictures(prev => prev.map(p =>\n-          p.date === picture.date ? updatedPicture : p\n-        ));\n+        setPicturesByDate(prev => {\n+          const next = new Map(prev);\n+          next.set(stored.date, updatedPicture);\n+          return next;\n+        });\n       } catch (error) {\n         console.error('Failed to load full image:', error);\n       }\n     }\n \n-    await reloadCommentsForDate(picture.date);\n+    await reloadCommentsForDate(stored.date);\n   };\n \n   const handleGenerateForDate = async (dateStr: string) => {\n@@ -707,9 +823,11 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n \n       await saveDailyPicture(pictureDate, image_base64, prompt, thumbnail_base64);\n \n-      const updated = pictures.filter(p => p.date !== pictureDate);\n-      updated.unshift(newPicture);\n-      setPictures(updated);\n+      setPicturesByDate(prev => {\n+        const next = new Map(prev);\n+        next.set(pictureDate, newPicture);\n+        return next;\n+      });\n     } catch (error) {\n       console.error('Image generation failed:', error);\n       alert('Failed to generate image. Please try again.');\n@@ -761,16 +879,13 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n         />\n \n         {/* Cards */}\n-        {allTimelineDays.map((day, index) => {\n+        {renderedDays.map((day, localIndex) => {\n+          const globalIndex = renderStart + localIndex;\n           const dayData = timelineByDate.get(day.date);\n-          const hasData = !!dayData;\n+          const hasData = timelineByDate.has(day.date);\n           const isGenerating = generatingForDate === day.date;\n-          const isLeftSide = index % 2 === 0;\n-\n-          // Each card occupies a \"slot\" but overlaps with neighbors\n-          // Slot height = CARD_HEIGHT - CARD_OVERLAP (the non-overlapping portion)\n-          const slotHeight = CARD_HEIGHT - CARD_OVERLAP;\n-          const topPosition = index * slotHeight;\n+          const isLeftSide = globalIndex % 2 === 0;\n+          const topPosition = globalIndex * SLOT_HEIGHT;\n \n           return (\n             <div\n@@ -784,7 +899,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n                 paddingRight: isLeftSide ? '24px' : '0',\n                 paddingLeft: isLeftSide ? '0' : '24px',\n                 height: `${CARD_HEIGHT}px`,\n-                zIndex: allTimelineDays.length - index, // Stack order for overlapping\n+                zIndex: days.length - globalIndex, // Stack order for overlapping\n               }}\n             >\n               {/* Timeline dot */}\n@@ -822,7 +937,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin\n         })}\n \n         {/* Spacer to ensure container has correct height */}\n-        <div style={{ height: `${(allTimelineDays.length - 1) * (CARD_HEIGHT - CARD_OVERLAP) + CARD_HEIGHT + 32}px` }} />\n+        <div style={{ height: `${totalHeight}px` }} />\n       </div>\n \n       {/* Image Lightbox Modal */}"
    }
  ]
}