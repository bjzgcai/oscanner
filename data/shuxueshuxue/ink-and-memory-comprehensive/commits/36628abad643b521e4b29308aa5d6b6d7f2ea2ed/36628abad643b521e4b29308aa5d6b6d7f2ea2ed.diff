commit 36628abad643b521e4b29308aa5d6b6d7f2ea2ed
Author: lexicalmathical <lexicalmathical@gmail.com>
Date:   Tue Oct 21 22:41:04 2025 +0800

    Add hover feedback and fix Use Default button bug
    
    Features:
    - Implement hover feedback between highlighted text and voice comments
      - Hovering over highlighted text highlights corresponding comment
      - Comment scales up, adds shadow, and changes border
      - Smooth transitions for visual feedback
    - Add cursor pointer and hover effects to highlighted text
    
    Bug Fixes:
    - Fix "Use Default" button not refreshing display immediately
      - Root cause: defaultVoices prop was pointing to modified voiceConfigs
      - Solution: Store original backend defaults in separate state
      - Now clicking "Use Default" correctly resets to original defaults
    - Clear old voice triggers when voice config changes
      - Ensures immediate visual feedback when switching configs
    
    Technical Changes:
    - Add onPhraseHover callback to VoiceHighlight extension
    - Implement DOM event handlers (mouseover/mouseout) in ProseMirror plugin
    - Add hoveredPhrase state management in App.tsx
    - Pass isHovered prop to VoiceComment components
    - Separate defaultVoiceConfigs from voiceConfigs in App state
    - Add CSS hover effects for .voice-highlight elements
    
    ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
    
    Co-Authored-By: Claude <noreply@anthropic.com>

diff --git a/frontend/src/App.css b/frontend/src/App.css
index ce3ed02..d95e844 100644
--- a/frontend/src/App.css
+++ b/frontend/src/App.css
@@ -235,6 +235,13 @@
 .voice-highlight {
   margin: -2px -6px;
   padding: 2px 6px;
+  cursor: pointer;
+  transition: all 0.2s ease;
+}
+
+.voice-highlight:hover {
+  transform: scale(1.05);
+  filter: brightness(0.95);
 }
 
 .voice-highlight-yellow {
diff --git a/frontend/src/App.tsx b/frontend/src/App.tsx
index 0c1b465..2cadb9f 100644
--- a/frontend/src/App.tsx
+++ b/frontend/src/App.tsx
@@ -60,6 +60,8 @@ function App() {
           color: v.color   // Keep text name: "blue"
         };
       }
+      // Store the original defaults separately (never modified)
+      setDefaultVoiceConfigs(converted);
       // Use localStorage if exists, otherwise use backend defaults
       setVoiceConfigs(getVoices() || converted);
     });
@@ -69,10 +71,12 @@ function App() {
   const [voices, setVoices] = useState<Voice[]>([]);
   const [voiceTriggers, setVoiceTriggers] = useState<VoiceTrigger[]>([]);
   const [voiceConfigs, setVoiceConfigs] = useState<Record<string, VoiceConfig>>({});
+  const [defaultVoiceConfigs, setDefaultVoiceConfigs] = useState<Record<string, VoiceConfig>>({});
   const [currentText, setCurrentText] = useState<string>('');
   const [currentHTML, setCurrentHTML] = useState<string>('');
   const [cursorPosition, setCursorPosition] = useState<number>(0);
   const [focusedVoiceIndex, setFocusedVoiceIndex] = useState<number | undefined>(undefined);
+  const [hoveredPhrase, setHoveredPhrase] = useState<string | null>(null);
   const currentTextRef = useRef<string>('');
   const isAnalyzingRef = useRef<boolean>(false);
   const editorRef = useRef<EditableTextAreaRef>(null);
@@ -236,6 +240,14 @@ function App() {
     detectVoices(currentText, voiceTriggers);
   }, [voiceTriggers]);
 
+  // @@@ Clear old triggers when voice config changes (e.g., Use Default)
+  // This forces immediate re-analysis with new config
+  useEffect(() => {
+    console.log('ðŸ”„ Voice config changed, clearing old triggers');
+    setVoiceTriggers([]);
+    setVoices([]);
+  }, [voiceConfigs]);
+
   return (
     <>
       <LeftSidebar currentView={currentView} onViewChange={setCurrentView} />
@@ -247,19 +259,30 @@ function App() {
             onContentChange={handleContentChange}
             triggers={voiceTriggers}
             onCursorChange={setCursorPosition}
+            onPhraseHover={setHoveredPhrase}
             content={currentHTML}
           />
           <VoicesPanel focusedVoiceIndex={focusedVoiceIndex}>
-            {voices.map((voice, index) => (
-              <VoiceComment
-                key={index}
-                voice={voice.name}
-                text={voice.text}
-                icon={voice.icon}
-                color={voice.color}
-                onQuote={() => handleQuote(voice.name, voice.text)}
-              />
-            ))}
+            {voices.map((voice, index) => {
+              // @@@ Find the trigger phrase for this voice
+              const trigger = voiceTriggers.find(t =>
+                t.voice === voice.name && t.comment === voice.text
+              );
+              const isHovered = hoveredPhrase !== null && trigger !== undefined &&
+                hoveredPhrase.toLowerCase() === trigger.phrase.toLowerCase();
+
+              return (
+                <VoiceComment
+                  key={index}
+                  voice={voice.name}
+                  text={voice.text}
+                  icon={voice.icon}
+                  color={voice.color}
+                  onQuote={() => handleQuote(voice.name, voice.text)}
+                  isHovered={isHovered}
+                />
+              );
+            })}
           </VoicesPanel>
           <BinderRings />
         </div>
@@ -276,7 +299,7 @@ function App() {
           overflow: 'hidden'
         }}>
           <VoiceSettings
-            defaultVoices={voiceConfigs}
+            defaultVoices={defaultVoiceConfigs}
             onSave={setVoiceConfigs}
           />
         </div>
diff --git a/frontend/src/components/EditableTextArea.tsx b/frontend/src/components/EditableTextArea.tsx
index 23c97b9..fdbdec5 100644
--- a/frontend/src/components/EditableTextArea.tsx
+++ b/frontend/src/components/EditableTextArea.tsx
@@ -9,6 +9,7 @@ interface EditableTextAreaProps {
   onContentChange?: (html: string) => void;
   triggers: VoiceTrigger[];
   onCursorChange?: (position: number) => void;
+  onPhraseHover?: (phrase: string | null) => void;
   content?: string;
 }
 
@@ -18,7 +19,7 @@ export interface EditableTextAreaRef {
 
 const EditableTextArea = forwardRef<EditableTextAreaRef, EditableTextAreaProps>(
   (props, ref) => {
-    const { onChange, onContentChange, triggers, onCursorChange, content } = props;
+    const { onChange, onContentChange, triggers, onCursorChange, onPhraseHover, content } = props;
 
     const editor = useEditor({
       extensions: [
@@ -26,7 +27,10 @@ const EditableTextArea = forwardRef<EditableTextAreaRef, EditableTextAreaProps>(
         Placeholder.configure({
           placeholder: 'write here, I am listening...',
         }),
-        VoiceHighlight.configure({ triggers })
+        VoiceHighlight.configure({
+          triggers,
+          onPhraseHover
+        })
       ],
       content: content || '',
       onUpdate: ({ editor }) => {
@@ -50,6 +54,17 @@ const EditableTextArea = forwardRef<EditableTextAreaRef, EditableTextAreaProps>(
       }
     }, [triggers, editor]);
 
+    // @@@ Update onPhraseHover callback when it changes
+    useEffect(() => {
+      if (editor) {
+        editor.extensionManager.extensions.forEach((ext: any) => {
+          if (ext.name === 'voiceHighlight' && ext.options) {
+            ext.options.onPhraseHover = onPhraseHover;
+          }
+        });
+      }
+    }, [onPhraseHover, editor]);
+
     // Expose insertText method to parent component
     useImperativeHandle(ref, () => ({
       insertText: (text: string) => {
diff --git a/frontend/src/components/VoiceComment.tsx b/frontend/src/components/VoiceComment.tsx
index 619b37e..8969293 100644
--- a/frontend/src/components/VoiceComment.tsx
+++ b/frontend/src/components/VoiceComment.tsx
@@ -6,6 +6,7 @@ interface VoiceCommentProps {
   icon: string;
   color: string;
   onQuote?: () => void;
+  isHovered?: boolean;
 }
 
 const iconMap = {
@@ -31,17 +32,21 @@ const colorMap: Record<string, { background: string; border: string }> = {
   purple: { background: '#f3e6ff', border: '#b366ff' },
 };
 
-export default function VoiceComment({ voice, text, icon, color, onQuote }: VoiceCommentProps) {
+export default function VoiceComment({ voice, text, icon, color, onQuote, isHovered }: VoiceCommentProps) {
   const Icon = iconMap[icon as keyof typeof iconMap];
   const colors = colorMap[color] || { background: '#f0f0f0', border: '#ccc' };
 
   return (
     <div
-      className="voice-comment"
+      className={`voice-comment ${isHovered ? 'hovered' : ''}`}
       style={{
         backgroundColor: colors.background,
         borderColor: colors.border,
-        position: 'relative'
+        position: 'relative',
+        transform: isHovered ? 'scale(1.02)' : 'scale(1)',
+        boxShadow: isHovered ? '0 4px 12px rgba(0,0,0,0.15)' : 'none',
+        transition: 'all 0.2s ease',
+        borderWidth: isHovered ? '2px' : '4px',
       }}
     >
       <div className="voice-header">
diff --git a/frontend/src/components/VoiceSettings.tsx b/frontend/src/components/VoiceSettings.tsx
index c331807..6c8875f 100644
--- a/frontend/src/components/VoiceSettings.tsx
+++ b/frontend/src/components/VoiceSettings.tsx
@@ -42,9 +42,13 @@ export default function VoiceSettings({ defaultVoices, onSave }: Props) {
   };
 
   const handleDefault = () => {
+    console.log('ðŸ”„ Use Default clicked');
+    console.log('Current voices:', voices);
+    console.log('Default voices:', defaultVoices);
     clearVoices();
     // Deep copy to force React to re-render
     const freshDefaults = JSON.parse(JSON.stringify(defaultVoices));
+    console.log('Fresh defaults:', freshDefaults);
     setVoices(freshDefaults);
     onSave(freshDefaults);
   };
diff --git a/frontend/src/components/WritingArea.tsx b/frontend/src/components/WritingArea.tsx
index c73127f..3bfb79d 100644
--- a/frontend/src/components/WritingArea.tsx
+++ b/frontend/src/components/WritingArea.tsx
@@ -8,13 +8,14 @@ interface WritingAreaProps {
   onContentChange?: (html: string) => void;
   triggers: VoiceTrigger[];
   onCursorChange?: (position: number) => void;
+  onPhraseHover?: (phrase: string | null) => void;
   content?: string;
 }
 
-const WritingArea = forwardRef<EditableTextAreaRef, WritingAreaProps>(({ onChange, onContentChange, triggers, onCursorChange, content }, ref) => {
+const WritingArea = forwardRef<EditableTextAreaRef, WritingAreaProps>(({ onChange, onContentChange, triggers, onCursorChange, onPhraseHover, content }, ref) => {
   return (
     <BookPage side="left">
-      <EditableTextArea ref={ref} onChange={onChange} onContentChange={onContentChange} triggers={triggers} onCursorChange={onCursorChange} content={content} />
+      <EditableTextArea ref={ref} onChange={onChange} onContentChange={onContentChange} triggers={triggers} onCursorChange={onCursorChange} onPhraseHover={onPhraseHover} content={content} />
     </BookPage>
   );
 });
diff --git a/frontend/src/extensions/VoiceHighlight.ts b/frontend/src/extensions/VoiceHighlight.ts
index 91189fa..0077fef 100644
--- a/frontend/src/extensions/VoiceHighlight.ts
+++ b/frontend/src/extensions/VoiceHighlight.ts
@@ -12,6 +12,7 @@ export interface VoiceTrigger {
 
 export interface VoiceHighlightOptions {
   triggers: VoiceTrigger[];
+  onPhraseHover?: (phrase: string | null) => void;
 }
 
 export const VoiceHighlight = Extension.create<VoiceHighlightOptions>({
@@ -20,11 +21,13 @@ export const VoiceHighlight = Extension.create<VoiceHighlightOptions>({
   addOptions() {
     return {
       triggers: [],
+      onPhraseHover: undefined,
     };
   },
 
   addProseMirrorPlugins() {
     let triggers = this.options.triggers;
+    const onPhraseHover = this.options.onPhraseHover;
 
     return [
       new Plugin({
@@ -60,6 +63,33 @@ export const VoiceHighlight = Extension.create<VoiceHighlightOptions>({
           decorations(state) {
             return this.getState(state)?.decorations;
           },
+
+          // @@@ Hover detection - Find which phrase is being hovered
+          handleDOMEvents: {
+            mouseover(_view, event) {
+              const target = event.target as HTMLElement;
+
+              // Check if hovering over a highlighted element
+              if (target.classList.contains('voice-highlight')) {
+                // Extract the text content
+                const phrase = target.textContent || '';
+                onPhraseHover?.(phrase);
+                return false;
+              }
+              return false;
+            },
+
+            mouseout(_view, event) {
+              const target = event.target as HTMLElement;
+
+              // Check if leaving a highlighted element
+              if (target.classList.contains('voice-highlight')) {
+                onPhraseHover?.(null);
+                return false;
+              }
+              return false;
+            },
+          },
         },
       }),
     ];
