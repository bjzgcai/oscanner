{
  "sha": "878d4289ef68d2dae43aba9c2cdb779a99118c45",
  "node_id": "C_kwDOP2Zrm9oAKDg3OGQ0Mjg5ZWY2OGQyZGFlNDNhYmE5YzJjZGI3NzlhOTkxMThjNDU",
  "commit": {
    "author": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-12-09T16:59:13Z"
    },
    "committer": {
      "name": "lexicalmathical",
      "email": "lexicalmathical@gmail.com",
      "date": "2025-12-09T16:59:13Z"
    },
    "message": "remove friends from the timeline",
    "tree": {
      "sha": "639e95d142bcb2b4dda35d49fd98ef0881101962",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/trees/639e95d142bcb2b4dda35d49fd98ef0881101962"
    },
    "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/git/commits/878d4289ef68d2dae43aba9c2cdb779a99118c45",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null,
      "verified_at": null
    }
  },
  "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/878d4289ef68d2dae43aba9c2cdb779a99118c45",
  "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/878d4289ef68d2dae43aba9c2cdb779a99118c45",
  "comments_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/878d4289ef68d2dae43aba9c2cdb779a99118c45/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "5ad37f6dedcf974531b2d519954642aca39b13e8",
      "url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/commits/5ad37f6dedcf974531b2d519954642aca39b13e8",
      "html_url": "https://github.com/shuxueshuxue/ink-and-memory/commit/5ad37f6dedcf974531b2d519954642aca39b13e8"
    }
  ],
  "stats": {
    "total": 996,
    "additions": 191,
    "deletions": 805
  },
  "files": [
    {
      "sha": "3c3084528d96ad976e15a55f47ee1ef1a0d1ee69",
      "filename": "frontend/src/App.tsx",
      "status": "modified",
      "additions": 0,
      "deletions": 13,
      "changes": 13,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/878d4289ef68d2dae43aba9c2cdb779a99118c45/frontend%2Fsrc%2FApp.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/878d4289ef68d2dae43aba9c2cdb779a99118c45/frontend%2Fsrc%2FApp.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2FApp.tsx?ref=878d4289ef68d2dae43aba9c2cdb779a99118c45",
      "patch": "@@ -101,7 +101,6 @@ export default function App() {\n \n   const [currentView, setCurrentView] = useState<'writing' | 'settings' | 'timeline' | 'analysis' | 'decks' | 'friends'>('writing');\n   const [showCalendarPopup, setShowCalendarPopup] = useState(false);\n-  const [timelineFriendToSelect, setTimelineFriendToSelect] = useState<number | null>(null);\n   const [voiceConfigs, setVoiceConfigs] = useState<Record<string, VoiceConfig>>({});\n \n   const browserTimezone = useMemo(() => {\n@@ -1054,15 +1053,6 @@ export default function App() {\n     setShowCalendarPopup(false);\n   }, []);\n \n-  const handleViewFriendTimeline = useCallback((friendId: number, _friendName?: string) => {\n-    setTimelineFriendToSelect(friendId);\n-    setCurrentView('timeline');\n-  }, []);\n-\n-  const handleFriendSelectionHandled = useCallback(() => {\n-    setTimelineFriendToSelect(null);\n-  }, []);\n-\n   const handleCalendarEntryDeleted = useCallback((entryId: string) => {\n     if (!entryId || !engineRef.current) return;\n     const currentId = engineRef.current.getState().id;\n@@ -2277,8 +2267,6 @@ export default function App() {\n         <CollectionsView\n           isVisible={currentView === 'timeline'}\n           voiceConfigs={voiceConfigs}\n-          friendToSelect={timelineFriendToSelect}\n-          onFriendSelectionHandled={handleFriendSelectionHandled}\n           timezone={userTimezone}\n         />\n       </div>\n@@ -2310,7 +2298,6 @@ export default function App() {\n         }}>\n           <FriendsView\n             isVisible={currentView === 'friends'}\n-            onViewFriendTimeline={handleViewFriendTimeline}\n           />\n         </div>\n       )}"
    },
    {
      "sha": "cb48dfdf9011b8cc467587a0bd85157929f1f33f",
      "filename": "frontend/src/components/CollectionsView.tsx",
      "status": "modified",
      "additions": 191,
      "deletions": 792,
      "changes": 983,
      "blob_url": "https://github.com/shuxueshuxue/ink-and-memory/blob/878d4289ef68d2dae43aba9c2cdb779a99118c45/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx",
      "raw_url": "https://github.com/shuxueshuxue/ink-and-memory/raw/878d4289ef68d2dae43aba9c2cdb779a99118c45/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx",
      "contents_url": "https://api.github.com/repos/shuxueshuxue/ink-and-memory/contents/frontend%2Fsrc%2Fcomponents%2FCollectionsView.tsx?ref=878d4289ef68d2dae43aba9c2cdb779a99118c45",
      "patch": "@@ -1,11 +1,10 @@\n-import { useState, useEffect, useLayoutEffect, useRef, useMemo, useCallback } from 'react';\n+import { useState, useEffect, useLayoutEffect, useRef, useMemo } from 'react';\n import { useTranslation } from 'react-i18next';\n import type { Commentor } from '../engine/EditorEngine';\n import { findNormalizedPhrase } from '../utils/textNormalize';\n import { useAuth } from '../contexts/AuthContext';\n import { STORAGE_KEYS } from '../constants/storageKeys';\n import { getDateLocale } from '../i18n';\n-import type { Friend } from '../api/voiceApi';\n import { extractFirstLine } from '../utils/calendarStorage';\n import { loadSessionsGroupedByDate } from '../utils/sessionGrouping';\n \n@@ -33,12 +32,10 @@ interface TimelineEntryData {\n interface CollectionsViewProps {\n   isVisible: boolean;\n   voiceConfigs: Record<string, any>;\n-  friendToSelect?: number | null;\n-  onFriendSelectionHandled?: () => void;\n   timezone: string;\n }\n \n-export default function CollectionsView({ isVisible, voiceConfigs, friendToSelect, onFriendSelectionHandled, timezone }: CollectionsViewProps) {\n+export default function CollectionsView({ isVisible, voiceConfigs, timezone }: CollectionsViewProps) {\n   const { i18n } = useTranslation();\n   const dateLocale = getDateLocale(i18n.language);\n   return (\n@@ -54,8 +51,6 @@ export default function CollectionsView({ isVisible, voiceConfigs, friendToSelec\n         isVisible={isVisible}\n         voiceConfigs={voiceConfigs}\n         dateLocale={dateLocale}\n-        friendToSelect={friendToSelect}\n-        onFriendSelectionHandled={onFriendSelectionHandled}\n         timezone={timezone}\n       />\n     </div>\n@@ -64,16 +59,13 @@ export default function CollectionsView({ isVisible, voiceConfigs, friendToSelec\n \n // @@@ Extract complete sentence containing a phrase\n function extractCompleteSentence(text: string, phrase: string): string {\n-  // Find phrase position (with normalization)\n   const phraseIndex = findNormalizedPhrase(text, phrase);\n   if (phraseIndex === -1) {\n-    return phrase; // Fallback if phrase not found\n+    return phrase;\n   }\n \n-  // Sentence ending markers\n   const sentenceEndings = '.!?\u3002\uff01\uff1f\\n';\n \n-  // Find sentence start - go backwards to find previous sentence ending or start of text\n   let sentenceStart = 0;\n   for (let i = phraseIndex - 1; i >= 0; i--) {\n     if (sentenceEndings.includes(text[i])) {\n@@ -82,7 +74,6 @@ function extractCompleteSentence(text: string, phrase: string): string {\n     }\n   }\n \n-  // Find sentence end - go forwards to find next sentence ending\n   let sentenceEnd = text.length;\n   for (let i = phraseIndex + phrase.length; i < text.length; i++) {\n     if (sentenceEndings.includes(text[i])) {\n@@ -91,7 +82,6 @@ function extractCompleteSentence(text: string, phrase: string): string {\n     }\n   }\n \n-  // Extract sentence and trim whitespace\n   return text.slice(sentenceStart, sentenceEnd).trim();\n }\n \n@@ -114,9 +104,7 @@ function getIconForVoice(icon: string): string {\n   return iconMap[icon] || '\ud83d\udcad';\n }\n \n-// @@@ Helper to format dates consistently\n // @@@ Helper to get date in local timezone as YYYY-MM-DD\n-// Prevents timezone issues where UTC date differs from user's local date\n function getLocalDateString(date?: Date | string): string {\n   const d = date ? new Date(date) : new Date();\n   const year = d.getFullYear();\n@@ -134,14 +122,12 @@ function formatDate(date: Date | string, locale: string): string {\n }\n \n // @@@ Generate timeline days (7 past + today + 7 future)\n-// Returns dates in YYYY-MM-DD format to match database storage\n function generateTimelineDays(): TimelineDay[] {\n   const today = new Date();\n   const todayStr = getLocalDateString(today);\n   const allTimelineDays: TimelineDay[] = [];\n \n-  // Add past 7 days\n-  for (let i = 7; i >= 1; i--) {\n+  for (let i = 10; i >= 1; i--) {\n     const pastDate = new Date(today);\n     pastDate.setDate(today.getDate() - i);\n     allTimelineDays.push({\n@@ -153,7 +139,6 @@ function generateTimelineDays(): TimelineDay[] {\n     });\n   }\n \n-  // Add today\n   allTimelineDays.push({\n     date: todayStr,\n     isPast: false,\n@@ -162,8 +147,7 @@ function generateTimelineDays(): TimelineDay[] {\n     daysOffset: 0\n   });\n \n-  // Add future 7 days\n-  for (let i = 1; i <= 7; i++) {\n+  for (let i = 1; i <= 10; i++) {\n     const futureDate = new Date(today);\n     futureDate.setDate(today.getDate() + i);\n     allTimelineDays.push({\n@@ -188,37 +172,35 @@ function getPlaceholderText(t: (key: string, options?: any) => string, daysOffse\n     return translation;\n   }\n \n-  return daysOffset < 0 ? t('timelinePlaceholders.default') : t('timelinePlaceholders.default');\n+  return t('timelinePlaceholders.default');\n }\n \n // @@@ Extract and truncate beginning of text for timeline preview\n function getTextPreview(text: string, maxLength: number = 60): string {\n   if (!text || text.trim().length === 0) return '';\n \n-  // Remove extra whitespace\n   const cleaned = text.trim().replace(/\\s+/g, ' ');\n-\n-  // Find first sentence ending\n   const sentenceEndings = /[.!?\u3002\uff01\uff1f]/;\n   const match = cleaned.match(sentenceEndings);\n \n   let preview = '';\n   if (match && match.index !== undefined && match.index < maxLength * 1.5) {\n-    // Use first sentence if it's not too long\n     preview = cleaned.substring(0, match.index + 1);\n   } else {\n-    // Otherwise use first N characters\n     preview = cleaned.substring(0, maxLength);\n   }\n \n-  // Truncate if still too long\n   if (preview.length > maxLength) {\n     preview = preview.substring(0, maxLength).trim() + '...';\n   }\n \n   return preview;\n }\n \n+// @@@ Card height for overlap calculation\n+const CARD_HEIGHT = 100;\n+const CARD_OVERLAP = 30; // 30% overlap for zigzag effect\n+\n interface TimelineCardProps {\n   day: TimelineDay;\n   dayData?: TimelineEntryData;\n@@ -231,11 +213,10 @@ interface TimelineCardProps {\n   t: (key: string, options?: any) => string;\n   onImageClick: (picture: TimelinePicture) => void;\n   onGenerate?: (date: string) => void;\n-  readOnly?: boolean;\n-  customDescription?: string;\n+  side: 'left' | 'right';\n }\n \n-function renderTimelineCard({\n+function TimelineCard({\n   day,\n   dayData,\n   hasData,\n@@ -247,18 +228,15 @@ function renderTimelineCard({\n   t,\n   onImageClick,\n   onGenerate,\n-  readOnly,\n-  customDescription\n+  side\n }: TimelineCardProps) {\n   const cardCursor = dayData?.picture && !isGenerating ? 'pointer' : 'default';\n   const textContent = textByDate.get(day.date);\n   const firstLine = firstLineByDate.get(day.date);\n   const commentCount = dayData?.comments?.length || 0;\n \n   let description = placeholder;\n-  if (customDescription) {\n-    description = customDescription;\n-  } else if (isGenerating) {\n+  if (isGenerating) {\n     description = t('timeline.generating');\n   } else if (day.isToday && !dayData?.picture) {\n     description = placeholder;\n@@ -270,6 +248,10 @@ function renderTimelineCard({\n     description = t('timeline.entryCount', { count: commentCount });\n   }\n \n+  // For left side: text on left, image on right (near center line)\n+  // For right side: image on left (near center line), text on right\n+  const isLeftSide = side === 'left';\n+\n   return (\n     <div\n       onClick={() => {\n@@ -279,36 +261,77 @@ function renderTimelineCard({\n       }}\n       style={{\n         display: 'flex',\n+        flexDirection: isLeftSide ? 'row' : 'row-reverse',\n         alignItems: 'center',\n-        gap: '1rem',\n-        padding: '0.5rem 0',\n+        gap: '0.75rem',\n+        padding: '0.5rem',\n         cursor: cardCursor,\n-        transition: 'transform 0.2s',\n-        opacity: day.isPast && !hasData ? 0.4 : 1\n+        transition: 'transform 0.2s, box-shadow 0.2s',\n+        opacity: day.isPast && !hasData ? 0.5 : 1,\n+        width: '100%',\n+        height: `${CARD_HEIGHT}px`,\n+        boxSizing: 'border-box',\n+        background: 'rgba(248, 240, 230, 0.8)',\n+        borderRadius: '8px',\n       }}\n       onMouseEnter={e => {\n         if (dayData?.picture && !isGenerating) {\n-          e.currentTarget.style.transform = 'translateX(8px)';\n+          e.currentTarget.style.transform = 'scale(1.02)';\n+          e.currentTarget.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';\n         }\n       }}\n       onMouseLeave={e => {\n-        e.currentTarget.style.transform = 'translateX(0)';\n+        e.currentTarget.style.transform = 'scale(1)';\n+        e.currentTarget.style.boxShadow = 'none';\n       }}\n     >\n+      {/* Text content - on the outer side */}\n+      <div style={{\n+        flex: 1,\n+        minWidth: 0,\n+        textAlign: isLeftSide ? 'right' : 'left',\n+        paddingRight: isLeftSide ? '0.5rem' : 0,\n+        paddingLeft: isLeftSide ? 0 : '0.5rem',\n+      }}>\n+        <div style={{\n+          fontSize: '13px',\n+          fontWeight: 600,\n+          color: day.isToday ? '#2c2c2c' : '#666',\n+          marginBottom: '0.25rem'\n+        }}>\n+          {day.isToday ? t('timeline.today') : formatDate(day.date, dateLocale)}\n+        </div>\n+        <div style={{\n+          fontSize: '12px',\n+          color: '#888',\n+          fontStyle: (!textContent && (day.isToday || !dayData?.comments?.length)) ? 'italic' : 'normal',\n+          overflow: 'hidden',\n+          textOverflow: 'ellipsis',\n+          display: '-webkit-box',\n+          WebkitLineClamp: 2,\n+          WebkitBoxOrient: 'vertical',\n+          lineHeight: '1.4',\n+        }}>\n+          {description}\n+        </div>\n+      </div>\n+\n+      {/* Image - on the inner side (near center line) */}\n       <div style={{ flexShrink: 0 }}>\n         {dayData?.picture ? (\n           <div style={{ position: 'relative' }}>\n             <img\n               src={`data:image/${dayData.picture.base64?.startsWith('iVBOR') ? 'png' : 'jpeg'};base64,${dayData.picture.base64}`}\n               alt={dayData.picture.prompt}\n               style={{\n-                width: '80px',\n-                height: '80px',\n+                width: '72px',\n+                height: '72px',\n                 objectFit: 'cover',\n-                borderRadius: '6px'\n+                borderRadius: '6px',\n+                boxShadow: '0 2px 8px rgba(0,0,0,0.15)'\n               }}\n             />\n-            {!readOnly && onGenerate && (\n+            {onGenerate && (\n               <button\n                 onClick={(e) => {\n                   e.stopPropagation();\n@@ -319,94 +342,64 @@ function renderTimelineCard({\n                   position: 'absolute',\n                   top: '4px',\n                   right: '4px',\n-                  width: '24px',\n-                  height: '24px',\n+                  width: '22px',\n+                  height: '22px',\n                   borderRadius: '50%',\n                   background: 'rgba(255, 255, 255, 0.95)',\n                   border: 'none',\n                   cursor: isGenerating ? 'wait' : 'pointer',\n                   display: 'flex',\n                   alignItems: 'center',\n                   justifyContent: 'center',\n-                  opacity: 0.9,\n+                  opacity: 0.85,\n                   transition: 'opacity 0.2s'\n                 }}\n                 onMouseEnter={e => {\n                   if (!isGenerating) e.currentTarget.style.opacity = '1';\n                 }}\n                 onMouseLeave={e => {\n-                  e.currentTarget.style.opacity = '0.9';\n+                  e.currentTarget.style.opacity = '0.85';\n                 }}\n                 title=\"Redraw image\"\n               >\n-                <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n-                  <path d=\"M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2\"/>\n+                <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n+                  <path d=\"M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2\" />\n                 </svg>\n               </button>\n             )}\n           </div>\n         ) : (\n           <div style={{\n-            width: '80px',\n-            height: '80px',\n-            background: day.isFuture ? 'linear-gradient(135deg, #f8f0e6 0%, #ede3d5 100%)' : 'linear-gradient(135deg, #f0e8de 0%, #e5dbc9 100%)',\n+            width: '72px',\n+            height: '72px',\n+            background: day.isFuture\n+              ? 'linear-gradient(135deg, #f8f0e6 0%, #ede3d5 100%)'\n+              : 'linear-gradient(135deg, #f0e8de 0%, #e5dbc9 100%)',\n             border: day.isFuture ? '2px dashed #d0c4b0' : '2px dashed #b8a896',\n             borderRadius: '6px',\n             display: 'flex',\n             alignItems: 'center',\n             justifyContent: 'center',\n-            fontSize: '11px',\n-            color: '#999',\n-            fontStyle: 'italic',\n-            textAlign: 'center',\n-            padding: '0.5rem'\n+            fontSize: '20px',\n+            color: '#bbb',\n           }}>\n-            {isGenerating ? '...' : '?'}\n+            {isGenerating ? '\u23f3' : '\ud83d\udcf7'}\n           </div>\n         )}\n       </div>\n-\n-      <div style={{ flex: 1, minWidth: 0 }}>\n-        <div style={{\n-          fontSize: '14px',\n-          fontWeight: 600,\n-          color: day.isToday ? '#2c2c2c' : '#666',\n-          marginBottom: '0.25rem'\n-        }}>\n-          {day.isToday ? t('timeline.today') : formatDate(day.date, dateLocale)}\n-        </div>\n-        <div style={{\n-          fontSize: '13px',\n-          color: '#888',\n-          fontStyle: (!textContent && (day.isToday || !dayData?.comments?.length)) ? 'italic' : 'normal'\n-        }}>\n-          {description}\n-        </div>\n-      </div>\n     </div>\n   );\n }\n \n-// @@@ Get all notes from all sessions (localStorage for guest, database for authenticated)\n // @@@ Timeline page - combines pictures and comments by date\n-const MAX_RECENT_FRIENDS = 6;\n-\n-const getInitialLetter = (name?: string, fallback: string = '?') => {\n-  if (!name) return fallback;\n-  const first = name.trim().charAt(0).toUpperCase();\n-  return first || fallback;\n-};\n-\n interface TimelinePageProps {\n   isVisible: boolean;\n   voiceConfigs: Record<string, any>;\n   dateLocale: string;\n-  friendToSelect?: number | null;\n-  onFriendSelectionHandled?: () => void;\n   timezone: string;\n }\n \n-function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onFriendSelectionHandled, timezone }: TimelinePageProps) {\n+function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: TimelinePageProps) {\n   const { t } = useTranslation();\n   const { isAuthenticated } = useAuth();\n   const [starredComments, setStarredComments] = useState<Commentor[]>([]);\n@@ -415,121 +408,14 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n   const [firstLineByDate, setFirstLineByDate] = useState<Map<string, string>>(new Map());\n   const [pictures, setPictures] = useState<TimelinePicture[]>([]);\n   const [generatingForDate, setGeneratingForDate] = useState<string | null>(null);\n-  const [viewingImage, setViewingImage] = useState<{ base64: string; full_base64?: string; prompt: string; date: string; origin?: 'self' | 'friend'; friendId?: number } | null>(null);\n+  const [viewingImage, setViewingImage] = useState<{ base64: string; full_base64?: string; prompt: string; date: string; } | null>(null);\n   const [initialLoading, setInitialLoading] = useState(true);\n   const [loadingCommentsForDate, setLoadingCommentsForDate] = useState<string | null>(null);\n-  const [friends, setFriends] = useState<Friend[]>([]);\n-  const [selectedFriendId, setSelectedFriendId] = useState<number | null>(() => {\n-    if (typeof window === 'undefined') return null;\n-    const stored = localStorage.getItem(STORAGE_KEYS.SELECTED_FRIEND);\n-    if (!stored) return null;\n-    const parsed = Number(stored);\n-    return Number.isFinite(parsed) ? parsed : null;\n-  });\n-  const [recentFriendIds, setRecentFriendIds] = useState<number[]>(() => {\n-    if (typeof window === 'undefined') return [];\n-    try {\n-      const stored = localStorage.getItem(STORAGE_KEYS.RECENT_FRIENDS);\n-      if (!stored) return [];\n-      const parsed = JSON.parse(stored);\n-      if (Array.isArray(parsed)) {\n-        return parsed.filter(id => typeof id === 'number');\n-      }\n-      return [];\n-    } catch {\n-      return [];\n-    }\n-  });\n-  const [isFriendPickerOpen, setIsFriendPickerOpen] = useState(false);\n-  const [friendSearchTerm, setFriendSearchTerm] = useState('');\n-  const [friendPictures, setFriendPictures] = useState<TimelinePicture[]>([]);\n-  const [, setLoadingFriends] = useState(false);\n-  const [friendLoadError, setFriendLoadError] = useState<string | null>(null);\n-  const [, setFriendTimelineError] = useState<string | null>(null);\n-  const [loadingFriendTimeline, setLoadingFriendTimeline] = useState(false);\n   const scrollContainerRef = useRef<HTMLDivElement | null>(null);\n-  const emptyTextMap = useMemo(() => new Map<string, string>(), []);\n-  const emptyFirstLineMap = useMemo(() => new Map<string, string>(), []);\n   const allTimelineDays = useMemo(() => generateTimelineDays(), []);\n-  const filteredFriends = useMemo(() => {\n-    const term = friendSearchTerm.trim().toLowerCase();\n-    if (!term) return friends;\n-    return friends.filter(friend =>\n-      friend.friend_name?.toLowerCase().includes(term) ||\n-      friend.friend_email?.toLowerCase().includes(term)\n-    );\n-  }, [friends, friendSearchTerm]);\n-  useEffect(() => {\n-    setRecentFriendIds(prev =>\n-      prev.filter(id => friends.some(friend => friend.friend_id === id))\n-    );\n-  }, [friends]);\n-\n-  // @@@ Reset friend selection when auth state changes (guests can't view friends)\n-  useEffect(() => {\n-    if (!isAuthenticated) {\n-      setSelectedFriendId(null);\n-      localStorage.removeItem(STORAGE_KEYS.SELECTED_FRIEND);\n-    }\n-  }, [isAuthenticated]);\n-  useEffect(() => {\n-    if (typeof window === 'undefined') return;\n-    localStorage.setItem(STORAGE_KEYS.RECENT_FRIENDS, JSON.stringify(recentFriendIds));\n-  }, [recentFriendIds]);\n-  const friendMap = useMemo(() => {\n-    const map = new Map<number, Friend>();\n-    friends.forEach(friend => map.set(friend.friend_id, friend));\n-    return map;\n-  }, [friends]);\n-  const orderedFriendIds = useMemo(() => {\n-    const recentValid = recentFriendIds.filter(id => friendMap.has(id));\n-    const prioritized = selectedFriendId && friendMap.has(selectedFriendId)\n-      ? [selectedFriendId, ...recentValid.filter(id => id !== selectedFriendId)]\n-      : [...recentValid];\n-\n-    if (prioritized.length < MAX_RECENT_FRIENDS) {\n-      for (const friend of friends) {\n-        if (!friendMap.has(friend.friend_id)) continue;\n-        if (!prioritized.includes(friend.friend_id)) {\n-          prioritized.push(friend.friend_id);\n-        }\n-        if (prioritized.length >= MAX_RECENT_FRIENDS) {\n-          break;\n-        }\n-      }\n-    }\n-\n-    return prioritized.slice(0, MAX_RECENT_FRIENDS);\n-  }, [recentFriendIds, selectedFriendId, friendMap, friends]);\n-  const selectedFriend = selectedFriendId ? friendMap.get(selectedFriendId) : null;\n-  const orderedRecentFriends = orderedFriendIds\n-    .map(id => friendMap.get(id))\n-    .filter((friend): friend is Friend => Boolean(friend));\n-  const friendTimelineByDate = useMemo(() => {\n-    const map = new Map<string, TimelineEntryData>();\n-    friendPictures.forEach(pic => {\n-      map.set(pic.date, { picture: pic, comments: [] });\n-    });\n-    return map;\n-  }, [friendPictures]);\n-  const friendHasVisibleCards = useMemo(() => {\n-    if (!selectedFriendId) return false;\n-    return allTimelineDays.some(day => Boolean(friendTimelineByDate.get(day.date)?.picture));\n-  }, [selectedFriendId, friendTimelineByDate, allTimelineDays]);\n-\n-  useEffect(() => {\n-    console.debug('[Timeline] friend hint state', {\n-      selectedFriendId,\n-      isFriendPickerOpen,\n-      friendPicturesCount: friendPictures.length,\n-      loadingFriendTimeline,\n-      visibleFriendCards: friendHasVisibleCards\n-    });\n-  }, [selectedFriendId, isFriendPickerOpen, friendPictures.length, loadingFriendTimeline, friendHasVisibleCards]);\n \n   useEffect(() => {\n     const loadTimelineData = async () => {\n-      // @@@ Load all comments grouped by date from database if authenticated, localStorage if guest\n       if (isAuthenticated) {\n         try {\n           const { listSessions, getSession } = await import('../api/voiceApi');\n@@ -586,15 +472,13 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n           console.error('Failed to load comments from database:', error);\n         }\n       } else {\n-        // Guest mode: load from localStorage\n         const savedState = localStorage.getItem(STORAGE_KEYS.EDITOR_STATE);\n         if (savedState) {\n           try {\n             const state = JSON.parse(savedState);\n             const starred = state.commentors?.filter((c: Commentor) => c.feedback === 'star') || [];\n             setStarredComments(starred);\n \n-            // For guest mode, all comments are from today\n             const today = formatDate(new Date(), dateLocale);\n             const allComments = state.commentors?.filter((c: Commentor) => c.appliedAt) || [];\n             const commentsByDate = new Map<string, Commentor[]>();\n@@ -629,26 +513,22 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n         }\n       }\n \n-      // @@@ Load pictures from database if authenticated\n       if (isAuthenticated) {\n         try {\n           const { getDailyPictures } = await import('../api/voiceApi');\n           const dbPictures = await getDailyPictures(30);\n-          // @@@ Backend returns ONLY thumbnails for fast loading (full images loaded on-demand)\n           const formattedPictures = dbPictures.map(p => ({\n             date: p.date,\n-            base64: p.base64,  // Thumbnail only\n+            base64: p.base64,\n             prompt: p.prompt || ''\n           }));\n           setPictures(formattedPictures);\n         } catch (error) {\n           console.error('Failed to load pictures from database:', error);\n-          // Fallback to localStorage\n           const savedPictures = localStorage.getItem(STORAGE_KEYS.DAILY_PICTURES);\n           if (savedPictures) {\n             try {\n               const parsed = JSON.parse(savedPictures);\n-              // @@@ Strip full_base64 from old cached data (keep only thumbnails)\n               const thumbnailsOnly = parsed.map((p: any) => ({\n                 date: p.date,\n                 base64: p.base64,\n@@ -661,12 +541,10 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n           }\n         }\n       } else {\n-        // Guest mode: load from localStorage\n         const savedPictures = localStorage.getItem(STORAGE_KEYS.DAILY_PICTURES);\n         if (savedPictures) {\n           try {\n             const parsed = JSON.parse(savedPictures);\n-            // @@@ Strip full_base64 from old cached data (keep only thumbnails)\n             const thumbnailsOnly = parsed.map((p: any) => ({\n               date: p.date,\n               base64: p.base64,\n@@ -682,155 +560,69 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n       setInitialLoading(false);\n     };\n \n-    const loadFriendsList = async () => {\n-      if (!isAuthenticated) {\n-        setFriends([]);\n-        setFriendLoadError(null);\n-        setFriendPictures([]);\n-        setSelectedFriendId(null);\n-        setFriendTimelineError(null);\n-        setLoadingFriendTimeline(false);\n-        setIsFriendPickerOpen(false);\n-        setFriendSearchTerm('');\n-        if (typeof window !== 'undefined') {\n-          localStorage.removeItem(STORAGE_KEYS.SELECTED_FRIEND);\n-        }\n-        return;\n-      }\n-\n-      setLoadingFriends(true);\n-      setFriendLoadError(null);\n-      try {\n-        const { getFriends } = await import('../api/voiceApi');\n-        const friendList = await getFriends();\n-        setFriends(friendList);\n-        setSelectedFriendId(prev => {\n-          if (!prev) return prev;\n-          const exists = friendList.some(friend => friend.friend_id === prev);\n-          if (!exists) {\n-            if (typeof window !== 'undefined') {\n-              localStorage.removeItem(STORAGE_KEYS.SELECTED_FRIEND);\n-            }\n-            return null;\n-          }\n-          return prev;\n-        });\n-      } catch (err) {\n-        console.error('Failed to load friends:', err);\n-        setFriendLoadError(err instanceof Error ? err.message : String(err));\n-      } finally {\n-        setLoadingFriends(false);\n-      }\n-    };\n-\n     loadTimelineData();\n-    loadFriendsList();\n   }, [isAuthenticated, timezone, dateLocale]);\n \n-  // @@@ Group items by date (using YYYY-MM-DD format to match timeline days)\n-  const timelineByDate = new Map<string, TimelineEntryData>();\n-\n-  starredComments.forEach(comment => {\n-    const commentDate = new Date(comment.appliedAt || comment.computedAt);\n-    const date = getLocalDateString(commentDate);  // Convert to YYYY-MM-DD\n-    if (!timelineByDate.has(date)) {\n-      timelineByDate.set(date, { comments: [] });\n-    }\n-    timelineByDate.get(date)!.comments.push(comment);\n-  });\n+  // @@@ Group items by date\n+  const timelineByDate = useMemo(() => {\n+    const map = new Map<string, TimelineEntryData>();\n \n-  pictures.forEach(pic => {\n-    const date = pic.date;  // Already in YYYY-MM-DD format from database\n-    if (!timelineByDate.has(date)) {\n-      timelineByDate.set(date, { comments: [] });\n-    }\n-    timelineByDate.get(date)!.picture = pic;\n-  });\n-  useEffect(() => {\n-    if (!isAuthenticated || !selectedFriendId) {\n-      setFriendPictures([]);\n-      setFriendTimelineError(null);\n-      setLoadingFriendTimeline(false);\n-      return;\n-    }\n+    starredComments.forEach(comment => {\n+      const commentDate = new Date(comment.appliedAt || comment.computedAt);\n+      const date = getLocalDateString(commentDate);\n+      if (!map.has(date)) {\n+        map.set(date, { comments: [] });\n+      }\n+      map.get(date)!.comments.push(comment);\n+    });\n \n-    let cancelled = false;\n-    const loadFriendTimeline = async () => {\n-      setLoadingFriendTimeline(true);\n-      setFriendTimelineError(null);\n-      try {\n-        const { getFriendTimeline } = await import('../api/voiceApi');\n-        const friendData = await getFriendTimeline(selectedFriendId, 30);\n-        const normalized: TimelinePicture[] = friendData.map((pic: any) => ({\n-          date: pic.date,\n-          base64: pic.base64,\n-          prompt: pic.prompt || '',\n-          full_base64: pic.full_base64\n-        }));\n-        if (!cancelled) {\n-          setFriendPictures(normalized);\n-        }\n-      } catch (err) {\n-        if (!cancelled) {\n-          console.error('Failed to load friend timeline:', err);\n-          setFriendTimelineError(err instanceof Error ? err.message : String(err));\n-          setFriendPictures([]);\n-        }\n-      } finally {\n-        if (!cancelled) {\n-          setLoadingFriendTimeline(false);\n-        }\n+    pictures.forEach(pic => {\n+      const date = pic.date;\n+      if (!map.has(date)) {\n+        map.set(date, { comments: [] });\n       }\n-    };\n+      map.get(date)!.picture = pic;\n+    });\n \n-    loadFriendTimeline();\n-    return () => {\n-      cancelled = true;\n-    };\n-  }, [isAuthenticated, selectedFriendId]);\n+    return map;\n+  }, [starredComments, pictures]);\n \n-  // @@@ Set initial scroll position to show today's row at top\n-  // Use useLayoutEffect to position BEFORE browser paints (prevents flash)\n+  // @@@ Set initial scroll position to show today's row centered\n   useLayoutEffect(() => {\n     if (!isVisible || initialLoading || !scrollContainerRef.current) return;\n \n     const container = scrollContainerRef.current;\n-    const todayIndex = allTimelineDays.findIndex(day => day.isToday);\n-    if (todayIndex === -1) return;\n+    const todayStr = getLocalDateString();\n \n     requestAnimationFrame(() => {\n       requestAnimationFrame(() => {\n-        const rows = container.querySelectorAll('[data-timeline-row]');\n-        const todayRow = rows[todayIndex] as HTMLElement | undefined;\n-        if (todayRow) {\n-          const containerRect = container.getBoundingClientRect();\n-          const todayRect = todayRow.getBoundingClientRect();\n-          const offset = todayRect.top - containerRect.top;\n-          const centerAdjustment = (container.clientHeight / 2) - (todayRect.height / 2);\n-          container.scrollTop += offset - centerAdjustment;\n+        const todayElement = container.querySelector(`[data-date=\"${todayStr}\"]`) as HTMLElement | null;\n+        if (todayElement) {\n+          const containerHeight = container.clientHeight;\n+          const elementTop = todayElement.offsetTop;\n+          const elementHeight = todayElement.offsetHeight;\n+          const scrollTarget = elementTop - (containerHeight / 2) + (elementHeight / 2);\n+          container.scrollTop = Math.max(0, scrollTarget);\n         }\n       });\n     });\n   }, [isVisible, initialLoading, allTimelineDays]);\n \n   // @@@ Reload comments for a specific date from backend\n   const reloadCommentsForDate = async (dateStr: string) => {\n-    // dateStr is in YYYY-MM-DD format\n     setLoadingCommentsForDate(dateStr);\n \n     try {\n       if (isAuthenticated) {\n         const { listSessions, getSession } = await import('../api/voiceApi');\n-        const sessions = await listSessions();\n+        const sessions = await listSessions(timezone);\n         const commentsForDate: Commentor[] = [];\n \n         for (const session of sessions) {\n-          // @@@ Get all comments from session and group by their appliedAt timestamp\n           try {\n             const fullSession = await getSession(session.id);\n             const comments = fullSession.editor_state?.commentors || [];\n \n-            // Filter comments that belong to this date (using appliedAt timestamp, not session created_at)\n             comments.filter((c: Commentor) => c.appliedAt).forEach((comment: Commentor) => {\n               const commentDate = new Date(comment.appliedAt || comment.computedAt);\n               const date = getLocalDateString(commentDate);\n@@ -843,7 +635,6 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n           }\n         }\n \n-        // Update allCommentsByDate for this specific date (using YYYY-MM-DD as key)\n         setAllCommentsByDate(prev => {\n           const next = new Map(prev);\n           next.set(dateStr, commentsForDate);\n@@ -858,19 +649,16 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n   };\n \n   const handleImageClick = async (picture: TimelinePicture) => {\n-    setViewingImage({ ...picture, origin: 'self' });\n+    setViewingImage({ ...picture });\n \n-    // Load full image on-demand if not already loaded\n     if (!picture.full_base64 && isAuthenticated) {\n       try {\n         const { getDailyPictureFull } = await import('../api/voiceApi');\n         const fullImage = await getDailyPictureFull(picture.date);\n \n-        // Update the picture object with full image\n-        const updatedPicture = { ...picture, full_base64: fullImage, origin: 'self' as const };\n+        const updatedPicture = { ...picture, full_base64: fullImage };\n         setViewingImage(updatedPicture);\n \n-        // Also update pictures array so we don't reload next time\n         setPictures(prev => prev.map(p =>\n           p.date === picture.date ? updatedPicture : p\n         ));\n@@ -882,59 +670,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n     await reloadCommentsForDate(picture.date);\n   };\n \n-  const handleFriendImageClick = async (picture: TimelinePicture) => {\n-    setViewingImage({ ...picture, origin: 'friend' });\n-\n-    if (!picture.full_base64 && selectedFriendId) {\n-      try {\n-        const { getFriendPictureFull } = await import('../api/voiceApi');\n-        const fullImage = await getFriendPictureFull(selectedFriendId, picture.date);\n-        const updatedPicture = { ...picture, full_base64: fullImage };\n-        setViewingImage({ ...updatedPicture, origin: 'friend' });\n-        setFriendPictures(prev => prev.map(p =>\n-          p.date === picture.date ? updatedPicture : p\n-        ));\n-      } catch (error) {\n-        console.error('Failed to load friend full image:', error);\n-      }\n-    }\n-  };\n-\n-  const handleFriendSelection = useCallback((friendId: number | null) => {\n-    setSelectedFriendId(friendId);\n-    if (typeof window !== 'undefined') {\n-      if (friendId) {\n-        localStorage.setItem(STORAGE_KEYS.SELECTED_FRIEND, String(friendId));\n-      } else {\n-        localStorage.removeItem(STORAGE_KEYS.SELECTED_FRIEND);\n-      }\n-    }\n-    if (friendId) {\n-      setRecentFriendIds(prev => {\n-        const without = prev.filter(id => id !== friendId);\n-        return [friendId, ...without].slice(0, MAX_RECENT_FRIENDS);\n-      });\n-    }\n-    setFriendSearchTerm('');\n-    setIsFriendPickerOpen(false);\n-  }, []);\n-\n-  useEffect(() => {\n-    if (friendToSelect === undefined || friendToSelect === null) {\n-      return;\n-    }\n-\n-    if (friendToSelect === selectedFriendId) {\n-      onFriendSelectionHandled?.();\n-      return;\n-    }\n-\n-    handleFriendSelection(friendToSelect);\n-    onFriendSelectionHandled?.();\n-  }, [friendToSelect, selectedFriendId, handleFriendSelection, onFriendSelectionHandled]);\n-\n   const handleGenerateForDate = async (dateStr: string) => {\n-    // @@@ Block image generation for guests\n     if (!isAuthenticated) {\n       alert('Please log in to generate images. Image generation requires authentication.');\n       return;\n@@ -944,29 +680,24 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n \n     try {\n       const { generateDailyPicture, saveDailyPicture } = await import('../api/voiceApi');\n-      const { image_base64, thumbnail_base64, prompt } = await generateDailyPicture(); // Backend uses DB text\n+      const { image_base64, thumbnail_base64, prompt } = await generateDailyPicture();\n \n       if (!image_base64) {\n         alert('No notes found to generate an image. Please write and save entries first.');\n         return;\n       }\n \n-      // @@@ Use the dateStr parameter passed from the clicked card (already in YYYY-MM-DD format)\n       const pictureDate = dateStr;\n \n       const newPicture = {\n-        date: pictureDate,  // @@@ Use date from clicked card\n-        base64: thumbnail_base64 || image_base64,  // @@@ Only thumbnail for fast timeline\n+        date: pictureDate,\n+        base64: thumbnail_base64 || image_base64,\n         prompt: prompt\n-        // @@@ NO full_base64 - it will be loaded on-demand when clicking\n       };\n \n-      // @@@ Save to database (requires auth)\n       await saveDailyPicture(pictureDate, image_base64, prompt, thumbnail_base64);\n \n-      // @@@ Update local state - remove old picture for this date if exists\n       const updated = pictures.filter(p => p.date !== pictureDate);\n-\n       updated.unshift(newPicture);\n       setPictures(updated);\n     } catch (error) {\n@@ -992,380 +723,98 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n         overflowY: 'auto',\n         display: 'flex',\n         flexDirection: 'column',\n-        alignItems: 'center'\n-      }}>\n-      <div style={{\n-        position: 'fixed',\n-        right: '1rem',\n-        top: '50%',\n-        transform: 'translateY(-50%)',\n-        display: 'flex',\n-        flexDirection: 'column',\n-        gap: '0.4rem',\n         alignItems: 'center',\n-        zIndex: 4,\n-        pointerEvents: isFriendPickerOpen ? 'none' : 'auto',\n-        opacity: isFriendPickerOpen ? 0.4 : 1\n+        padding: '1rem 0'\n       }}>\n-        <button\n-          onClick={() => handleFriendSelection(null)}\n-          style={{\n-            width: '42px',\n-            height: '42px',\n-            borderRadius: '21px',\n-            border: selectedFriendId === null ? '2px solid #2c2c2c' : '1px solid #d0c4b0',\n-            background: selectedFriendId === null ? '#2c2c2c' : '#fff',\n-            color: selectedFriendId === null ? '#fff' : '#4a433a',\n-            fontSize: '12px',\n-            fontWeight: 600,\n-            cursor: 'pointer'\n-          }}\n-          title={t('timeline.friendSelector.personal') || 'You'}\n-        >\n-          {t('timeline.friendSelector.personal') || 'Me'}\n-        </button>\n-        {orderedRecentFriends.map(friend => {\n-          const isActive = friend.friend_id === selectedFriendId;\n-          return (\n-            <button\n-              key={friend.friend_id}\n-              onClick={() => handleFriendSelection(friend.friend_id)}\n-              style={{\n-                width: '42px',\n-                height: '42px',\n-                borderRadius: '21px',\n-                border: isActive ? '2px solid #2c2c2c' : '1px solid #d0c4b0',\n-                background: isActive ? '#2c2c2c' : '#fff',\n-                color: isActive ? '#fff' : '#4a433a',\n-                fontSize: '13px',\n-                fontWeight: 600,\n-                cursor: 'pointer'\n-              }}\n-              title={friend.friend_name || friend.friend_email}\n-            >\n-              {getInitialLetter(friend.friend_name, getInitialLetter(friend.friend_email))}\n-            </button>\n-          );\n-        })}\n-        <button\n-          onClick={() => {\n-            setFriendSearchTerm('');\n-            setIsFriendPickerOpen(true);\n-          }}\n-          style={{\n-            width: '42px',\n-            height: '42px',\n-            borderRadius: '21px',\n-            border: '1px solid #d0c4b0',\n-            background: '#fff',\n-            color: '#4a433a',\n-            fontSize: '18px',\n-            cursor: 'pointer'\n-          }}\n-          title={t('timeline.friendSelector.more') || 'More'}\n-        >\n-          \u2026\n-        </button>\n-      </div>\n-\n-      {!selectedFriendId && !isFriendPickerOpen && (\n-        <div style={{\n-          position: 'fixed',\n-          right: '6.5rem',\n-          top: '50%',\n-          transform: 'translateY(-50%)',\n-          width: '260px',\n-          borderRadius: '16px',\n-          border: '1px solid #d0c4b0',\n-          background: '#fffefb',\n-          padding: '1.5rem',\n-          boxShadow: '0 20px 60px rgba(0,0,0,0.18)',\n-          zIndex: 3\n-        }}>\n-          <div style={{\n-            fontSize: '15px',\n-            fontWeight: 600,\n-            color: '#3d342a',\n-            marginBottom: '0.75rem'\n-          }}>\n-            {t('timeline.friendSelector.selfOnlyTitle') || 'Your private timeline'}\n-          </div>\n-          <div style={{\n-            fontSize: '13px',\n-            color: '#5c5145',\n-            lineHeight: 1.5\n-          }}>\n-            {t('timeline.friendSelector.selfOnlyHint') || 'Pick a friend from the badges on the right to compare timelines side by side.'}\n-          </div>\n-        </div>\n-      )}\n-\n-      {selectedFriendId && !isFriendPickerOpen && !loadingFriendTimeline && !friendHasVisibleCards && (\n-        <div style={{\n-          position: 'fixed',\n-          right: '6.5rem',\n-          top: '50%',\n-          transform: 'translateY(-50%)',\n-          width: '260px',\n-          borderRadius: '16px',\n-          border: '1px solid #d0c4b0',\n-          background: '#fffefb',\n-          padding: '1.5rem',\n-          boxShadow: '0 20px 60px rgba(0,0,0,0.18)',\n-          zIndex: 3\n-        }}>\n-          <div style={{\n-            fontSize: '15px',\n-            fontWeight: 600,\n-            color: '#3d342a',\n-            marginBottom: '0.75rem'\n-          }}>\n-            {t('timeline.friendSelector.friendEmptyTitle') || 'No friend timeline yet'}\n-          </div>\n-          <div style={{\n-            fontSize: '13px',\n-            color: '#5c5145',\n-            lineHeight: 1.5\n-          }}>\n-            {t('timeline.friendSelector.friendEmptyHint', { name: selectedFriend?.friend_name || '' }) || 'They have not shared anything for these days yet.'}\n-          </div>\n-        </div>\n-      )}\n-\n-      {isFriendPickerOpen && (\n+      {/* @@@ Alternating overlapping timeline - zigzag pattern */}\n+      <div\n+        style={{\n+          position: 'relative',\n+          maxWidth: '900px',\n+          width: '100%',\n+          padding: '2rem',\n+          paddingBottom: '5rem',\n+        }}\n+      >\n+        {/* Center line */}\n         <div\n           style={{\n-            position: 'fixed',\n-            inset: 0,\n-            background: 'rgba(0, 0, 0, 0.45)',\n-            display: 'flex',\n-            alignItems: 'center',\n-            justifyContent: 'center',\n-            zIndex: 20,\n-            padding: '2rem'\n+            position: 'absolute',\n+            left: '50%',\n+            top: '2rem',\n+            bottom: '5rem',\n+            width: '4px',\n+            background: 'linear-gradient(180deg, transparent 0%, #d0c4b0 2%, #d0c4b0 98%, transparent 100%)',\n+            transform: 'translateX(-50%)',\n+            zIndex: 1,\n           }}\n-          onClick={() => setIsFriendPickerOpen(false)}\n-        >\n-          <div\n-            style={{\n-              width: '100%',\n-              maxWidth: '420px',\n-              background: '#fff',\n-              borderRadius: '12px',\n-              border: '1px solid #d0c4b0',\n-              boxShadow: '0 12px 40px rgba(0,0,0,0.25)',\n-              padding: '1.5rem',\n-              display: 'flex',\n-              flexDirection: 'column',\n-              gap: '1rem'\n-            }}\n-            onClick={(e) => e.stopPropagation()}\n-          >\n-            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>\n-              <div style={{ fontSize: '15px', fontWeight: 600, color: '#2c2c2c' }}>\n-                {t('timeline.friendSelector.label')}\n-              </div>\n-              <button\n-                onClick={() => setIsFriendPickerOpen(false)}\n-                style={{\n-                  border: 'none',\n-                  background: 'transparent',\n-                  fontSize: '14px',\n-                  color: '#7a7060',\n-                  cursor: 'pointer'\n-                }}\n-              >\n-                {t('timeline.friendSelector.close')}\n-              </button>\n-            </div>\n-            {friendLoadError && (\n-              <div style={{ fontSize: '12px', color: '#b8562e' }}>\n-                {t('timeline.friendSelector.error')}\n-              </div>\n-            )}\n-            <input\n-              type=\"text\"\n-              value={friendSearchTerm}\n-              onChange={(e) => setFriendSearchTerm(e.target.value)}\n-              placeholder={t('timeline.friendSelector.searchPlaceholder') || 'Search'}\n-              style={{\n-                width: '100%',\n-                padding: '0.65rem 0.85rem',\n-                borderRadius: '8px',\n-                border: '1px solid #c7b9a4',\n-                background: '#fff',\n-                fontSize: '14px',\n-                boxSizing: 'border-box'\n-              }}\n-            />\n-            <div style={{ display: 'flex', gap: '0.5rem' }}>\n-              <button\n-                onClick={() => handleFriendSelection(null)}\n-                style={{\n-                  flex: 1,\n-                  border: selectedFriendId === null ? '1px solid #2c2c2c' : '1px solid #c7b9a4',\n-                  background: selectedFriendId === null ? '#f0e8de' : '#fff',\n-                  borderRadius: '8px',\n-                  padding: '0.6rem 0.75rem',\n-                  fontSize: '13px',\n-                  cursor: 'pointer',\n-                  color: '#2c2c2c',\n-                  fontWeight: 600\n-                }}\n-              >\n-                {t('timeline.friendSelector.none')}\n-              </button>\n-            </div>\n-            <div style={{ maxHeight: '260px', overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>\n-              {friends.length === 0 && (\n-                <div style={{ fontSize: '13px', color: '#7a7060' }}>\n-                  {t('timeline.friendSelector.noFriends')}\n-                </div>\n-              )}\n-              {friends.length > 0 && filteredFriends.length === 0 && (\n-                <div style={{ fontSize: '13px', color: '#7a7060' }}>\n-                  {t('timeline.friendSelector.noMatches')}\n-                </div>\n-              )}\n-              {filteredFriends.map((friend) => {\n-                const isSelected = friend.friend_id === selectedFriendId;\n-                return (\n-                  <button\n-                    key={friend.friend_id}\n-                    onClick={() => handleFriendSelection(friend.friend_id)}\n-                    style={{\n-                      border: isSelected ? '1px solid #2c2c2c' : '1px solid #d0c4b0',\n-                      borderRadius: '8px',\n-                      padding: '0.65rem 0.9rem',\n-                      textAlign: 'left',\n-                      cursor: 'pointer',\n-                      background: isSelected ? '#f0e8de' : '#fff'\n-                    }}\n-                  >\n-                    <div style={{ fontWeight: 600, fontSize: '14px', color: '#2c2c2c' }}>\n-                      {friend.friend_name}\n-                    </div>\n-                    <div style={{ fontSize: '12px', color: '#7a7060' }}>\n-                      {friend.friend_email}\n-                    </div>\n-                  </button>\n-                );\n-              })}\n-            </div>\n-          </div>\n-        </div>\n-      )}\n+        />\n \n-      {/* @@@ Vertical scrolling timeline - rows stacked */}\n-      <div style={{\n-        display: 'flex',\n-        flexDirection: 'column',\n-        gap: '1.5rem',\n-        maxWidth: '1200px',\n-        width: '100%',\n-        padding: '0 2rem',\n-        paddingBottom: '5rem'  // @@@ Prevent bottom card cutoff\n-      }}>\n+        {/* Cards */}\n         {allTimelineDays.map((day, index) => {\n           const dayData = timelineByDate.get(day.date);\n-          const friendDayData = friendTimelineByDate.get(day.date);\n           const hasData = !!dayData;\n-          const hasFriendData = !!friendDayData;\n           const isGenerating = generatingForDate === day.date;\n           const placeholder = getPlaceholderText(t, day.daysOffset);\n-          const showFriendSide = Boolean(selectedFriendId);\n+          const isLeftSide = index % 2 === 0;\n+\n+          // Each card occupies a \"slot\" but overlaps with neighbors\n+          // Slot height = CARD_HEIGHT - CARD_OVERLAP (the non-overlapping portion)\n+          const slotHeight = CARD_HEIGHT - CARD_OVERLAP;\n+          const topPosition = index * slotHeight;\n \n           return (\n             <div\n-              data-timeline-row\n               key={day.date}\n+              data-date={day.date}\n               style={{\n-                position: 'relative',\n-                display: 'flex',\n-                alignItems: 'center',\n-                justifyContent: 'center',\n-                gap: '1.5rem',\n-                padding: '0 2rem'\n-              }}>\n-              <div style={{\n-                flex: '1',\n-                display: 'flex',\n-                justifyContent: 'flex-end',\n-                paddingRight: '2rem'\n-              }}>\n-                {renderTimelineCard({\n-                  day,\n-                  dayData,\n-                  hasData,\n-                  isGenerating,\n-                  onImageClick: handleImageClick,\n-                  onGenerate: handleGenerateForDate,\n-                  textByDate,\n-                  firstLineByDate,\n-                  t,\n-                  dateLocale,\n-                  placeholder\n-                })}\n-              </div>\n-\n-              {/* Center node */}\n-              <div style={{\n                 position: 'absolute',\n-                left: '50%',\n-                top: '50%',\n-                transform: 'translate(-50%, -50%)',\n-                width: '20px',\n-                height: '20px',\n-                borderRadius: '50%',\n-                background: (hasData || hasFriendData) ? '#4CAF50' : (day.isToday ? '#888' : '#ddd'),\n-                border: '3px solid #f8f0e6',\n-                boxShadow: '0 2px 8px rgba(0,0,0,0.15)',\n-                zIndex: 2,\n-                pointerEvents: 'none'\n-              }} />\n-\n-              {index < allTimelineDays.length - 1 && (\n-                <div style={{\n+                top: `${topPosition + 32}px`, // 32px accounts for padding\n+                left: isLeftSide ? '2rem' : '50%',\n+                right: isLeftSide ? '50%' : '2rem',\n+                paddingRight: isLeftSide ? '24px' : '0',\n+                paddingLeft: isLeftSide ? '0' : '24px',\n+                height: `${CARD_HEIGHT}px`,\n+                zIndex: allTimelineDays.length - index, // Stack order for overlapping\n+              }}\n+            >\n+              {/* Timeline dot */}\n+              <div\n+                style={{\n                   position: 'absolute',\n-                  left: 'calc(50% - 1.5px)',\n                   top: '50%',\n-                  height: 'calc(100% + 1.5rem)',\n-                  width: '3px',\n-                  background: '#d0c4b0',\n-                  zIndex: 1\n-                }} />\n-              )}\n-\n-              <div style={{\n-                flex: '1',\n-                display: 'flex',\n-                justifyContent: 'flex-start',\n-                paddingLeft: '2rem'\n-              }}>\n-                {showFriendSide && friendDayData?.picture ? (\n-                  renderTimelineCard({\n-                    day,\n-                    dayData: friendDayData,\n-                    hasData: true,\n-                    isGenerating: false,\n-                    onImageClick: handleFriendImageClick,\n-                    textByDate: emptyTextMap,\n-                    firstLineByDate: emptyFirstLineMap,\n-                    t,\n-                    dateLocale,\n-                    placeholder,\n-                    readOnly: true,\n-                    customDescription: friendDayData.picture.prompt\n-                      ? getTextPreview(friendDayData.picture.prompt, 80)\n-                      : placeholder\n-                  })\n-                ) : (\n-                  <div style={{ width: '80px', height: '80px' }} />\n-                )}\n-              </div>\n+                  [isLeftSide ? 'right' : 'left']: '-10px',\n+                  transform: 'translateY(-50%)',\n+                  width: '14px',\n+                  height: '14px',\n+                  borderRadius: '50%',\n+                  background: hasData ? '#4CAF50' : (day.isToday ? '#666' : '#ddd'),\n+                  border: '3px solid #f8f0e6',\n+                  boxShadow: '0 2px 6px rgba(0,0,0,0.15)',\n+                  zIndex: 10,\n+                }}\n+              />\n+            \n+              <TimelineCard\n+                day={day}\n+                dayData={dayData}\n+                hasData={hasData}\n+                isGenerating={isGenerating}\n+                placeholder={placeholder}\n+                textByDate={textByDate}\n+                firstLineByDate={firstLineByDate}\n+                dateLocale={dateLocale}\n+                t={t}\n+                onImageClick={handleImageClick}\n+                onGenerate={handleGenerateForDate}\n+                side={isLeftSide ? 'left' : 'right'}\n+              />\n             </div>\n           );\n         })}\n+\n+        {/* Spacer to ensure container has correct height */}\n+        <div style={{ height: `${(allTimelineDays.length - 1) * (CARD_HEIGHT - CARD_OVERLAP) + CARD_HEIGHT + 32}px` }} />\n       </div>\n \n       {/* Image Lightbox Modal */}\n@@ -1498,11 +947,8 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n                   boxSizing: 'border-box'\n                 }}>\n                   {(() => {\n-                    // @@@ Priority filtering: starred \u2192 chatted \u2192 last \u2192 none\n-                    // Use raw YYYY-MM-DD format to match Map keys\n                     const imageDate = viewingImage.date;\n \n-                    // Show loading state while fetching comments\n                     if (loadingCommentsForDate === imageDate) {\n                       return (\n                         <div style={{\n@@ -1521,21 +967,17 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n \n                     let commentsToDisplay: Commentor[] = [];\n \n-                    // Priority 1: Starred comments\n                     const starredForDate = allCommentsForDate.filter(c => c.feedback === 'star');\n                     if (starredForDate.length > 0) {\n                       commentsToDisplay = starredForDate;\n                     } else {\n-                      // Priority 2: One chatted comment (has chatHistory)\n                       const chattedComments = allCommentsForDate.filter(c => c.chatHistory && c.chatHistory.length > 0);\n                       if (chattedComments.length > 0) {\n-                        // Take the most recent chatted comment\n                         const mostRecentChatted = chattedComments.sort((a, b) =>\n                           (b.appliedAt || b.computedAt) - (a.appliedAt || a.computedAt)\n                         )[0];\n                         commentsToDisplay = [mostRecentChatted];\n                       } else {\n-                        // Priority 3: Last comment (by timestamp)\n                         if (allCommentsForDate.length > 0) {\n                           const lastComment = allCommentsForDate.sort((a, b) =>\n                             (b.appliedAt || b.computedAt) - (a.appliedAt || a.computedAt)\n@@ -1546,47 +988,6 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n                     }\n \n                     if (commentsToDisplay.length === 0) {\n-                      if (viewingImage.origin === 'friend' && viewingImage.prompt) {\n-                        return (\n-                          <div style={{\n-                            display: 'flex',\n-                            flexDirection: 'column',\n-                            gap: '1rem'\n-                          }}>\n-                            <div\n-                              style={{\n-                                background: '#fff',\n-                                border: '1px solid #e0d8cc',\n-                                borderRadius: '8px',\n-                                padding: '1rem'\n-                              }}\n-                            >\n-                              <div style={{\n-                                display: 'flex',\n-                                alignItems: 'center',\n-                                gap: '0.5rem',\n-                                marginBottom: '0.75rem'\n-                              }}>\n-                                <span style={{ fontSize: '18px' }}>\ud83d\udc65</span>\n-                                <span style={{ fontWeight: 600, fontSize: '14px', color: '#333' }}>\n-                                  {t('timeline.friendTimeline.readOnlyShort')}\n-                                </span>\n-                              </div>\n-                              <div style={{\n-                                fontSize: '13px',\n-                                color: '#555',\n-                                lineHeight: '1.7',\n-                                paddingLeft: '0.5rem',\n-                                wordBreak: 'break-word',\n-                                whiteSpace: 'pre-wrap'\n-                              }}>\n-                                {viewingImage.prompt}\n-                              </div>\n-                            </div>\n-                          </div>\n-                        );\n-                      }\n-\n                       return (\n                         <div style={{\n                           textAlign: 'center',\n@@ -1694,9 +1095,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF\n                 color: '#888'\n               }}>\n                 {(() => {\n-                  const commentCount = viewingImage.origin === 'friend'\n-                    ? (viewingImage.prompt ? 1 : 0)\n-                    : (timelineByDate.get(viewingImage.date)?.comments?.length || 0);\n+                  const commentCount = timelineByDate.get(viewingImage.date)?.comments?.length || 0;\n                   return t('timeline.entryCount', { count: commentCount });\n                 })()}\n               </div>"
    }
  ]
}