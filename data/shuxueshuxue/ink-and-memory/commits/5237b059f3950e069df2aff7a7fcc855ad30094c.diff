*** FILE: backend/database.py ***
@@ -146,6 +146,9 @@ def create_tables(db):
       enabled BOOLEAN DEFAULT 1,
       has_local_changes BOOLEAN DEFAULT 0,
       order_index INTEGER,
+      published BOOLEAN DEFAULT 0,
+      author_name TEXT,
+      install_count INTEGER DEFAULT 0,
       created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
       updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
       FOREIGN KEY (parent_id) REFERENCES decks(id),
@@ -154,6 +157,20 @@ def create_tables(db):
     """)
     db.execute("CREATE INDEX IF NOT EXISTS idx_decks_owner ON decks(owner_id)")
 
+    # @@@ Migration: Add publishing columns to existing decks table
+    try:
+        db.execute("ALTER TABLE decks ADD COLUMN published BOOLEAN DEFAULT 0")
+    except:
+        pass  # Column already exists
+    try:
+        db.execute("ALTER TABLE decks ADD COLUMN author_name TEXT")
+    except:
+        pass
+    try:
+        db.execute("ALTER TABLE decks ADD COLUMN install_count INTEGER DEFAULT 0")
+    except:
+        pass
+
     # @@@ Voices table - individual voice personas within decks
     db.execute("""
     CREATE TABLE IF NOT EXISTS voices (
@@ -312,6 +329,78 @@ def get_user_decks(user_id: int):
     finally:
         db.close()
 
+def get_published_decks():
+    """
+    Get all published decks (community deck store).
+    Returns list of deck dicts with voice counts and author info.
+    """
+    db = get_db()
+    try:
+        rows = db.execute("""
+        SELECT d.*, COUNT(v.id) as voice_count, u.display_name as author_display_name
+        FROM decks d
+        LEFT JOIN voices v ON d.id = v.deck_id AND v.enabled = 1
+        LEFT JOIN users u ON d.owner_id = u.id
+        WHERE d.published = 1
+        GROUP BY d.id
+        ORDER BY d.install_count DESC, d.created_at DESC
+        """).fetchall()
+        return [dict(row) for row in rows]
+    finally:
+        db.close()
+
+def publish_deck(deck_id: str, user_id: int):
+    """
+    Publish a deck to community store.
+    @@@ Breaks parent chain - published deck becomes standalone
+    """
+    db = get_db()
+    try:
+        # Get user's display name for author_name
+        user = db.execute("SELECT display_name FROM users WHERE id = ?", (user_id,)).fetchone()
+        author_name = user['display_name'] if user and user['display_name'] else f"User {user_id}"
+
+        db.execute("""
+        UPDATE decks
+        SET published = 1,
+            author_name = ?,
+            parent_id = NULL
+        WHERE id = ? AND owner_id = ?
+        """, (author_name, deck_id, user_id))
+        db.commit()
+    finally:
+        db.close()
+
+def unpublish_deck(deck_id: str, user_id: int):
+    """
+    Unpublish a deck from community store.
+    """
+    db = get_db()
+    try:
+        db.execute("""
+        UPDATE decks
+        SET published = 0
+        WHERE id = ? AND owner_id = ?
+        """, (deck_id, user_id))
+        db.commit()
+    finally:
+        db.close()
+
+def increment_deck_install_count(deck_id: str):
+    """
+    Increment install counter when deck is forked from store.
+    """
+    db = get_db()
+    try:
+        db.execute("""
+        UPDATE decks
+        SET install_count = install_count + 1
+        WHERE id = ?
+        """, (deck_id,))
+        db.commit()
+    finally:
+        db.close()
+
 def get_deck_with_voices(user_id: int, deck_id: str):
     """
     Get full deck details with all voices.

*** FILE: backend/server.py ***
@@ -1328,10 +1328,15 @@ class VoiceForkRequest(BaseModel):
     target_deck_id: str
 
 @app.get("/api/decks")
-def list_decks(current_user: dict = Depends(get_current_user)):
-    """Get all decks visible to user (system + user's own)"""
-    user_id = current_user['user_id']
-    decks = database.get_user_decks(user_id)
+def list_decks(published: bool = False, current_user: dict = Depends(get_current_user)):
+    """Get decks - either user's own or published community decks"""
+    if published:
+        # Get all published decks (community store)
+        decks = database.get_published_decks()
+    else:
+        # Get user's own decks
+        user_id = current_user['user_id']
+        decks = database.get_user_decks(user_id)
     return {"decks": decks}
 
 @app.get("/api/decks/{deck_id}")
@@ -1384,14 +1389,39 @@ def delete_deck(deck_id: str, current_user: dict = Depends(get_current_user)):
 
 @app.post("/api/decks/{deck_id}/fork")
 def fork_deck(deck_id: str, current_user: dict = Depends(get_current_user)):
-    """Fork a deck (usually system deck) to create user's own copy"""
+    """Fork a deck (system or published community deck) to create user's own copy"""
     user_id = current_user['user_id']
     try:
         new_deck_id = database.fork_deck(user_id, deck_id)
+        # @@@ Increment install count if forking from published deck
+        database.increment_deck_install_count(deck_id)
         return {"deck_id": new_deck_id}
     except ValueError as e:
         raise HTTPException(status_code=404, detail=str(e))
 
+@app.post("/api/decks/{deck_id}/publish")
+def publish_deck(deck_id: str, current_user: dict = Depends(get_current_user)):
+    """
+    Publish/unpublish a deck to community store.
+    @@@ Warning: Publishing breaks parent_id chain (deck becomes standalone)
+    """
+    user_id = current_user['user_id']
+    try:
+        # Check if deck is currently published
+        deck = database.get_deck_with_voices(user_id, deck_id)
+        if not deck:
+            raise HTTPException(status_code=404, detail="Deck not found or not owned by user")
+
+        # Toggle published status
+        if deck.get('published'):
+            database.unpublish_deck(deck_id, user_id)
+            return {"success": True, "published": False}
+        else:
+            database.publish_deck(deck_id, user_id)
+            return {"success": True, "published": True}
+    except Exception as e:
+        raise HTTPException(status_code=500, detail=str(e))
+
 @app.post("/api/decks/{deck_id}/sync")
 def sync_deck(deck_id: str, current_user: dict = Depends(get_current_user)):
     """Sync user's forked deck with parent template (force overwrites local changes)"""

*** FILE: frontend/src/api/voiceApi.ts ***
@@ -626,8 +626,12 @@ export async function markFirstLoginCompleted(): Promise<void> {
 /**
  * List all decks (includes system decks + user's own decks)
  */
-export async function listDecks(): Promise<Deck[]> {
-  const response = await fetch(`${API_BASE}/api/decks`, {
+export async function listDecks(published?: boolean): Promise<Deck[]> {
+  const url = published
+    ? `${API_BASE}/api/decks?published=true`
+    : `${API_BASE}/api/decks`;
+
+  const response = await fetch(url, {
     headers: getAuthHeaders()
   });
 
@@ -759,6 +763,24 @@ export async function syncDeck(deckId: string): Promise<{ success: boolean; sync
   return await response.json();
 }
 
+/**
+ * Publish/unpublish a deck to community store
+ * @@@ Warning: Publishing breaks parent_id chain (deck becomes standalone)
+ */
+export async function publishDeck(deckId: string): Promise<{ success: boolean; published: boolean }> {
+  const response = await fetch(`${API_BASE}/api/decks/${deckId}/publish`, {
+    method: 'POST',
+    headers: getAuthHeaders()
+  });
+
+  if (!response.ok) {
+    const error = await response.json();
+    throw new Error(error.detail || 'Publish deck failed');
+  }
+
+  return await response.json();
+}
+
 /**
  * Create a new voice in a deck
  */
