*** FILE: backend/server.py ***
@@ -55,21 +55,41 @@ def get_writing_suggestion(text: str, user_id: int, meta_prompt: str = "", state
     system_prompt = f"""You are {voice_info['name']}, an inner voice persona.
 Your role: {voice_info.get('systemPrompt', '')}
 
-Read the user's writing and offer a brief, inspiring comment to help them continue.
-Be encouraging, insightful, or thought-provoking (1-2 sentences).
-Speak in the voice's characteristic style."""
+Read what the user just wrote and offer a VERY SHORT, gentle nudge about what to write next.
+
+IMPORTANT STYLE:
+- Keep it EXTREMELY brief (1 short sentence, max 15 words)
+- Be warm, conversational, and friendly
+- Focus on inspiration and possibility, not criticism
+- Suggest what to explore next, don't analyze what was written
+- Use casual, everyday language
+- Think: "What if you..." or "Maybe explore..." or "How about..."
+
+DO NOT:
+- Analyze or critique their writing
+- Summarize what they wrote
+- Give formal feedback
+- Be verbose or explanatory
+
+Examples of GOOD suggestions:
+- "What if you describe how that made you feel?"
+- "Maybe explore what happened next?"
+- "I'm curious about the details..."
+- "How did that moment change things?"
+
+Speak in {voice_info['name']}'s characteristic style, but keep it brief and inspiring."""
 
     if state_prompt:
-        system_prompt += f"\n\nContext: {state_prompt}"
+        system_prompt += f"\n\nEmotional context: {state_prompt}"
 
     if meta_prompt:
-        system_prompt += f"\n\nStyle guide: {meta_prompt}"
+        system_prompt += f"\n\nWriter's style: {meta_prompt}"
 
-    user_prompt = f"""The user wrote:
+    user_prompt = f"""The user just wrote:
 
 {text}
 
-Offer a brief, inspiring comment to help them continue writing (1-2 sentences)."""
+Give them ONE very short, gentle nudge about what to write next (max 15 words)."""
 
     # Generate inspiration
     print(f"üì§ Calling agent.run() with model='claude-haiku-4.5'...")
@@ -415,25 +435,62 @@ def generate_daily_picture(all_notes: str, user_id: int):
 
     import requests
 
+    # @@@ Fetch recent prompts to avoid duplication
+    recent_prompts_text = ""
+    try:
+        db = database.get_db()
+        recent_prompts = db.execute(
+            "SELECT prompt FROM daily_pictures WHERE user_id = ? ORDER BY date DESC LIMIT 5",
+            (user_id,)
+        ).fetchall()
+        db.close()
+
+        if recent_prompts:
+            recent_prompts_list = [p[0] for p in recent_prompts if p[0]]
+            if recent_prompts_list:
+                recent_prompts_text = "\n\nPREVIOUS IMAGE DESCRIPTIONS (do NOT repeat these themes/settings/objects):\n"
+                for i, prompt in enumerate(recent_prompts_list, 1):
+                    recent_prompts_text += f"{i}. {prompt}\n"
+                recent_prompts_text += "\n‚ö†Ô∏è IMPORTANT: Create something COMPLETELY DIFFERENT from all previous descriptions above!\n"
+                recent_prompts_text += "‚ö†Ô∏è Use different: setting, objects, style, mood, time of day, colors, composition.\n"
+                recent_prompts_text += "‚ö†Ô∏è Be creative and avoid repetition!\n"
+                print(f"üìã Found {len(recent_prompts_list)} recent prompts to avoid duplication")
+    except Exception as e:
+        print(f"‚ö†Ô∏è Could not fetch recent prompts: {e}")
+
     # Step 1: Convert notes to artistic image description using Claude Haiku
-    description_prompt = f"""Read these personal notes and create a warm, gentle image description that captures the emotional essence.
+    description_prompt = f"""Read these personal notes and create a MINIMAL, SIMPLE image description.
 
 Notes:
 ---
 {all_notes}
 ---
-
-Create a simple, heartfelt image description (2-3 sentences) that:
-- Captures the emotional warmth and human feeling
-- Uses natural, everyday imagery (avoid abstract or technical concepts)
-- Specifies style: oil painting, photograph, or vintage stamp art
-- Describes soft colors, natural lighting, simple composition
-
-Be warm and minimal. Focus on human emotion and simple beauty.
-Avoid: technical terms, complex metaphors, digital aesthetics.
-Favor: warmth, intimacy, natural scenes, gentle moments.
-
-Return ONLY the image description, no other text."""
+{recent_prompts_text}
+Create an EXTREMELY SIMPLE image description (1-2 sentences):
+- ONE single object or element only (e.g., "a bird", "edge of a house", "a leaf")
+- Clean white or simple solid color background
+- Simple lines, minimal details
+- Soft, gentle colors
+- Style: simple line drawing, watercolor, or minimalist illustration
+
+IMPORTANT RULES:
+- Maximum 1-2 objects in the entire image
+- No complex scenes, no multiple elements
+- No detailed backgrounds
+- Think: "one bird on white background" or "corner of a window, white space"
+- Embrace empty space and simplicity
+
+Examples of GOOD descriptions:
+- "A single sparrow perched, simple brushstrokes, white background"
+- "Corner of a window frame, soft blue, minimal details"
+- "One maple leaf, watercolor, pale background"
+
+Examples of BAD descriptions (TOO COMPLEX):
+- "A desk with notebook, tea cup, lamp, and books" ‚ùå
+- "A room with furniture and decorations" ‚ùå
+- "Multiple objects or detailed scene" ‚ùå
+
+Return ONLY the minimal image description, no other text."""
 
     print("üß† Creating image description from notes with Claude Haiku...")
 

*** FILE: frontend/src/components/CollectionsView.tsx ***
@@ -168,6 +168,34 @@ function getPlaceholderText(daysOffset: number): string {
   return placeholders[daysOffset.toString()] || (daysOffset < 0 ? 'what was has passed' : 'yet to be written');
 }
 
+// @@@ Extract and truncate beginning of text for timeline preview
+function getTextPreview(text: string, maxLength: number = 60): string {
+  if (!text || text.trim().length === 0) return '';
+
+  // Remove extra whitespace
+  const cleaned = text.trim().replace(/\s+/g, ' ');
+
+  // Find first sentence ending
+  const sentenceEndings = /[.!?„ÄÇÔºÅÔºü]/;
+  const match = cleaned.match(sentenceEndings);
+
+  let preview = '';
+  if (match && match.index !== undefined && match.index < maxLength * 1.5) {
+    // Use first sentence if it's not too long
+    preview = cleaned.substring(0, match.index + 1);
+  } else {
+    // Otherwise use first N characters
+    preview = cleaned.substring(0, maxLength);
+  }
+
+  // Truncate if still too long
+  if (preview.length > maxLength) {
+    preview = preview.substring(0, maxLength).trim() + '...';
+  }
+
+  return preview;
+}
+
 // @@@ Get all notes from all sessions (localStorage for guest, database for authenticated)
 async function getAllNotesFromSessions(isAuthenticated: boolean): Promise<string> {
   const allText: string[] = [];
@@ -228,6 +256,7 @@ function TimelinePage({ isVisible, voiceConfigs }: { isVisible: boolean; voiceCo
   const { isAuthenticated } = useAuth();
   const [starredComments, setStarredComments] = useState<Commentor[]>([]);
   const [allCommentsByDate, setAllCommentsByDate] = useState<Map<string, Commentor[]>>(new Map());
+  const [textByDate, setTextByDate] = useState<Map<string, string>>(new Map());
   const [pictures, setPictures] = useState<Array<{ date: string; base64: string; full_base64?: string; prompt: string }>>([]);
   const [generatingForDate, setGeneratingForDate] = useState<string | null>(null);
   const [viewingImage, setViewingImage] = useState<{ base64: string; full_base64?: string; prompt: string; date: string } | null>(null);
@@ -244,6 +273,7 @@ function TimelinePage({ isVisible, voiceConfigs }: { isVisible: boolean; voiceCo
           const sessions = await listSessions();
           const allStarred: Commentor[] = [];
           const commentsByDate = new Map<string, Commentor[]>();
+          const textByDateMap = new Map<string, string>();
 
           for (const session of sessions) {
             try {
@@ -264,13 +294,30 @@ function TimelinePage({ isVisible, voiceConfigs }: { isVisible: boolean; voiceCo
                 }
                 commentsByDate.get(date)!.push(comment);
               });
+
+              // @@@ Extract text from session and group by creation date
+              if (fullSession.editor_state?.createdAt && fullSession.editor_state?.cells) {
+                const sessionDate = fullSession.editor_state.createdAt; // Already in YYYY-MM-DD format
+                const text = fullSession.editor_state.cells
+                  .filter((c: any) => c.type === 'text')
+                  .map((c: any) => c.content)
+                  .join(' ')
+                  .trim();
+
+                if (text) {
+                  // Append text for this date (sessions can have multiple entries per day)
+                  const existingText = textByDateMap.get(sessionDate) || '';
+                  textByDateMap.set(sessionDate, existingText ? `${existingText} ${text}` : text);
+                }
+              }
             } catch (err) {
               console.error(`Failed to load session ${session.id}:`, err);
             }
           }
 
           setStarredComments(allStarred);
           setAllCommentsByDate(commentsByDate);
+          setTextByDate(textByDateMap);
         } catch (error) {
           console.error('Failed to load comments from database:', error);
         }
@@ -699,9 +746,11 @@ function TimelinePage({ isVisible, voiceConfigs }: { isVisible: boolean; voiceCo
                   <div style={{
                     fontSize: '13px',
                     color: '#888',
-                    fontStyle: 'italic'
+                    fontStyle: textByDate.get(day.date) ? 'normal' : 'italic'
                   }}>
                     {isGenerating ? 'Generating...' :
+                     textByDate.get(day.date) ?
+                       getTextPreview(textByDate.get(day.date)!) :
                      dayData?.comments?.length ?
                        `${dayData.comments.length} ${dayData.comments.length === 1 ? 'entry' : 'entries'}` :
                        getPlaceholderText(day.daysOffset)}
