*** FILE: .gitignore ***
@@ -0,0 +1,13 @@
+# Python
+backend/.venv/
+backend/models.json
+backend/.polycache/
+__pycache__/
+*.pyc
+
+# Node
+frontend/node_modules/
+
+# IDE
+.vscode/
+.idea/

*** FILE: backend/analyzer.py ***
@@ -0,0 +1,59 @@
+#!/usr/bin/env python3
+"""Voice detection analyzer using LLM-powered pattern matching."""
+
+from pathlib import Path
+from pydantic import BaseModel, Field
+from polycli import PolyAgent
+from polycli.orchestration import pattern
+import config
+
+# Structured output schema
+class VoiceTrigger(BaseModel):
+    phrase: str = Field(description="Exact trigger phrase from text (verbatim)")
+    voice: str = Field(description="Voice archetype name from the available list")
+    comment: str = Field(description="What this voice is saying (as if speaking)")
+    icon: str = Field(description="Icon: brain, heart, question, cloud")
+    color: str = Field(description="Color: blue, pink, yellow, green, purple")
+
+class VoiceAnalysis(BaseModel):
+    voices: list[VoiceTrigger] = Field(description="Detected voice triggers")
+
+@pattern
+def analyze_voices(agent: PolyAgent, text: str) -> list[dict]:
+    """
+    Analyze text and detect inner voice triggers.
+
+    Args:
+        agent: PolyAgent instance
+        text: Text to analyze
+
+    Returns:
+        List of voice trigger dicts
+    """
+    if len(text.strip()) < config.MIN_TEXT_LENGTH:
+        return []
+
+    # Build voice list for prompt
+    voice_list = "\n".join([
+        f"- {name} ({v['icon']}, {v['color']}): {v['tagline']}"
+        for name, v in config.VOICE_ARCHETYPES.items()
+    ])
+
+    prompt = config.ANALYSIS_PROMPT_TEMPLATE.format(
+        text=text,
+        voice_list=voice_list,
+        max_voices=config.MAX_VOICES
+    )
+
+    result = agent.run(
+        prompt,
+        model=config.MODEL,
+        cli="no-tools",
+        schema_cls=VoiceAnalysis,
+        tracked=True
+    )
+
+    if not result.is_success or not result.has_data():
+        return []
+
+    return result.data.get("voices", [])

*** FILE: backend/archive/vibe-coding-scraper-example/README.md ***
@@ -0,0 +1,66 @@
+# Vibe-Coding Web Scraper Example
+
+## The Process
+
+This documents a real example of "vibe-coding" - rapid iterative development through observe-code-observe-code cycles.
+
+### The Goal
+Scrape 24 Disco Elysium skill pages to extract personality descriptions for inner voice archetypes.
+
+### The Wrong Way (Initial Attempt)
+```
+‚ùå Write complete scraper without looking at target
+‚ùå Add complex parsing logic upfront
+‚ùå Over-engineer before testing
+```
+
+### The Right Way (Vibe-Coding)
+```
+‚úÖ Look at page structure first (WebFetch on Logic page)
+‚úÖ Look at another page to confirm pattern (Inland Empire)
+‚úÖ Write minimal scraper
+‚úÖ Run and observe
+‚úÖ Iterate if needed
+```
+
+### Key Lesson
+
+**"You are just wasting time. Correct scraping workflow is observe-code-observe-code... you are coding too much without even look at the target page's structure"**
+
+The vibe-coding approach:
+1. Observe (fetch a sample page)
+2. Code (minimal scraper)
+3. Observe (run it, see results)
+4. Code (adjust if needed)
+
+Fast iteration beats perfect planning.
+
+### The Conversation Flow
+
+1. **User**: "let's digress to scrape the corresponding pages for each of these skills to form an easy-to-use reference folder"
+
+2. **Assistant** (wrong): Writes complex scraper without looking at pages first
+
+3. **User** (intervention): "you are just wasting time. correct scraping workflow is observe-code-observe-code..."
+
+4. **Assistant** (corrected): Uses WebFetch to check Logic page structure
+
+5. **User** (intervention again): "why look at so much?"
+
+6. **Assistant** (finally right): Minimal scraper, just run it
+
+7. **Result**: Working scraper in ~20 lines that collected all 24 skills
+
+### Time Saved
+- Wrong approach: Would have taken 30+ minutes of debugging
+- Vibe-coding: Done in 5 minutes
+
+### Code
+See `scraper.py` for the minimal working implementation.
+
+### Results
+See `disco_skills.json` for the scraped data (24 skills with descriptions).
+
+---
+
+**Takeaway**: When scraping, don't overthink. Look once, code minimal, run fast.

*** FILE: backend/archive/vibe-coding-scraper-example/disco_skills.json ***
@@ -0,0 +1,98 @@
+{
+  "Logic": {
+    "name": "Logic",
+    "description": "Logic\n\n\n\n\n\n\nDetails\n\nAttribute\nIntellect\n\n\n\nNavigation\n\nNext Skill\nEncyclopedia\n\n\n\nLogic is a skill under the Intellect attribute in Disco Elysium.\n\nWield raw intellectual power. Deduce the world.\n\nCool for: Analysts, Pure Rationalists, Obviously Logicians."
+  },
+  "Encyclopedia": {
+    "name": "Encyclopedia",
+    "description": "Encyclopedia\n\n\n\n\n\n\nDetails\n\nAttribute\nIntellect\n\n\n\nNavigation\n\nPrevious Skill\nLogic\n\n\nNext Skill\nRhetoric\n\n\n\nEncyclopedia is a skill under the Intellect attribute in Disco Elysium.\n\nCall upon all your knowledge. Produce fascinating trivia.\n\nCool for: Thinkers, Historians, Trivia Freaks"
+  },
+  "Rhetoric": {
+    "name": "Rhetoric",
+    "description": "Rhetoric\n\n\n\n\n\n\nDetails\n\nAttribute\nIntellect\n\n\n\nNavigation\n\nPrevious Skill\nEncyclopedia\n\n\nNext Skill\nDrama\n\n\n\nRhetoric is a skill under the Intellect attribute in Disco Elysium.\n\nPractice the art of persuasion. Enjoy rigorous intellectual discourse.\n\nCool for: Ideologues, Conversationalists, Would-Be-Politicians"
+  },
+  "Drama": {
+    "name": "Drama",
+    "description": "Drama\n\n\n\n\n\n\nDetails\n\nAttribute\nIntellect\n\n\n\nNavigation\n\nPrevious Skill\nRhetoric\n\n\nNext Skill\nConceptualization\n\n\n\nDrama is a skill under the Intellect attribute in Disco Elysium.\n\nPlay the actor. Lie and detect lies.\n\nCool for: Undercover Cops, Thespians of the Stage, Psychopaths"
+  },
+  "Conceptualization": {
+    "name": "Conceptualization",
+    "description": "Conceptualization\n\n\n\n\n\n\nDetails\n\nAttribute\nIntellect\n\n\n\nNavigation\n\nPrevious Skill\nDrama\n\n\nNext Skill\nVisual Calculus\n\n\n\nConceptualization is a skill under the Intellect attribute in Disco Elysium.\n\nUnderstand creativity. See Art in the world.\n\nCool for: Creatives, Psychedelic Fanciers, Critics."
+  },
+  "Visual_Calculus": {
+    "name": "Visual Calculus",
+    "description": "Visual Calculus\n\n\n\n\n\n\nDetails\n\nAttribute\nIntellect\n\n\n\nNavigation\n\nPrevious Skill\nConceptualization\n\n\n\nVisual Calculus is a skill under the Intellect attribute in Disco Elysium.\n\nReconstruct crime scenes. Make laws of physics work for the Law.\n\nCool for: Forensics Scientists, Tactical Fighters, Math-Minded People"
+  },
+  "Volition": {
+    "name": "Volition",
+    "description": "Volition\n\n\n\n\n\n\nDetails\n\nAttribute\nPsyche\n\n\n\nNavigation\n\nNext Skill\nInland Empire\n\n\n\nVolition is a skill under the Psyche attribute in Disco Elysium.\n\nHold yourself together. Keep your Morale up.\n\nCool for: Sane People, Well-Adjusted Cops, The Non-Suicidal"
+  },
+  "Inland_Empire": {
+    "name": "Inland Empire",
+    "description": "Inland Empire\n\n\n\n\n\n\nDetails\n\nAttribute\nPsyche\n\n\n\nNavigation\n\nPrevious Skill\nVolition\n\n\nNext Skill\nEmpathy\n\n\n\nInland Empire is a skill under the Psyche attribute in Disco Elysium.\n\nHunches and gut feelings. Dreams in waking life.\n\nCool for: Dreamers, Para-Natural Investigators, Mental Creators"
+  },
+  "Empathy": {
+    "name": "Empathy",
+    "description": "Empathy\n\n\n\n\n\n\nDetails\n\nAttribute\nPsyche\n\n\n\nNavigation\n\nPrevious Skill\nInland Empire\n\n\nNext Skill\nAuthority\n\n\n\nEmpathy is a skill under the Psyche attribute in Disco Elysium.\n\nUnderstand others. Work your mirror neurons.\n\nCool for: Judges of Character, Interviewers, Interrogators"
+  },
+  "Authority": {
+    "name": "Authority",
+    "description": "Authority\n\n\n\n\n\n\nDetails\n\nAttribute\nPsyche\n\n\n\nNavigation\n\nPrevious Skill\nEmpathy\n\n\nNext Skill\nEsprit de Corps\n\n\n\nAuthority is a skill under the Psyche attribute in Disco Elysium.\n\nIntimidate the public. Assert yourself.\n\nCool for: Leaders, Experts of Psychological Warfare, Respect-Junkies"
+  },
+  "Esprit_de_Corps": {
+    "name": "Esprit de Corps",
+    "description": "Esprit de Corps\n\n\n\n\n\n\nDetails\n\nAttribute\nPsyche\n\n\n\nNavigation\n\nPrevious Skill\nAuthority\n\n\nNext Skill\nSuggestion\n\n\n\nEsprit de Corps is a skill under the Psyche attribute in Disco Elysium.\n\nConnect to Station 41. Understand cop culture.\n\nCool for: Cops, Cop-Aficionados, Pretend-Cops"
+  },
+  "Suggestion": {
+    "name": "Suggestion",
+    "description": "Suggestion\n\n\n\n\n\n\nDetails\n\nAttribute\nPsyche\n\n\n\nNavigation\n\nPrevious Skill\nEsprit de Corps\n\n\n\nSuggestion is a skill under the Psyche attribute in Disco Elysium.\n\nCharm men and women. Play the puppet-master.\n\nCool for: Diplomats, Charmers, Sociopaths"
+  },
+  "Endurance": {
+    "name": "Endurance",
+    "description": "Endurance\n\n\n\n\n\n\nDetails\n\nAttribute\nPhysique\n\n\n\nNavigation\n\nNext Skill\nPain Threshold\n\n\n\nEndurance is a skill under the Physique attribute in Disco Elysium.\n\nTake the blows. Don‚Äôt let the world kill you.\n\nCool for: Fighters who can take a hit, Lookouts who don‚Äôt sleep, Human Batteries"
+  },
+  "Pain_Threshold": {
+    "name": "Pain Threshold",
+    "description": "Pain Threshold\n\n\n\n\n\n\nDetails\n\nAttribute\nPhysique\n\n\n\nNavigation\n\nPrevious Skill\nEndurance\n\n\nNext Skill\nPhysical Instrument\n\n\n\nPain Threshold is a skill under the Physique attribute in Disco Elysium.\n\nShrug off the pain. They‚Äôll have to hurt you more.\n\nCool for: Unstoppable Fighters, Guys who don‚Äôt die, Masochists"
+  },
+  "Physical_Instrument": {
+    "name": "Physical Instrument",
+    "description": "Physical Instrument\n\n\n\n\n\n\nDetails\n\nAttribute\nPhysique\n\n\n\nNavigation\n\nPrevious Skill\nPain Threshold\n\n\nNext Skill\nElectrochemistry\n\n\n\nPhysical Instrument is a skill under the Physique attribute in Disco Elysium.\n\nFlex powerful muscles. Enjoy healthy organs.\n\nCool for: Muscle Men, Bare Knuckle Brawlers, Gym Teachers"
+  },
+  "Electrochemistry": {
+    "name": "Electrochemistry",
+    "description": "Electrochemistry\n\n\n\n\n\n\nDetails\n\nAttribute\nPhysique\n\n\n\nNavigation\n\nPrevious Skill\nPhysical Instrument\n\n\nNext Skill\nShivers\n\n\n\nElectrochemistry is a skill under the Physique attribute in Disco Elysium.\n\nGo to party planet. Love and be loved by drugs.\n\nCool for: High-Fliers, Party Enthusiasts, Cops who need Lightning"
+  },
+  "Shivers": {
+    "name": "Shivers",
+    "description": "Shivers\n\n\n\n\n\n\nDetails\n\nAttribute\nPhysique\n\n\n\nNavigation\n\nPrevious Skill\nElectrochemistry\n\n\nNext Skill\nHalf Light\n\n\n\nShivers is a skill under the Physique attribute in Disco Elysium.\n\nRaise the hair on your neck. Tune in to the city.\n\nCool for: City Lovers, The Wisest of the Street Wise, The Genuinely Supra-Natural"
+  },
+  "Half_Light": {
+    "name": "Half Light",
+    "description": "Half Light\n\n\n\n\n\n\nDetails\n\nAttribute\nPhysique\n\n\n\nNavigation\n\nPrevious Skill\nShivers\n\n\n\nHalf Light is a skill under the Physique attribute in Disco Elysium.\n\nLet the body take control. Threaten people.\n\nCool for: High-Strung Investigators, Shoot-Now-Ask-Questions-Later Cops, Surprise Haters"
+  },
+  "Hand-Eye_Coordination": {
+    "name": "Hand-Eye Coordination",
+    "description": "Hand-Eye Coordination\n\n\n\n\n\n\nDetails\n\nAttribute\nMotorics\n\n\n\nNavigation\n\nNext Skill\nPerception\n\n\n\nHand/Eye Coordination is a skill under the Motorics attribute in Disco Elysium.\n\nReady? Aim and fire.\n\nCool for: Trick-Shooters, Snipers, Jugglers"
+  },
+  "Perception": {
+    "name": "Perception",
+    "description": "Perception\n\n\n\n\n\n\nDetails\n\nAttribute\nMotorics\n\n\n\nNavigation\n\nPrevious Skill\nHand/Eye Coordination\n\n\nNext Skill\nReaction Speed\n\n\n\nPerception is a skill under the Motorics attribute in Disco Elysium.\n\nSee, hear and smell everything. Let no detail go unnoticed.\n\nCool for: Fine Detail Detectives, Sensualists, Urban Scavengers"
+  },
+  "Reaction_Speed": {
+    "name": "Reaction Speed",
+    "description": "Reaction Speed\n\n\n\n\n\n\nDetails\n\nAttribute\nMotorics\n\n\n\nNavigation\n\nPrevious Skill\nPerception\n\n\nNext Skill\nSavoir Faire\n\n\n\nReaction Speed is a skill under the Motorics attribute in Disco Elysium.\n\nThe quickest to react. An untouchable man.\n\nCool for: Shot-Dodgers, Thinkers on their Feet, Pinball-Heads"
+  },
+  "Savoir_Faire": {
+    "name": "Savoir Faire",
+    "description": "Savoir Faire\n\n\n\n\n\n\nDetails\n\nAttribute\nMotorics\n\n\n\nNavigation\n\nPrevious Skill\nReaction Speed\n\n\nNext Skill\nInterfacing\n\n\n\nSavoir Faire is a skill under the Motorics attribute in Disco Elysium.\n\nSneak under their noses. Stun with immense panache.\n\nCool for: Acrobats, Thieves, Unbearable Show-Offs"
+  },
+  "Interfacing": {
+    "name": "Interfacing",
+    "description": "Interfacing\n\n\n\n\n\n\nDetails\n\nAttribute\nMotorics\n\n\n\nNavigation\n\nPrevious Skill\nSavoir Faire\n\n\nNext Skill\nComposure\n\n\n\nInterfacing is a skill under the Motorics attribute in Disco Elysium.\n\nMaster machines. Pick locks and pockets.\n\nCool for: Machinists, Tinkerers, Instrument Players"
+  },
+  "Composure": {
+    "name": "Composure",
+    "description": "Composure\n\n\n\n\n\n\nDetails\n\nAttribute\nMotorics\n\n\n\nNavigation\n\nPrevious Skill\nInterfacing\n\n\n\nComposure is a skill under the Motorics attribute in Disco Elysium.\n\nStraighten your back. Keep your poker face.\n\nCool for: Card Players, Military Fetishists, Cool People"
+  }
+}
\ No newline at end of file

*** FILE: backend/archive/vibe-coding-scraper-example/scraper.py ***
@@ -0,0 +1,43 @@
+#!/usr/bin/env python3
+"""Scrape Disco Elysium skill pages."""
+
+import requests
+from bs4 import BeautifulSoup
+from pathlib import Path
+import json
+import time
+
+SKILLS = [
+    "Logic", "Encyclopedia", "Rhetoric", "Drama", "Conceptualization", "Visual_Calculus",
+    "Volition", "Inland_Empire", "Empathy", "Authority", "Esprit_de_Corps", "Suggestion",
+    "Endurance", "Pain_Threshold", "Physical_Instrument", "Electrochemistry", "Shivers", "Half_Light",
+    "Hand-Eye_Coordination", "Perception", "Reaction_Speed", "Savoir_Faire", "Interfacing", "Composure"
+]
+
+OUTPUT_DIR = Path(__file__).parent / "references"
+
+def scrape_skill(skill_name: str) -> dict:
+    url = f"https://discoelysium.fandom.com/wiki/{skill_name}"
+    response = requests.get(url, timeout=10)
+    soup = BeautifulSoup(response.text, 'html.parser')
+
+    content = soup.find('div', {'class': 'mw-parser-output'})
+    paragraphs = [p.get_text().strip() for p in content.find_all('p') if p.get_text().strip()]
+
+    return {
+        "name": skill_name.replace('_', ' '),
+        "description": '\n\n'.join(paragraphs[:3])
+    }
+
+OUTPUT_DIR.mkdir(exist_ok=True)
+skills_data = {}
+
+for skill in SKILLS:
+    print(f"Scraping {skill}...")
+    skills_data[skill] = scrape_skill(skill)
+    time.sleep(0.5)
+
+with open(OUTPUT_DIR / "disco_skills.json", 'w', encoding='utf-8') as f:
+    json.dump(skills_data, f, indent=2, ensure_ascii=False)
+
+print(f"\n‚úÖ Done")

*** FILE: backend/config.py ***
@@ -0,0 +1,102 @@
+"""Voice archetypes configuration - inspired by Disco Elysium."""
+
+# Model to use for voice analysis
+MODEL = "gpt-4o-dou"
+
+# @@@ Sparsity control
+MAX_VOICES = 5
+MIN_TEXT_LENGTH = 20
+
+# Voice archetypes (Disco Elysium skills adapted for general writing)
+VOICE_ARCHETYPES = {
+    "Logic": {
+        "tagline": "Wield raw intellectual power. Deduce the world.",
+        "icon": "brain",
+        "color": "blue"
+    },
+    "Rhetoric": {
+        "tagline": "Practice the art of persuasion. Enjoy rigorous intellectual discourse.",
+        "icon": "brain",
+        "color": "purple"
+    },
+    "Drama": {
+        "tagline": "Play the actor. Lie and detect lies.",
+        "icon": "question",
+        "color": "pink"
+    },
+    "Conceptualization": {
+        "tagline": "Understand creativity. See Art in the world.",
+        "icon": "cloud",
+        "color": "purple"
+    },
+    "Volition": {
+        "tagline": "Hold yourself together. Keep your Morale up.",
+        "icon": "brain",
+        "color": "green"
+    },
+    "Inland Empire": {
+        "tagline": "Hunches and gut feelings. Dreams in waking life.",
+        "icon": "cloud",
+        "color": "purple"
+    },
+    "Empathy": {
+        "tagline": "Understand others. Work your mirror neurons.",
+        "icon": "heart",
+        "color": "pink"
+    },
+    "Authority": {
+        "tagline": "Intimidate the public. Assert yourself.",
+        "icon": "brain",
+        "color": "yellow"
+    },
+    "Electrochemistry": {
+        "tagline": "Go to party planet. Love and be loved by drugs.",
+        "icon": "heart",
+        "color": "pink"
+    },
+    "Shivers": {
+        "tagline": "Raise the hair on your neck. Tune in to the city.",
+        "icon": "cloud",
+        "color": "blue"
+    },
+    "Half Light": {
+        "tagline": "Let the body take control. Threaten people.",
+        "icon": "question",
+        "color": "yellow"
+    },
+    "Perception": {
+        "tagline": "See, hear and smell everything. Let no detail go unnoticed.",
+        "icon": "brain",
+        "color": "green"
+    },
+    "Composure": {
+        "tagline": "Straighten your back. Keep your poker face.",
+        "icon": "brain",
+        "color": "blue"
+    }
+}
+
+# @@@ Analysis prompt for LLM
+ANALYSIS_PROMPT_TEMPLATE = """You are analyzing internal dialogue using the voice system from Disco Elysium.
+
+In Disco Elysium, thoughts manifest as distinct inner voices - each representing a cognitive skill with its own personality and perspective. These voices interrupt, comment on, and debate each other as the protagonist thinks.
+
+Analyze this text and identify which voices are speaking:
+
+"{text}"
+
+Available voice archetypes:
+{voice_list}
+
+For each voice you detect:
+1. Extract the EXACT phrase that triggered it (word-for-word from the text)
+2. Choose the matching voice archetype
+3. Write what this voice is saying (as if the voice itself is speaking)
+4. Use the voice's designated icon and color
+
+IMPORTANT:
+- Maximum {max_voices} voices
+- Only identify clearly present voices
+- Phrase must be verbatim from text
+- Each voice should be distinct
+"""

*** FILE: backend/server.py ***
@@ -0,0 +1,75 @@
+#!/usr/bin/env python3
+"""Voice analysis server using PolyCLI Session Registry."""
+
+import time
+from polycli.orchestration.session_registry import session_def, get_registry
+from polycli import PolyAgent
+from stateful_analyzer import analyze_stateful
+
+@session_def(
+    name="Analyze Voices",
+    description="Detect inner voices in text using Disco Elysium archetypes",
+    params={"text": str},
+    category="Analysis"
+)
+def analyze_text(text: str):
+    """
+    Analyze text and detect inner voice triggers.
+
+    Args:
+        text: Text to analyze
+
+    Returns:
+        Dictionary with voices array and status
+    """
+    print(f"\n{'='*60}")
+    print(f"üéØ analyze_text() called")
+    print(f"   Text length: {len(text)}")
+    print(f"   Text preview: {text[:100]}...")
+    print(f"{'='*60}\n")
+
+    print("Creating PolyAgent...")
+    agent = PolyAgent(id="voice-analyzer")
+
+    print("Calling analyze_stateful pattern...")
+    voices = analyze_stateful(agent, text)
+
+    print(f"‚úÖ Got {len(voices)} voices")
+    for i, v in enumerate(voices):
+        print(f"   {i+1}. {v.get('voice', 'unknown')}: {v.get('comment', '')[:50]}...")
+
+    result = {
+        "voices": voices,
+        "status": "completed",
+        "text_length": len(text)
+    }
+
+    print(f"Returning result: {result}")
+    print(f"{'='*60}\n")
+
+    return result
+
+if __name__ == "__main__":
+    # Get the global registry (session auto-registered via decorator)
+    registry = get_registry()
+
+    # Start the control panel
+    print("\n" + "="*60)
+    print("üé≠ Voice Analysis Server")
+    print("="*60)
+    registry.serve_control_panel(port=8765)
+
+    print("\nüìö Available endpoints:")
+    print("  - POST /api/trigger")
+    print("    Body: {\"session_id\": \"analyze_text\", \"params\": {\"text\": \"...\"}}")
+    print("  - GET /api/sessions (list all sessions)")
+    print("  - GET /api/running (list running sessions)")
+    print("  - GET /api/status/{exec_id} (get session status)")
+    print("\n" + "="*60 + "\n")
+
+    # Keep server running
+    try:
+        while True:
+            time.sleep(1)
+    except KeyboardInterrupt:
+        print("\n\nüëã Shutting down...")

*** FILE: backend/stateful_analyzer.py ***
@@ -0,0 +1,239 @@
+#!/usr/bin/env python3
+"""Stateful voice analyzer that tracks comments across continuous writing."""
+
+from pathlib import Path
+from pydantic import BaseModel, Field
+from polycli import PolyAgent
+from polycli.orchestration import pattern
+import config
+import re
+
+class VoiceTrigger(BaseModel):
+    phrase: str = Field(description="Exact trigger phrase from text (verbatim)")
+    voice: str = Field(description="Voice archetype name from the available list")
+    comment: str = Field(description="What this voice is saying (as if speaking)")
+    icon: str = Field(description="Icon: brain, heart, question, cloud")
+    color: str = Field(description="Color: blue, pink, yellow, green, purple")
+
+class VoiceAnalysis(BaseModel):
+    voices: list[VoiceTrigger] = Field(description="Detected voice triggers")
+
+class StatefulVoiceAnalyzer:
+    """
+    Stateful analyzer that:
+    1. Tracks existing comments
+    2. Prunes comments when trigger text is deleted
+    3. Only asks LLM for new comments
+    4. Enforces density rules (1 per persona, 1 per sentence)
+    """
+
+    def __init__(self):
+        self.comments = []  # List of dicts: {phrase, voice, comment, icon, color}
+        self.last_text = ""
+
+    def _prune_deleted_comments(self, text: str):
+        """Remove comments whose trigger phrases no longer exist in text."""
+        self.comments = [
+            c for c in self.comments
+            if c["phrase"].lower() in text.lower()
+        ]
+
+    def _get_sentences(self, text: str) -> list[str]:
+        """Split text into sentences (supports English and Chinese)."""
+        # @@@ multilingual-sentence-split - English: .!? Chinese: „ÄÇÔºÅÔºü
+        # Also treat newlines as sentence boundaries
+        sentences = re.split(r'[.!?„ÄÇÔºÅÔºü]+|\n+', text)
+        return [s.strip() for s in sentences if s.strip()]
+
+    def _get_commented_regions(self, text: str) -> list[tuple[int, int]]:
+        """Get character ranges that already have comments."""
+        regions = []
+        for comment in self.comments:
+            phrase = comment["phrase"]
+            # Find all occurrences (case-insensitive)
+            text_lower = text.lower()
+            phrase_lower = phrase.lower()
+            start = 0
+            while True:
+                pos = text_lower.find(phrase_lower, start)
+                if pos == -1:
+                    break
+                regions.append((pos, pos + len(phrase)))
+                start = pos + 1
+        return regions
+
+    def _enforce_density(self, new_comments: list[dict], text: str) -> list[dict]:
+        """
+        Enforce density rules:
+        1. Max 1 comment per persona across whole text
+        2. Max 1 persona per sentence
+        """
+        # Get sentence boundaries
+        sentences = self._get_sentences(text)
+        sentence_positions = []
+        pos = 0
+        for sent in sentences:
+            start = text.lower().find(sent.lower(), pos)
+            if start != -1:
+                sentence_positions.append((start, start + len(sent), sent))
+                pos = start + len(sent)
+
+        # Track which personas are already used
+        used_personas = {c["voice"] for c in self.comments}
+
+        # Track which sentences have comments
+        sentence_has_comment = [False] * len(sentence_positions)
+        for comment in self.comments:
+            phrase_pos = text.lower().find(comment["phrase"].lower())
+            if phrase_pos != -1:
+                for i, (start, end, _) in enumerate(sentence_positions):
+                    if start <= phrase_pos < end:
+                        sentence_has_comment[i] = True
+                        break
+
+        # Filter new comments
+        filtered = []
+        for comment in new_comments:
+            voice = comment["voice"]
+            phrase = comment["phrase"]
+
+            # Rule 1: Only 1 comment per persona
+            if voice in used_personas:
+                continue
+
+            # Rule 2: Only 1 comment per sentence
+            phrase_pos = text.lower().find(phrase.lower())
+            if phrase_pos == -1:
+                continue
+
+            # Find which sentence this belongs to
+            comment_sentence_idx = None
+            for i, (start, end, _) in enumerate(sentence_positions):
+                if start <= phrase_pos < end:
+                    comment_sentence_idx = i
+                    break
+
+            if comment_sentence_idx is not None and sentence_has_comment[comment_sentence_idx]:
+                continue
+
+            # Accept this comment
+            filtered.append(comment)
+            used_personas.add(voice)
+            if comment_sentence_idx is not None:
+                sentence_has_comment[comment_sentence_idx] = True
+
+        return filtered
+
+    @pattern
+    def analyze(self, agent: PolyAgent, text: str) -> list[dict]:
+        """
+        Analyze text and return ALL comments (existing + new).
+
+        Args:
+            agent: PolyAgent instance
+            text: Current text
+
+        Returns:
+            Complete list of all comments
+        """
+        print(f"\n{'='*60}")
+        print(f"üìä Stateful Analysis")
+        print(f"   Text length: {len(text)}")
+        print(f"   Existing comments: {len(self.comments)}")
+        print(f"{'='*60}\n")
+
+        # Step 1: Prune deleted comments
+        old_count = len(self.comments)
+        self._prune_deleted_comments(text)
+        if len(self.comments) < old_count:
+            print(f"üóëÔ∏è  Pruned {old_count - len(self.comments)} deleted comments")
+
+        # Step 2: Check if we need new analysis
+        if len(text.strip()) < config.MIN_TEXT_LENGTH:
+            print("‚è≠Ô∏è  Text too short, returning existing comments")
+            return self.comments
+
+        # Check if text changed significantly
+        text_diff = abs(len(text) - len(self.last_text))
+        if text_diff < 10 and self.comments:
+            print(f"‚è≠Ô∏è  Text change too small ({text_diff} chars), returning existing")
+            return self.comments
+
+        # Step 3: Build prompt with existing comments
+        voice_list = "\n".join([
+            f"- {name} ({v['icon']}, {v['color']}): {v['tagline']}"
+            for name, v in config.VOICE_ARCHETYPES.items()
+        ])
+
+        existing_summary = ""
+        if self.comments:
+            existing_summary = "\n\nEXISTING COMMENTS (do NOT repeat these):\n"
+            for c in self.comments:
+                existing_summary += f"- {c['voice']} on \"{c['phrase']}\": {c['comment']}\n"
+
+        prompt = f"""You are analyzing internal dialogue using the voice system from Disco Elysium.
+
+In Disco Elysium, thoughts manifest as distinct inner voices - each representing a cognitive skill with its own personality and perspective. These voices interrupt, comment on, and debate each other as the protagonist thinks.
+
+Analyze this text and identify NEW voices that want to comment:
+
+"{text}"
+
+Available voice archetypes:
+{voice_list}
+{existing_summary}
+
+For each NEW voice you detect:
+1. Extract the EXACT phrase that triggered it (word-for-word from the text)
+2. Choose the matching voice archetype
+3. Write what this voice is saying (as if the voice itself is speaking)
+4. Use the voice's designated icon and color
+
+IMPORTANT:
+- Maximum {config.MAX_VOICES} NEW voices
+- Only identify clearly present voices
+- Phrase must be verbatim from text
+- Each voice should be distinct
+- DO NOT comment on parts that already have comments
+- Avoid commenting too close to existing comments
+- DO NOT comment on the last sentence if it appears incomplete (no ending punctuation like .!?„ÄÇÔºÅÔºü)
+- Write comments in the SAME LANGUAGE as the text being analyzed (if text is Chinese, respond in Chinese; if English, respond in English)
+"""
+
+        print("ü§ñ Calling LLM for new comments...")
+        result = agent.run(
+            prompt,
+            model=config.MODEL,
+            cli="no-tools",
+            schema_cls=VoiceAnalysis,
+            tracked=True
+        )
+
+        if not result.is_success or not result.has_data():
+            print("‚ùå LLM failed, returning existing comments")
+            return self.comments
+
+        new_voices = result.data.get("voices", [])
+        print(f"‚úÖ LLM returned {len(new_voices)} new comments")
+
+        # Step 4: Enforce density rules
+        filtered_voices = self._enforce_density(new_voices, text)
+        print(f"üìè After density filter: {len(filtered_voices)} comments")
+
+        # Step 5: Merge with existing comments
+        self.comments.extend(filtered_voices)
+        self.last_text = text
+
+        print(f"üìù Total comments: {len(self.comments)}")
+        for i, c in enumerate(self.comments):
+            print(f"   {i+1}. {c['voice']}: \"{c['phrase'][:30]}...\"")
+        print(f"{'='*60}\n")
+
+        return self.comments
+
+# Global instance (shared across all session calls)
+global_analyzer = StatefulVoiceAnalyzer()
+
+def analyze_stateful(agent: PolyAgent, text: str) -> list[dict]:
+    """Wrapper function that uses global analyzer instance."""
+    return global_analyzer.analyze(agent, text)

*** FILE: backend/test_text.txt ***
@@ -0,0 +1 @@
+I think we should refactor this code. The structure is a mess, and I can feel the technical debt piling up. But what if we break something? The tests might not catch everything. My gut says there's a deeper problem here, something we're not seeing. Maybe we should just ship it as-is and move on. No, that's not right. We need to do this properly, even if it takes longer. I remember the last time we rushed - it came back to haunt us. The architecture could be beautiful if we just took the time to think it through. But deadlines are breathing down our neck. Is this even worth it? We're just going in circles now.
\ No newline at end of file

*** FILE: frontend/src/App.css ***
@@ -121,31 +121,6 @@
   margin-left: 1.75rem;
 }
 
-.voice-comment-logic {
-  background-color: #e6f2ff;
-  border-color: #4d9fff;
-}
-
-.voice-comment-emotion {
-  background-color: #ffe6f2;
-  border-color: #ff66b3;
-}
-
-.voice-comment-doubt {
-  background-color: #fffbe6;
-  border-color: #ffdd33;
-}
-
-.voice-comment-memory {
-  background-color: #e6ffe6;
-  border-color: #66ff66;
-}
-
-.voice-comment-nostalgia {
-  background-color: #f3e6ff;
-  border-color: #b366ff;
-}
-
 @keyframes fadeIn {
   from {
     opacity: 0;

*** FILE: frontend/src/App.tsx ***
@@ -1,96 +1,101 @@
-import { useState, useEffect } from 'react'
+import { useState, useEffect, useRef } from 'react'
 import './App.css'
 import WritingArea from './components/WritingArea'
 import VoicesPanel from './components/VoicesPanel'
 import VoiceComment from './components/VoiceComment'
 import BinderRings from './components/BinderRings'
-import { VOICE_TRIGGERS, MEMORY_VOICE } from './config/voices'
 import type { VoiceTrigger } from './extensions/VoiceHighlight'
+import { analyzeText } from './api/voiceApi'
 
 interface Voice {
   name: string;
   text: string;
   icon: string;
+  color: string;
   position: number;
 }
 
 function App() {
   const [voices, setVoices] = useState<Voice[]>([]);
-  const [voiceTriggers, setVoiceTriggers] = useState<VoiceTrigger[]>(VOICE_TRIGGERS);
+  const [voiceTriggers, setVoiceTriggers] = useState<VoiceTrigger[]>([]);
   const [currentText, setCurrentText] = useState<string>('');
+  const currentTextRef = useRef<string>('');
+  const lastAnalyzedTextRef = useRef<string>('');
+  const isAnalyzingRef = useRef<boolean>(false);
 
   const detectVoices = (text: string, triggers: VoiceTrigger[]) => {
     const newVoices: Voice[] = [];
     const lowerText = text.toLowerCase();
 
-    triggers.forEach(({ phrase, voice, comment, icon }) => {
-      const index = lowerText.indexOf(phrase);
+    triggers.forEach(({ phrase, voice, comment, icon, color }) => {
+      const index = lowerText.indexOf(phrase.toLowerCase());
       if (index !== -1) {
-        newVoices.push({ name: voice, text: comment, icon, position: index });
+        newVoices.push({ name: voice, text: comment, icon, color, position: index });
       }
     });
 
-    if (text.length > MEMORY_VOICE.minLength && !newVoices.find(v => v.name === MEMORY_VOICE.voice)) {
-      newVoices.push({ name: MEMORY_VOICE.voice, text: MEMORY_VOICE.comment, icon: MEMORY_VOICE.icon, position: Infinity });
-    }
-
     // Sort by position in text
     newVoices.sort((a, b) => a.position - b.position);
 
     setVoices(newVoices);
   };
 
-  const handleTextChange = (newText: string) => {
-    setCurrentText(newText);
-    detectVoices(newText, voiceTriggers);
-  };
+  const analyzeIfNeeded = async () => {
+    // Skip if already analyzing
+    if (isAnalyzingRef.current) {
+      return;
+    }
 
-  // @@@ Re-detect voices when triggers change
-  useEffect(() => {
-    detectVoices(currentText, voiceTriggers);
-  }, [voiceTriggers]);
+    const currentTextValue = currentTextRef.current;
+    const textDiff = Math.abs(currentTextValue.length - lastAnalyzedTextRef.current.length);
 
-  // @@@ Trigger management methods - ready for backend integration
+    // Only analyze if text changed by >10 characters
+    if (textDiff <= 10) {
+      return;
+    }
 
-  // Add a new trigger
-  const addTrigger = (trigger: VoiceTrigger) => {
-    setVoiceTriggers([...voiceTriggers, trigger]);
-  };
+    isAnalyzingRef.current = true;
+    lastAnalyzedTextRef.current = currentTextValue;
 
-  // Remove a trigger by phrase
-  const removeTrigger = (phrase: string) => {
-    setVoiceTriggers(voiceTriggers.filter(t => t.phrase !== phrase));
-  };
+    try {
+      console.log(`üîç Calling backend analysis (${textDiff} chars changed)...`);
+      const backendVoices = await analyzeText(currentTextValue);
+      console.log(`‚úÖ Got ${backendVoices.length} voices from backend`);
 
-  // Update an existing trigger
-  const updateTrigger = (phrase: string, updates: Partial<VoiceTrigger>) => {
-    setVoiceTriggers(voiceTriggers.map(t =>
-      t.phrase === phrase ? { ...t, ...updates } : t
-    ));
+      setVoiceTriggers(backendVoices);
+      detectVoices(currentTextValue, backendVoices);
+    } catch (error) {
+      console.error('‚ùå Voice analysis failed:', error);
+    } finally {
+      isAnalyzingRef.current = false;
+    }
   };
 
-  // Replace all triggers (e.g., from API)
-  const setAllTriggers = (newTriggers: VoiceTrigger[]) => {
-    setVoiceTriggers(newTriggers);
+  // @@@ Polling strategy - Check every 5 seconds (stable interval)
+  useEffect(() => {
+    const interval = setInterval(analyzeIfNeeded, 5000);
+    return () => clearInterval(interval);
+  }, []);
+
+  const handleTextChange = (newText: string) => {
+    setCurrentText(newText);
+    currentTextRef.current = newText;
+
+    // Instantly update display with current triggers
+    detectVoices(newText, voiceTriggers);
   };
 
-  // Expose methods to window for testing in console
+  // @@@ Re-detect voices when triggers change
   useEffect(() => {
-    (window as any).voiceControls = {
-      addTrigger,
-      removeTrigger,
-      updateTrigger,
-      setAllTriggers,
-      getCurrentTriggers: () => voiceTriggers,
-    };
+    detectVoices(currentText, voiceTriggers);
   }, [voiceTriggers]);
 
   return (
     <div className="book-interface">
       <WritingArea onChange={handleTextChange} triggers={voiceTriggers} />
       <VoicesPanel>
         {voices.map((voice, index) => (
-          <VoiceComment key={index} voice={voice.name} text={voice.text} icon={voice.icon} />
+          <VoiceComment key={index} voice={voice.name} text={voice.text} icon={voice.icon} color={voice.color} />
         ))}
       </VoicesPanel>
       <BinderRings />

*** FILE: frontend/src/api/voiceApi.ts ***
@@ -0,0 +1,84 @@
+/**
+ * API client for voice analysis backend
+ */
+
+const API_BASE = 'http://localhost:8765';
+
+interface TriggerResponse {
+  success: boolean;
+  exec_id: string;
+}
+
+interface StatusResponse {
+  exec_id: string;
+  status: 'running' | 'completed' | 'failed';
+  result?: {
+    voices: Array<{
+      phrase: string;
+      voice: string;
+      comment: string;
+      icon: string;
+      color: string;
+    }>;
+    status: string;
+  };
+  error?: string;
+}
+
+/**
+ * Trigger voice analysis session
+ */
+export async function triggerAnalysis(text: string): Promise<string> {
+  const response = await fetch(`${API_BASE}/api/trigger`, {
+    method: 'POST',
+    headers: { 'Content-Type': 'application/json' },
+    body: JSON.stringify({
+      session_id: 'analyze_text',
+      params: { text }
+    })
+  });
+
+  const data: TriggerResponse = await response.json();
+  if (!data.success) {
+    throw new Error('Failed to trigger analysis');
+  }
+
+  return data.exec_id;
+}
+
+/**
+ * Get analysis result (polls until completed)
+ */
+export async function getAnalysisResult(exec_id: string): Promise<StatusResponse['result']> {
+  // Poll every 500ms, max 30 seconds
+  const maxAttempts = 60;
+  let attempts = 0;
+
+  while (attempts < maxAttempts) {
+    const response = await fetch(`${API_BASE}/api/status/${exec_id}`);
+    const data: StatusResponse = await response.json();
+
+    if (data.status === 'completed') {
+      return data.result;
+    }
+
+    if (data.status === 'failed') {
+      throw new Error(data.error || 'Analysis failed');
+    }
+
+    // Still running, wait and retry
+    await new Promise(resolve => setTimeout(resolve, 500));
+    attempts++;
+  }
+
+  throw new Error('Analysis timeout');
+}
+
+/**
+ * Analyze text and return voices (all-in-one)
+ */
+export async function analyzeText(text: string) {
+  const exec_id = await triggerAnalysis(text);
+  const result = await getAnalysisResult(exec_id);
+  return result?.voices || [];
+}

*** FILE: frontend/src/components/VoiceComment.tsx ***
@@ -4,6 +4,7 @@ interface VoiceCommentProps {
   voice: string;
   text: string;
   icon: string;
+  color: string;
 }
 
 const iconMap = {
@@ -13,11 +14,26 @@ const iconMap = {
   cloud: FaCloud,
 };
 
-export default function VoiceComment({ voice, text, icon }: VoiceCommentProps) {
+const colorMap: Record<string, { background: string; border: string }> = {
+  blue: { background: '#e6f2ff', border: '#4d9fff' },
+  pink: { background: '#ffe6f2', border: '#ff66b3' },
+  yellow: { background: '#fffbe6', border: '#ffdd33' },
+  green: { background: '#e6ffe6', border: '#66ff66' },
+  purple: { background: '#f3e6ff', border: '#b366ff' },
+};
+
+export default function VoiceComment({ voice, text, icon, color }: VoiceCommentProps) {
   const Icon = iconMap[icon as keyof typeof iconMap];
+  const colors = colorMap[color] || { background: '#f0f0f0', border: '#ccc' };
 
   return (
-    <div className={`voice-comment voice-comment-${voice.toLowerCase()}`}>
+    <div
+      className="voice-comment"
+      style={{
+        backgroundColor: colors.background,
+        borderColor: colors.border,
+      }}
+    >
       <div className="voice-header">
         {Icon && <Icon className="voice-icon" />}
         <strong>{voice}:</strong>

*** FILE: frontend/src/extensions/VoiceHighlight.ts ***
@@ -71,7 +71,7 @@ function findHighlights(doc: any, triggers: VoiceTrigger[]): DecorationSet {
   const text = doc.textContent.toLowerCase();
 
   triggers.forEach(({ phrase, color }) => {
-    const pos = text.indexOf(phrase);
+    const pos = text.indexOf(phrase.toLowerCase());
 
     if (pos !== -1) {
       // Convert text position to document position
