*** FILE: backend/database.py ***
@@ -1257,6 +1257,36 @@ def get_daily_picture_full(user_id: int, date: str):
     finally:
         db.close()
 
+
+def get_friend_picture_full(user_id: int, friend_id: int, date: str):
+    """Get full resolution image for a friend's specific date if users are friends."""
+    db = get_db()
+    try:
+        friendship = db.execute("""
+        SELECT id FROM friendships
+        WHERE status = 'accepted' AND (
+          (user_id = ? AND friend_id = ?) OR
+          (user_id = ? AND friend_id = ?)
+        )
+        """, (user_id, friend_id, friend_id, user_id)).fetchone()
+
+        if not friendship:
+            return None
+
+        row = db.execute("""
+        SELECT image_base64
+        FROM daily_pictures
+        WHERE user_id = ? AND date = ?
+        ORDER BY created_at DESC
+        LIMIT 1
+        """, (friend_id, date)).fetchone()
+
+        if row:
+            return row['image_base64']
+        return None
+    finally:
+        db.close()
+
 # ========== User Preferences ==========
 
 def save_preferences(user_id: int, voice_configs: dict = None, meta_prompt: str = None,

*** FILE: backend/server.py ***
@@ -1169,6 +1169,22 @@ def get_picture_full(
 
     return {"image_base64": full_image}
 
+
+@app.get("/api/friends/{friend_id}/pictures/{date}/full")
+def get_friend_picture_full_endpoint(
+    friend_id: int,
+    date: str,
+    current_user: dict = Depends(get_current_user)
+):
+    """Get full resolution image for a friend's specific date (only if users are friends)."""
+    user_id = current_user['user_id']
+    full_image = database.get_friend_picture_full(user_id, friend_id, date)
+
+    if not full_image:
+        raise HTTPException(status_code=404, detail="Picture not found or not accessible")
+
+    return {"image_base64": full_image}
+
 @app.post("/api/pictures")
 def save_picture(
     request: dict,
@@ -1634,6 +1650,7 @@ def get_friend_timeline(friend_id: int, limit: int = 30, current_user: dict = De
     print("    DELETE /api/sessions/{id} - Delete session")
     print("    POST /api/pictures        - Save daily picture")
     print("    GET  /api/pictures        - List pictures")
+    print("    GET  /api/pictures/{date}/full - Get full picture by date")
     print("    GET  /api/preferences     - Get user preferences")
     print("    POST /api/preferences     - Save preferences")
     print("    GET  /api/reports         - Get analysis reports")
@@ -1660,6 +1677,7 @@ def get_friend_timeline(friend_id: int, limit: int = 30, current_user: dict = De
     print("    GET  /api/friends                 - Get friends list")
     print("    DELETE /api/friends/{id}          - Remove friend")
     print("    GET  /api/friends/{id}/timeline   - Get friend's timeline")
+    print("    GET  /api/friends/{id}/pictures/{date}/full - Get friend's full picture")
     print("\n  PolyCLI (AI Functions):")
     print("    /polycli                  - Control panel UI")
     print("    /polycli/api/trigger-sync - Direct sync API")

*** FILE: frontend/src/api/voiceApi.ts ***
@@ -1085,3 +1085,20 @@ export async function getFriendTimeline(friendId: number, limit: number = 30): P
   const data = await response.json();
   return data.pictures;
 }
+
+/**
+ * Get friend's full-resolution picture for a specific date
+ */
+export async function getFriendPictureFull(friendId: number, date: string): Promise<string> {
+  const response = await fetch(`${API_BASE}/api/friends/${friendId}/pictures/${date}/full`, {
+    headers: getAuthHeaders()
+  });
+
+  if (!response.ok) {
+    const error = await response.json();
+    throw new Error(error.detail || 'Get friend picture failed');
+  }
+
+  const data = await response.json();
+  return data.image_base64;
+}

*** FILE: frontend/src/components/CollectionsView.tsx ***
@@ -1,10 +1,11 @@
-import { useState, useEffect, useLayoutEffect, useRef } from 'react';
+import { useState, useEffect, useLayoutEffect, useRef, useMemo } from 'react';
 import { useTranslation } from 'react-i18next';
 import type { Commentor } from '../engine/EditorEngine';
 import { findNormalizedPhrase } from '../utils/textNormalize';
 import { useAuth } from '../contexts/AuthContext';
 import { STORAGE_KEYS } from '../constants/storageKeys';
 import { getDateLocale } from '../i18n';
+import type { Friend } from '../api/voiceApi';
 
 // @@@ TypeScript interfaces
 interface TimelineDay {
@@ -15,6 +16,18 @@ interface TimelineDay {
   daysOffset: number;
 }
 
+type TimelinePicture = {
+  date: string;
+  base64: string;
+  full_base64?: string;
+  prompt: string;
+};
+
+interface TimelineEntryData {
+  picture?: TimelinePicture;
+  comments: Commentor[];
+}
+
 export default function CollectionsView({ isVisible, voiceConfigs }: { isVisible: boolean; voiceConfigs: Record<string, any> }) {
   const { i18n } = useTranslation();
   const dateLocale = getDateLocale(i18n.language);
@@ -189,6 +202,169 @@ function getTextPreview(text: string, maxLength: number = 60): string {
   return preview;
 }
 
+interface TimelineCardProps {
+  day: TimelineDay;
+  dayData?: TimelineEntryData;
+  hasData: boolean;
+  isGenerating: boolean;
+  placeholder: string;
+  textByDate: Map<string, string>;
+  dateLocale: string;
+  t: (key: string, options?: any) => string;
+  onImageClick: (picture: TimelinePicture) => void;
+  onGenerate?: (date: string) => void;
+  readOnly?: boolean;
+  customDescription?: string;
+}
+
+function renderTimelineCard({
+  day,
+  dayData,
+  hasData,
+  isGenerating,
+  placeholder,
+  textByDate,
+  dateLocale,
+  t,
+  onImageClick,
+  onGenerate,
+  readOnly,
+  customDescription
+}: TimelineCardProps) {
+  const cardCursor = dayData?.picture && !isGenerating ? 'pointer' : 'default';
+  const textContent = dayData && textByDate.get(day.date);
+  const commentCount = dayData?.comments?.length || 0;
+
+  let description = placeholder;
+  if (customDescription) {
+    description = customDescription;
+  } else if (isGenerating) {
+    description = t('timeline.generating');
+  } else if (day.isToday && !dayData?.picture) {
+    description = placeholder;
+  } else if (textContent) {
+    description = getTextPreview(textContent);
+  } else if (commentCount > 0) {
+    description = t('timeline.entryCount', { count: commentCount });
+  }
+
+  return (
+    <div
+      onClick={() => {
+        if (dayData?.picture) {
+          onImageClick(dayData.picture);
+        }
+      }}
+      style={{
+        display: 'flex',
+        alignItems: 'center',
+        gap: '1rem',
+        padding: '0.5rem 0',
+        cursor: cardCursor,
+        transition: 'transform 0.2s',
+        opacity: day.isPast && !hasData ? 0.4 : 1
+      }}
+      onMouseEnter={e => {
+        if (dayData?.picture && !isGenerating) {
+          e.currentTarget.style.transform = 'translateX(8px)';
+        }
+      }}
+      onMouseLeave={e => {
+        e.currentTarget.style.transform = 'translateX(0)';
+      }}
+    >
+      <div style={{ flexShrink: 0 }}>
+        {dayData?.picture ? (
+          <div style={{ position: 'relative' }}>
+            <img
+              src={`data:image/${dayData.picture.base64?.startsWith('iVBOR') ? 'png' : 'jpeg'};base64,${dayData.picture.base64}`}
+              alt={dayData.picture.prompt}
+              style={{
+                width: '80px',
+                height: '80px',
+                objectFit: 'cover',
+                borderRadius: '6px'
+              }}
+            />
+            {!readOnly && onGenerate && (
+              <button
+                onClick={(e) => {
+                  e.stopPropagation();
+                  if (!isGenerating) onGenerate(day.date);
+                }}
+                disabled={isGenerating}
+                style={{
+                  position: 'absolute',
+                  top: '4px',
+                  right: '4px',
+                  width: '24px',
+                  height: '24px',
+                  borderRadius: '50%',
+                  background: 'rgba(255, 255, 255, 0.95)',
+                  border: 'none',
+                  cursor: isGenerating ? 'wait' : 'pointer',
+                  display: 'flex',
+                  alignItems: 'center',
+                  justifyContent: 'center',
+                  opacity: 0.9,
+                  transition: 'opacity 0.2s'
+                }}
+                onMouseEnter={e => {
+                  if (!isGenerating) e.currentTarget.style.opacity = '1';
+                }}
+                onMouseLeave={e => {
+                  e.currentTarget.style.opacity = '0.9';
+                }}
+                title="Redraw image"
+              >
+                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
+                  <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
+                </svg>
+              </button>
+            )}
+          </div>
+        ) : (
+          <div style={{
+            width: '80px',
+            height: '80px',
+            background: day.isFuture ? 'linear-gradient(135deg, #f8f0e6 0%, #ede3d5 100%)' : 'linear-gradient(135deg, #f0e8de 0%, #e5dbc9 100%)',
+            border: day.isFuture ? '2px dashed #d0c4b0' : '2px dashed #b8a896',
+            borderRadius: '6px',
+            display: 'flex',
+            alignItems: 'center',
+            justifyContent: 'center',
+            fontSize: '11px',
+            color: '#999',
+            fontStyle: 'italic',
+            textAlign: 'center',
+            padding: '0.5rem'
+          }}>
+            {isGenerating ? '...' : '?'}
+          </div>
+        )}
+      </div>
+
+      <div style={{ flex: 1, minWidth: 0 }}>
+        <div style={{
+          fontSize: '14px',
+          fontWeight: 600,
+          color: day.isToday ? '#2c2c2c' : '#666',
+          marginBottom: '0.25rem'
+        }}>
+          {day.isToday ? t('timeline.today') : formatDate(day.date, dateLocale)}
+        </div>
+        <div style={{
+          fontSize: '13px',
+          color: '#888',
+          fontStyle: (!textContent && (day.isToday || !dayData?.comments?.length)) ? 'italic' : 'normal'
+        }}>
+          {description}
+        </div>
+      </div>
+    </div>
+  );
+}
+
 // @@@ Get all notes from all sessions (localStorage for guest, database for authenticated)
 async function getAllNotesFromSessions(isAuthenticated: boolean): Promise<string> {
   const allText: string[] = [];
@@ -245,21 +421,95 @@ async function getAllNotesFromSessions(isAuthenticated: boolean): Promise<string
 }
 
 // @@@ Timeline page - combines pictures and comments by date
+const MAX_RECENT_FRIENDS = 6;
+
+const getInitialLetter = (name?: string, fallback: string = '?') => {
+  if (!name) return fallback;
+  const first = name.trim().charAt(0).toUpperCase();
+  return first || fallback;
+};
+
 function TimelinePage({ isVisible, voiceConfigs, dateLocale }: { isVisible: boolean; voiceConfigs: Record<string, any>; dateLocale: string }) {
   const { t } = useTranslation();
   const { isAuthenticated } = useAuth();
   const [starredComments, setStarredComments] = useState<Commentor[]>([]);
   const [allCommentsByDate, setAllCommentsByDate] = useState<Map<string, Commentor[]>>(new Map());
   const [textByDate, setTextByDate] = useState<Map<string, string>>(new Map());
-  const [pictures, setPictures] = useState<Array<{ date: string; base64: string; full_base64?: string; prompt: string }>>([]);
+  const [pictures, setPictures] = useState<TimelinePicture[]>([]);
   const [generatingForDate, setGeneratingForDate] = useState<string | null>(null);
-  const [viewingImage, setViewingImage] = useState<{ base64: string; full_base64?: string; prompt: string; date: string } | null>(null);
+  const [viewingImage, setViewingImage] = useState<{ base64: string; full_base64?: string; prompt: string; date: string; origin?: 'self' | 'friend'; friendId?: number } | null>(null);
   const [initialLoading, setInitialLoading] = useState(true);
   const [loadingCommentsForDate, setLoadingCommentsForDate] = useState<string | null>(null);
+  const [friends, setFriends] = useState<Friend[]>([]);
+  const [selectedFriendId, setSelectedFriendId] = useState<number | null>(() => {
+    if (typeof window === 'undefined') return null;
+    const stored = localStorage.getItem(STORAGE_KEYS.SELECTED_FRIEND);
+    if (!stored) return null;
+    const parsed = Number(stored);
+    return Number.isFinite(parsed) ? parsed : null;
+  });
+  const [recentFriendIds, setRecentFriendIds] = useState<number[]>(() => {
+    if (typeof window === 'undefined') return [];
+    try {
+      const stored = localStorage.getItem(STORAGE_KEYS.RECENT_FRIENDS);
+      if (!stored) return [];
+      const parsed = JSON.parse(stored);
+      if (Array.isArray(parsed)) {
+        return parsed.filter(id => typeof id === 'number');
+      }
+      return [];
+    } catch {
+      return [];
+    }
+  });
+  const [isFriendPickerOpen, setIsFriendPickerOpen] = useState(false);
+  const [friendSearchTerm, setFriendSearchTerm] = useState('');
+  const [friendPictures, setFriendPictures] = useState<TimelinePicture[]>([]);
+  const [loadingFriends, setLoadingFriends] = useState(false);
+  const [friendLoadError, setFriendLoadError] = useState<string | null>(null);
+  const [friendTimelineError, setFriendTimelineError] = useState<string | null>(null);
+  const [loadingFriendTimeline, setLoadingFriendTimeline] = useState(false);
   const scrollContainerRef = useRef<HTMLDivElement | null>(null);
+  const emptyTextMap = useMemo(() => new Map<string, string>(), []);
+  const filteredFriends = useMemo(() => {
+    const term = friendSearchTerm.trim().toLowerCase();
+    if (!term) return friends;
+    return friends.filter(friend =>
+      friend.friend_name?.toLowerCase().includes(term) ||
+      friend.friend_email?.toLowerCase().includes(term)
+    );
+  }, [friends, friendSearchTerm]);
+  useEffect(() => {
+    setRecentFriendIds(prev =>
+      prev.filter(id => friends.some(friend => friend.friend_id === id))
+    );
+  }, [friends]);
+  const selectedFriend = useMemo(
+    () => friends.find(friend => friend.friend_id === selectedFriendId),
+    [friends, selectedFriendId]
+  );
+  useEffect(() => {
+    if (typeof window === 'undefined') return;
+    localStorage.setItem(STORAGE_KEYS.RECENT_FRIENDS, JSON.stringify(recentFriendIds));
+  }, [recentFriendIds]);
+  const friendMap = useMemo(() => {
+    const map = new Map<number, Friend>();
+    friends.forEach(friend => map.set(friend.friend_id, friend));
+    return map;
+  }, [friends]);
+  const orderedFriendIds = useMemo(() => {
+    const ids = recentFriendIds.filter(id => friendMap.has(id));
+    if (selectedFriendId && friendMap.has(selectedFriendId)) {
+      return [selectedFriendId, ...ids.filter(id => id !== selectedFriendId)].slice(0, MAX_RECENT_FRIENDS);
+    }
+    return ids.slice(0, MAX_RECENT_FRIENDS);
+  }, [recentFriendIds, selectedFriendId, friendMap]);
+  const orderedRecentFriends = orderedFriendIds
+    .map(id => friendMap.get(id))
+    .filter((friend): friend is Friend => Boolean(friend));
 
   useEffect(() => {
-    const loadData = async () => {
+    const loadTimelineData = async () => {
       // @@@ Load all comments grouped by date from database if authenticated, localStorage if guest
       if (isAuthenticated) {
         try {
@@ -391,11 +641,53 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale }: { isVisible: bool
       setInitialLoading(false);
     };
 
-    loadData();
+    const loadFriendsList = async () => {
+      if (!isAuthenticated) {
+        setFriends([]);
+        setFriendLoadError(null);
+        setFriendPictures([]);
+        setSelectedFriendId(null);
+        setFriendTimelineError(null);
+        setLoadingFriendTimeline(false);
+        setIsFriendPickerOpen(false);
+        setFriendSearchTerm('');
+        if (typeof window !== 'undefined') {
+          localStorage.removeItem(STORAGE_KEYS.SELECTED_FRIEND);
+        }
+        return;
+      }
+
+      setLoadingFriends(true);
+      setFriendLoadError(null);
+      try {
+        const { getFriends } = await import('../api/voiceApi');
+        const friendList = await getFriends();
+        setFriends(friendList);
+        setSelectedFriendId(prev => {
+          if (!prev) return prev;
+          const exists = friendList.some(friend => friend.friend_id === prev);
+          if (!exists) {
+            if (typeof window !== 'undefined') {
+              localStorage.removeItem(STORAGE_KEYS.SELECTED_FRIEND);
+            }
+            return null;
+          }
+          return prev;
+        });
+      } catch (err) {
+        console.error('Failed to load friends:', err);
+        setFriendLoadError(err instanceof Error ? err.message : String(err));
+      } finally {
+        setLoadingFriends(false);
+      }
+    };
+
+    loadTimelineData();
+    loadFriendsList();
   }, [isAuthenticated]);
 
   // @@@ Group items by date (using YYYY-MM-DD format to match timeline days)
-  const timelineByDate = new Map<string, { picture?: any; comments: Commentor[] }>();
+  const timelineByDate = new Map<string, TimelineEntryData>();
 
   starredComments.forEach(comment => {
     const commentDate = new Date(comment.appliedAt || comment.computedAt);
@@ -414,6 +706,54 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale }: { isVisible: bool
     timelineByDate.get(date)!.picture = pic;
   });
 
+  const friendTimelineByDate = new Map<string, TimelineEntryData>();
+  friendPictures.forEach(pic => {
+    friendTimelineByDate.set(pic.date, { picture: pic, comments: [] });
+  });
+
+  useEffect(() => {
+    if (!isAuthenticated || !selectedFriendId) {
+      setFriendPictures([]);
+      setFriendTimelineError(null);
+      setLoadingFriendTimeline(false);
+      return;
+    }
+
+    let cancelled = false;
+    const loadFriendTimeline = async () => {
+      setLoadingFriendTimeline(true);
+      setFriendTimelineError(null);
+      try {
+        const { getFriendTimeline } = await import('../api/voiceApi');
+        const friendData = await getFriendTimeline(selectedFriendId, 30);
+        const normalized: TimelinePicture[] = friendData.map((pic: any) => ({
+          date: pic.date,
+          base64: pic.base64,
+          prompt: pic.prompt || '',
+          full_base64: pic.full_base64
+        }));
+        if (!cancelled) {
+          setFriendPictures(normalized);
+        }
+      } catch (err) {
+        if (!cancelled) {
+          console.error('Failed to load friend timeline:', err);
+          setFriendTimelineError(err instanceof Error ? err.message : String(err));
+          setFriendPictures([]);
+        }
+      } finally {
+        if (!cancelled) {
+          setLoadingFriendTimeline(false);
+        }
+      }
+    };
+
+    loadFriendTimeline();
+    return () => {
+      cancelled = true;
+    };
+  }, [isAuthenticated, selectedFriendId]);
+
   // @@@ Set initial scroll position to show today's row at top
   // Use useLayoutEffect to position BEFORE browser paints (prevents flash)
   useLayoutEffect(() => {
@@ -482,8 +822,8 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale }: { isVisible: bool
     }
   };
 
-  const handleImageClick = async (picture: { base64: string; full_base64?: string; prompt: string; date: string }) => {
-    setViewingImage(picture);
+  const handleImageClick = async (picture: TimelinePicture) => {
+    setViewingImage({ ...picture, origin: 'self' });
 
     // Load full image on-demand if not already loaded
     if (!picture.full_base64 && isAuthenticated) {
@@ -492,7 +832,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale }: { isVisible: bool
         const fullImage = await getDailyPictureFull(picture.date);
 
         // Update the picture object with full image
-        const updatedPicture = { ...picture, full_base64: fullImage };
+        const updatedPicture = { ...picture, full_base64: fullImage, origin: 'self' as const };
         setViewingImage(updatedPicture);
 
         // Also update pictures array so we don't reload next time
@@ -507,6 +847,43 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale }: { isVisible: bool
     await reloadCommentsForDate(picture.date);
   };
 
+  const handleFriendImageClick = async (picture: TimelinePicture) => {
+    setViewingImage({ ...picture, origin: 'friend' });
+
+    if (!picture.full_base64 && selectedFriendId) {
+      try {
+        const { getFriendPictureFull } = await import('../api/voiceApi');
+        const fullImage = await getFriendPictureFull(selectedFriendId, picture.date);
+        const updatedPicture = { ...picture, full_base64: fullImage };
+        setViewingImage({ ...updatedPicture, origin: 'friend' });
+        setFriendPictures(prev => prev.map(p =>
+          p.date === picture.date ? updatedPicture : p
+        ));
+      } catch (error) {
+        console.error('Failed to load friend full image:', error);
+      }
+    }
+  };
+
+  const handleFriendSelection = (friendId: number | null) => {
+    setSelectedFriendId(friendId);
+    if (typeof window !== 'undefined') {
+      if (friendId) {
+        localStorage.setItem(STORAGE_KEYS.SELECTED_FRIEND, String(friendId));
+      } else {
+        localStorage.removeItem(STORAGE_KEYS.SELECTED_FRIEND);
+      }
+    }
+    if (friendId) {
+      setRecentFriendIds(prev => {
+        const without = prev.filter(id => id !== friendId);
+        return [friendId, ...without].slice(0, MAX_RECENT_FRIENDS);
+      });
+    }
+    setFriendSearchTerm('');
+    setIsFriendPickerOpen(false);
+  };
+
   const handleGenerateForDate = async (dateStr: string) => {
     // @@@ Block image generation for guests
     if (!isAuthenticated) {
@@ -570,52 +947,273 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale }: { isVisible: bool
         overflowY: 'auto',
         display: 'flex',
         flexDirection: 'column',
+        alignItems: 'center'
+      }}>
+      <div style={{
+        position: 'fixed',
+        right: '1rem',
+        top: '160px',
+        display: 'flex',
+        flexDirection: 'column',
+        gap: '0.4rem',
         alignItems: 'center',
-        padding: '3rem 0',
-        paddingBottom: '3rem'
+        zIndex: 4,
+        pointerEvents: isFriendPickerOpen ? 'none' : 'auto',
+        opacity: isFriendPickerOpen ? 0.4 : 1
       }}>
+        <button
+          onClick={() => handleFriendSelection(null)}
+          style={{
+            width: '42px',
+            height: '42px',
+            borderRadius: '21px',
+            border: selectedFriendId === null ? '2px solid #2c2c2c' : '1px solid #d0c4b0',
+            background: selectedFriendId === null ? '#2c2c2c' : '#fff',
+            color: selectedFriendId === null ? '#fff' : '#4a433a',
+            fontSize: '12px',
+            fontWeight: 600,
+            cursor: 'pointer'
+          }}
+          title={t('timeline.friendSelector.personal') || 'You'}
+        >
+          {t('timeline.friendSelector.personal') || 'Me'}
+        </button>
+        {orderedRecentFriends.map(friend => {
+          const isActive = friend.friend_id === selectedFriendId;
+          return (
+            <button
+              key={friend.id}
+              onClick={() => handleFriendSelection(friend.friend_id)}
+              style={{
+                width: '42px',
+                height: '42px',
+                borderRadius: '21px',
+                border: isActive ? '2px solid #2c2c2c' : '1px solid #d0c4b0',
+                background: isActive ? '#2c2c2c' : '#fff',
+                color: isActive ? '#fff' : '#4a433a',
+                fontSize: '13px',
+                fontWeight: 600,
+                cursor: 'pointer'
+              }}
+              title={friend.friend_name || friend.friend_email}
+            >
+              {getInitialLetter(friend.friend_name, getInitialLetter(friend.friend_email))}
+            </button>
+          );
+        })}
+        <button
+          onClick={() => {
+            setFriendSearchTerm('');
+            setIsFriendPickerOpen(true);
+          }}
+          style={{
+            width: '42px',
+            height: '42px',
+            borderRadius: '21px',
+            border: '1px solid #d0c4b0',
+            background: '#fff',
+            color: '#4a433a',
+            fontSize: '18px',
+            cursor: 'pointer'
+          }}
+          title={t('timeline.friendSelector.more') || 'More'}
+        >
+          ‚Ä¶
+        </button>
+      </div>
+
+      {isFriendPickerOpen && (
+        <div
+          style={{
+            position: 'fixed',
+            inset: 0,
+            background: 'rgba(0, 0, 0, 0.45)',
+            display: 'flex',
+            alignItems: 'center',
+            justifyContent: 'center',
+            zIndex: 20,
+            padding: '2rem'
+          }}
+          onClick={() => setIsFriendPickerOpen(false)}
+        >
+          <div
+            style={{
+              width: '100%',
+              maxWidth: '420px',
+              background: '#fff',
+              borderRadius: '12px',
+              border: '1px solid #d0c4b0',
+              boxShadow: '0 12px 40px rgba(0,0,0,0.25)',
+              padding: '1.5rem',
+              display: 'flex',
+              flexDirection: 'column',
+              gap: '1rem'
+            }}
+            onClick={(e) => e.stopPropagation()}
+          >
+            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
+              <div style={{ fontSize: '15px', fontWeight: 600, color: '#2c2c2c' }}>
+                {t('timeline.friendSelector.label')}
+              </div>
+              <button
+                onClick={() => setIsFriendPickerOpen(false)}
+                style={{
+                  border: 'none',
+                  background: 'transparent',
+                  fontSize: '14px',
+                  color: '#7a7060',
+                  cursor: 'pointer'
+                }}
+              >
+                {t('timeline.friendSelector.close')}
+              </button>
+            </div>
+            {friendLoadError && (
+              <div style={{ fontSize: '12px', color: '#b8562e' }}>
+                {t('timeline.friendSelector.error')}
+              </div>
+            )}
+            <input
+              type="text"
+              value={friendSearchTerm}
+              onChange={(e) => setFriendSearchTerm(e.target.value)}
+              placeholder={t('timeline.friendSelector.searchPlaceholder') || 'Search'}
+              style={{
+                width: '100%',
+                padding: '0.65rem 0.85rem',
+                borderRadius: '8px',
+                border: '1px solid #c7b9a4',
+                background: '#fff',
+                fontSize: '14px',
+                boxSizing: 'border-box'
+              }}
+            />
+            <div style={{ display: 'flex', gap: '0.5rem' }}>
+              <button
+                onClick={() => handleFriendSelection(null)}
+                style={{
+                  flex: 1,
+                  border: '1px solid #c7b9a4',
+                  background: '#f8f0e6',
+                  borderRadius: '8px',
+                  padding: '0.6rem 0.75rem',
+                  fontSize: '13px',
+                  cursor: 'pointer'
+                }}
+              >
+                {t('timeline.friendSelector.none')}
+              </button>
+            </div>
+            <div style={{ maxHeight: '260px', overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
+              {friends.length === 0 && (
+                <div style={{ fontSize: '13px', color: '#7a7060' }}>
+                  {t('timeline.friendSelector.noFriends')}
+                </div>
+              )}
+              {friends.length > 0 && filteredFriends.length === 0 && (
+                <div style={{ fontSize: '13px', color: '#7a7060' }}>
+                  {t('timeline.friendSelector.noMatches')}
+                </div>
+              )}
+              {filteredFriends.map((friend) => {
+                const isSelected = friend.friend_id === selectedFriendId;
+                return (
+                  <button
+                    key={friend.id}
+                    onClick={() => handleFriendSelection(friend.friend_id)}
+                    style={{
+                      border: isSelected ? '1px solid #2c2c2c' : '1px solid #d0c4b0',
+                      borderRadius: '8px',
+                      padding: '0.65rem 0.9rem',
+                      textAlign: 'left',
+                      cursor: 'pointer',
+                      background: isSelected ? '#f0e8de' : '#fff'
+                    }}
+                  >
+                    <div style={{ fontWeight: 600, fontSize: '14px', color: '#2c2c2c' }}>
+                      {friend.friend_name}
+                    </div>
+                    <div style={{ fontSize: '12px', color: '#7a7060' }}>
+                      {friend.friend_email}
+                    </div>
+                  </button>
+                );
+              })}
+            </div>
+          </div>
+        </div>
+      )}
+
       {/* @@@ Vertical scrolling timeline - rows stacked */}
       <div style={{
         display: 'flex',
         flexDirection: 'column',
         gap: '1.5rem',
-        maxWidth: '900px',
+        maxWidth: '1200px',
         width: '100%',
         padding: '0 2rem',
         paddingBottom: '5rem'  // @@@ Prevent bottom card cutoff
       }}>
         {allTimelineDays.map((day, index) => {
           const dayData = timelineByDate.get(day.date);
+          const friendDayData = friendTimelineByDate.get(day.date);
           const hasData = !!dayData;
+          const hasFriendData = !!friendDayData;
           const isGenerating = generatingForDate === day.date;
+          const placeholder = getPlaceholderText(t, day.daysOffset);
+          const showFriendSide = Boolean(selectedFriendId);
 
           return (
             <div
               key={day.date}
               style={{
                 position: 'relative',
-                paddingLeft: '3rem'
+                display: 'flex',
+                alignItems: 'center',
+                justifyContent: 'center',
+                gap: '1.5rem',
+                padding: '0 2rem'
               }}>
-              {/* @@@ Fixed timeline node - does NOT move with card hover */}
+              <div style={{
+                flex: '1',
+                display: 'flex',
+                justifyContent: 'flex-end',
+                paddingRight: '2rem'
+              }}>
+                {renderTimelineCard({
+                  day,
+                  dayData,
+                  hasData,
+                  isGenerating,
+                  onImageClick: handleImageClick,
+                  onGenerate: handleGenerateForDate,
+                  textByDate,
+                  t,
+                  dateLocale,
+                  placeholder
+                })}
+              </div>
+
+              {/* Center node */}
               <div style={{
                 position: 'absolute',
-                left: '0',
+                left: '50%',
                 top: '50%',
-                transform: 'translateY(-50%)',
+                transform: 'translate(-50%, -50%)',
                 width: '20px',
                 height: '20px',
                 borderRadius: '50%',
-                background: hasData ? '#4CAF50' : (day.isToday ? '#888' : '#ddd'),
+                background: (hasData || hasFriendData) ? '#4CAF50' : (day.isToday ? '#888' : '#ddd'),
                 border: '3px solid #f8f0e6',
                 boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
-                zIndex: 2
+                zIndex: 2,
+                pointerEvents: 'none'
               }} />
 
-              {/* @@@ Fixed connecting line - does NOT move with card hover */}
               {index < allTimelineDays.length - 1 && (
                 <div style={{
                   position: 'absolute',
-                  left: '10.5px',
+                  left: 'calc(50% - 1.5px)',
                   top: '50%',
                   height: 'calc(100% + 1.5rem)',
                   width: '3px',
@@ -624,133 +1222,31 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale }: { isVisible: bool
                 }} />
               )}
 
-              {/* @@@ Movable card - slides right on hover */}
-              <div
-                onClick={() => {
-                  if (dayData?.picture) {
-                    handleImageClick(dayData.picture);
-                  }
-                  // @@@ Removed manual generation for today - now automatic only
-                }}
-                style={{
-                  display: 'flex',
-                  alignItems: 'center',
-                  gap: '1rem',
-                  background: '#fff',
-                  border: '1px solid #d0c4b0',
-                  borderRadius: '8px',
-                  padding: '1rem',
-                  cursor: dayData?.picture && !isGenerating ? 'pointer' : 'default',
-                  transition: 'transform 0.2s, box-shadow 0.2s',
-                  opacity: day.isPast && !hasData ? 0.4 : 1
-                }}
-                onMouseEnter={e => {
-                  if (dayData?.picture && !isGenerating) {
-                    e.currentTarget.style.transform = 'translateX(8px)';
-                    e.currentTarget.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
-                  }
-                }}
-                onMouseLeave={e => {
-                  e.currentTarget.style.transform = 'translateX(0)';
-                  e.currentTarget.style.boxShadow = 'none';
-                }}
-              >
-                {/* @@@ Small 80x80 image thumbnail */}
-                <div style={{ flexShrink: 0 }}>
-                  {dayData?.picture ? (
-                    <div style={{ position: 'relative' }}>
-                      <img
-                        src={`data:image/${dayData.picture.base64?.startsWith('iVBOR') ? 'png' : 'jpeg'};base64,${dayData.picture.base64}`}
-                        alt={dayData.picture.prompt}
-                        style={{
-                          width: '80px',
-                          height: '80px',
-                          objectFit: 'cover',
-                          borderRadius: '6px'
-                        }}
-                      />
-                      {/* Redraw button */}
-                      <button
-                        onClick={(e) => {
-                          e.stopPropagation();
-                          if (!isGenerating) handleGenerateForDate(day.date);
-                        }}
-                        disabled={isGenerating}
-                        style={{
-                          position: 'absolute',
-                          top: '4px',
-                          right: '4px',
-                          width: '24px',
-                          height: '24px',
-                          borderRadius: '50%',
-                          background: 'rgba(255, 255, 255, 0.95)',
-                          border: 'none',
-                          cursor: isGenerating ? 'wait' : 'pointer',
-                          display: 'flex',
-                          alignItems: 'center',
-                          justifyContent: 'center',
-                          opacity: 0.9,
-                          transition: 'opacity 0.2s'
-                        }}
-                        onMouseEnter={e => {
-                          if (!isGenerating) e.currentTarget.style.opacity = '1';
-                        }}
-                        onMouseLeave={e => {
-                          e.currentTarget.style.opacity = '0.9';
-                        }}
-                        title="Redraw image"
-                      >
-                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
-                          <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
-                        </svg>
-                      </button>
-                    </div>
-                  ) : (
-                    <div style={{
-                      width: '80px',
-                      height: '80px',
-                      background: day.isFuture ? 'linear-gradient(135deg, #f8f0e6 0%, #ede3d5 100%)' : 'linear-gradient(135deg, #f0e8de 0%, #e5dbc9 100%)',
-                      border: day.isFuture ? '2px dashed #d0c4b0' : '2px dashed #b8a896',
-                      borderRadius: '6px',
-                      display: 'flex',
-                      alignItems: 'center',
-                      justifyContent: 'center',
-                      fontSize: '11px',
-                      color: '#999',
-                      fontStyle: 'italic',
-                      textAlign: 'center',
-                      padding: '0.5rem'
-                    }}>
-                      {isGenerating ? '...' : '?'}
-                    </div>
-                  )}
-                </div>
-
-                {/* @@@ Text content - date + summary */}
-                <div style={{ flex: 1, minWidth: 0 }}>
-                  <div style={{
-                    fontSize: '14px',
-                    fontWeight: 600,
-                    color: day.isToday ? '#2c2c2c' : '#666',
-                    marginBottom: '0.25rem'
-                  }}>
-                    {day.isToday ? t('timeline.today') : formatDate(day.date, dateLocale)}
-                  </div>
-                  <div style={{
-                    fontSize: '13px',
-                    color: '#888',
-                    fontStyle: (day.isToday && !dayData?.picture) || (!textByDate.get(day.date) && !dayData?.comments?.length) ? 'italic' : 'normal'
-                  }}>
-                    {isGenerating ? t('timeline.generating') :
-                     day.isToday && !dayData?.picture ?
-                       getPlaceholderText(t, day.daysOffset) :
-                     textByDate.get(day.date) ?
-                       getTextPreview(textByDate.get(day.date)!) :
-                     dayData?.comments?.length ?
-                       t('timeline.entryCount', { count: dayData.comments.length }) :
-                       getPlaceholderText(t, day.daysOffset)}
-                  </div>
-                </div>
+              <div style={{
+                flex: '1',
+                display: 'flex',
+                justifyContent: 'flex-start',
+                paddingLeft: '2rem'
+              }}>
+                {showFriendSide && friendDayData?.picture ? (
+                  renderTimelineCard({
+                    day,
+                    dayData: friendDayData,
+                    hasData: true,
+                    isGenerating: false,
+                    onImageClick: handleFriendImageClick,
+                    textByDate: emptyTextMap,
+                    t,
+                    dateLocale,
+                    placeholder,
+                    readOnly: true,
+                    customDescription: friendDayData.picture.prompt
+                      ? getTextPreview(friendDayData.picture.prompt, 80)
+                      : placeholder
+                  })
+                ) : (
+                  <div style={{ width: '80px', height: '80px' }} />
+                )}
               </div>
             </div>
           );
@@ -935,6 +1431,47 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale }: { isVisible: bool
                     }
 
                     if (commentsToDisplay.length === 0) {
+                      if (viewingImage.origin === 'friend' && viewingImage.prompt) {
+                        return (
+                          <div style={{
+                            display: 'flex',
+                            flexDirection: 'column',
+                            gap: '1rem'
+                          }}>
+                            <div
+                              style={{
+                                background: '#fff',
+                                border: '1px solid #e0d8cc',
+                                borderRadius: '8px',
+                                padding: '1rem'
+                              }}
+                            >
+                              <div style={{
+                                display: 'flex',
+                                alignItems: 'center',
+                                gap: '0.5rem',
+                                marginBottom: '0.75rem'
+                              }}>
+                                <span style={{ fontSize: '18px' }}>üë•</span>
+                                <span style={{ fontWeight: 600, fontSize: '14px', color: '#333' }}>
+                                  {t('timeline.friendTimeline.readOnlyShort')}
+                                </span>
+                              </div>
+                              <div style={{
+                                fontSize: '13px',
+                                color: '#555',
+                                lineHeight: '1.7',
+                                paddingLeft: '0.5rem',
+                                wordBreak: 'break-word',
+                                whiteSpace: 'pre-wrap'
+                              }}>
+                                {viewingImage.prompt}
+                              </div>
+                            </div>
+                          </div>
+                        );
+                      }
+
                       return (
                         <div style={{
                           textAlign: 'center',
@@ -1042,11 +1579,10 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale }: { isVisible: bool
                 color: '#888'
               }}>
                 {(() => {
-                  const dateData = Array.from(timelineByDate.entries()).find(([_, data]) =>
-                    data.picture?.base64 === viewingImage.base64
-                  );
-                  const commentCount = dateData?.[1]?.comments?.length || 0;
-                  return `${commentCount} ${commentCount === 1 ? 'entry' : 'entries'}`;
+                  const commentCount = viewingImage.origin === 'friend'
+                    ? (viewingImage.prompt ? 1 : 0)
+                    : (timelineByDate.get(viewingImage.date)?.comments?.length || 0);
+                  return t('timeline.entryCount', { count: commentCount });
                 })()}
               </div>
             </div>
@@ -1056,5 +1592,3 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale }: { isVisible: bool
     </div>
   );
 }
-
-// @@@ Analysis Page (placeholder for echoes/traits/patterns)

*** FILE: frontend/src/constants/storageKeys.ts ***
@@ -22,6 +22,8 @@ export const STORAGE_KEYS = {
   // Calendar & Pictures
   CALENDAR_ENTRIES: 'calendarEntries',
   DAILY_PICTURES: 'daily-pictures',
+  SELECTED_FRIEND: 'ink-selected-friend',
+  RECENT_FRIENDS: 'ink-recent-friends',
 
   // Analysis
   ANALYSIS_REPORTS: 'analysisReports'

*** FILE: frontend/src/i18n.ts ***
@@ -125,7 +125,30 @@ const resources = {
         today: 'Today',
         generating: 'Generating...',
         entryCount_one: '{{count}} entry',
-        entryCount_other: '{{count}} entries'
+        entryCount_other: '{{count}} entries',
+        friendSelector: {
+          label: 'View Timeline',
+          placeholder: 'Choose a friend',
+          none: 'No friend selected',
+          loading: 'Loading friends...',
+          error: 'Could not load friends',
+          button: 'Timeline settings',
+          summarySolo: 'Personal timeline only',
+          summaryWithFriend: 'Comparing with {{name}}',
+          searchPlaceholder: 'Search friends',
+          noFriends: 'You have no friends yet.',
+          noMatches: 'No matches found',
+          close: 'Close',
+          personal: 'You',
+          more: 'More'
+        },
+        friendTimeline: {
+          loading: 'Loading friend timeline...',
+          empty: 'This friend has no entries yet.',
+          error: 'Unable to load friend timeline.',
+          readOnly: "Friend reflections open in read-only mode. You're just viewing their day.",
+          readOnlyShort: 'Friend timeline preview'
+        }
       },
       timelinePlaceholders: {
         today: 'Generates automatically overnight',
@@ -310,7 +333,30 @@ const resources = {
         today: '‰ªäÂ§©',
         generating: 'ÁîüÊàê‰∏≠...',
         entryCount_one: '{{count}} Êù°ËÆ∞ÂΩï',
-        entryCount_other: '{{count}} Êù°ËÆ∞ÂΩï'
+        entryCount_other: '{{count}} Êù°ËÆ∞ÂΩï',
+        friendSelector: {
+          label: 'Êü•ÁúãÊó∂Èó¥Á∫ø',
+          placeholder: 'ÈÄâÊã©Â•ΩÂèã',
+          none: '‰∏çÊü•ÁúãÂ•ΩÂèã',
+          loading: 'Ê≠£Âú®Âä†ËΩΩÂ•ΩÂèã...',
+          error: 'Êó†Ê≥ïÂä†ËΩΩÂ•ΩÂèãÂàóË°®',
+          button: 'Êó∂Èó¥Á∫øËÆæÁΩÆ',
+          summarySolo: 'ÂΩìÂâç‰ªÖÊòæÁ§∫‰∏™‰∫∫Êó∂Èó¥Á∫ø',
+          summaryWithFriend: 'Ê≠£Âú®‰∏é {{name}} ÁöÑÊó∂Èó¥Á∫øÂØπÁÖß',
+          searchPlaceholder: 'ÊêúÁ¥¢Â•ΩÂèã',
+          noFriends: '‰Ω†ËøòÊ≤°ÊúâÂ•ΩÂèã„ÄÇ',
+          noMatches: 'Ê≤°ÊúâÁ¨¶ÂêàÊù°‰ª∂ÁöÑÂ•ΩÂèã',
+          close: 'ÂÖ≥Èó≠',
+          personal: '‰ªÖËá™Â∑±',
+          more: 'Êõ¥Â§ö'
+        },
+        friendTimeline: {
+          loading: 'Ê≠£Âú®Âä†ËΩΩÂ•ΩÂèãÊó∂Èó¥Á∫ø...',
+          empty: 'Ëøô‰ΩçÂ•ΩÂèãÊúÄËøëÊ≤°ÊúâËÆ∞ÂΩï„ÄÇ',
+          error: 'Êó†Ê≥ïÂä†ËΩΩÂ•ΩÂèãÁöÑÊó∂Èó¥Á∫ø„ÄÇ',
+          readOnly: 'Â•ΩÂèãÁöÑÊÄªÁªì‰ªÖ‰æõÊü•ÁúãÔºåÊó†Ê≥ï‰∫íÂä®„ÄÇ',
+          readOnlyShort: 'Â•ΩÂèãÊó∂Èó¥Á∫øÈ¢ÑËßà'
+        }
       },
       timelinePlaceholders: {
         today: 'Â§úÈáåËá™Âä®ÁîüÊàê‰Ω†ÁöÑÊó∂Èó¥Á∫ø',
