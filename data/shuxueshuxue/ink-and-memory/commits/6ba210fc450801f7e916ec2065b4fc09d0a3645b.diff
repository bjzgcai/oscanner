*** FILE: .gitignore ***
@@ -5,6 +5,7 @@ backend/.polycache/
 backend/benchmark/
 __pycache__/
 *.pyc
+AGENTS.md
 
 # Node
 frontend/node_modules/

*** FILE: CLAUDE.md ***
@@ -1,4 +1,4 @@
-# Ink & Memory - Development & Deployment Guide
+# Ink & Memory - Complete Development Guide
 
 ## üöÄ Deployment to Production
 
@@ -153,58 +153,550 @@ python server.py
 Create `backend/models.json` with your API configuration.
 The backend uses PolyCLI's model configuration system.
 
-## üìù Key Features & Implementation
+---
+
+## üìù CRITICAL IMPLEMENTATION DETAILS
+
+### 1. Comment Positioning System (SCROLL-INDEPENDENT)
+
+**Problem Solved**: Comments were shifting position when scrolling then clicking on text.
+
+**Solution** (`frontend/src/App.tsx:998-1042`):
+- Use `offsetTop` (document-relative) instead of `getBoundingClientRect()` (viewport-relative)
+- Position comments relative to their cell wrapper (the div with `position: relative`)
+- Account for all padding/margins in calculation
+
+**Key Code**:
+```typescript
+// Get textarea for this group's cell
+const cellTextarea = textareaRefs.current.get(group.cellId);
+const cellWrapper = cellTextarea.parentElement; // The div with position: relative
+const cellOffsetTop = cellWrapper.offsetTop;
+
+// Calculate line height
+const computedStyle = window.getComputedStyle(cellTextarea);
+const fontSize = parseFloat(computedStyle.fontSize) || 18;
+const lineHeightRatio = parseFloat(computedStyle.lineHeight) / fontSize || 1.8;
+const lineHeight = fontSize * lineHeightRatio;
+
+const containerPadding = parseFloat(window.getComputedStyle(cellWrapper.parentElement || cellWrapper).paddingLeft) || 20;
+const gap = Math.max(30, window.innerWidth * 0.02);
+const leftPosition = containerPadding + group.maxLineWidth + gap;
+
+// @@@ CRITICAL: Position using offsetTop (scroll-independent)
+// - cellOffsetTop: position relative to content container
+// - 20px: scroll container padding (line 884)
+// - 24px: StateChooser marginBottom (line 892)
+// - subtract 0.7 lineHeight: fine-tuned vertical alignment after iterative testing
+const topPosition = cellOffsetTop + group.centerY + 20 + 24 - (lineHeight * 0.7);
+```
+
+**Why 0.7 lineHeight?** After iterative testing:
+- 1.0 lineHeight: too far up
+- 0.5 lineHeight: too far down
+- 0.7 lineHeight: perfect alignment ‚úÖ
+
+### 2. Browser Auto-Scroll Prevention
+
+**Problem**: Browser was auto-scrolling element into view on focus, causing "lift up" effect.
+
+**Solution** (`frontend/src/App.tsx:952-956`):
+```typescript
+onFocus={(e) => {
+  // @@@ Prevent browser from scrolling element into view on focus
+  // This stops the "lift up" effect when clicking after scrolling
+  e.preventDefault();
+}}
+```
+
+### 3. Scroll Smoothness Fix
+
+**Problem**: "Stuck zones" at top and bottom where you had to scroll twice to reach true edges.
+
+**Root Cause**: Fixed stats bar (41px) at bottom not accounted for in outer container height.
+
+**Solution** (`frontend/src/App.tsx:787-794`):
+```typescript
+<div style={{
+  display: 'flex',
+  height: '100vh',
+  paddingTop: isMobile ? '0' : '48px',
+  paddingBottom: '41px',  // @@@ Space for fixed stats bar at bottom
+  fontFamily: 'system-ui, -apple-system, sans-serif',
+  boxSizing: 'border-box'  // @@@ CRITICAL: Include padding in height calculation
+}}>
+```
 
-### Energy Pool Trigger System (v1.2.0)
-- **Location**: `frontend/src/App.tsx`
-- **How it works**:
-  - Tracks weighted character count between polling intervals (every 5 seconds)
-  - Accumulates energy when text increases
-  - Triggers backend analysis when energy >= 40
-  - Consumes 40 energy per request, preserves remainder
-  - Ignores deletions (negative weight changes)
+### 4. Comment Grouping by 2-Row Blocks
 
-**Weighting System:**
-- CJK characters (Chinese/Japanese/Korean): 2 weight
-- Sentence punctuation (.!?„ÄÇÔºÅÔºü\n): 4 weight
-- Chinese comma (Ôºå): 0 weight (ignored)
-- Other characters: 1 weight
+**Algorithm** (`frontend/src/App.tsx:238-349`):
+- Calculate visual line numbers for each character (accounting for word wrap)
+- Group comments by 2-line blocks: `blockIndex = Math.floor(visualLineNumber / 2)`
+- Calculate max line width for the 2-line block
+- Position comment at vertical center: `centerY = (visualLineStart + 1) * lineHeight`
+- Create unique group key per cell: `${cell.id}-${blockIndex}`
 
-**@@@ Quote Weight Hack (non-obvious):**
-When a user quotes a voice comment (via the quote button), the quoted text gets inserted into the editor and would normally be counted as new text, triggering unwanted energy accumulation.
+**Why 2-row blocks?** Keeps comments aligned with natural reading flow without overwhelming the right margin.
 
-**Solution** (`App.tsx:241-244`):
+### 5. Comment Box Dynamic Width (Latest Change)
+
+**Evolution**:
+- **Before**: Fixed `maxWidth: 400px`, `height: 54px`, ellipsis cutoff after 3 lines
+- **Now** (`frontend/src/App.tsx:145-244`):
+  - `maxWidth: 600px` - wider expansion before wrapping
+  - `minHeight: 54px` - vertical expansion allowed
+  - `WebkitLineClamp: 3` - show up to 3 full lines
+  - `wordWrap: 'break-word'` - wrap instead of ellipsis
+
+```typescript
+<div style={{
+  minWidth: '200px',
+  maxWidth: '600px',  // @@@ Increased from 400px
+  minHeight: '54px',  // @@@ Changed from fixed height
+  // ... other styles
+}}>
+  <div style={{
+    flex: 1,
+    wordWrap: 'break-word',
+    overflowWrap: 'break-word',
+    display: '-webkit-box',
+    WebkitLineClamp: 3,  // @@@ Show up to 3 lines
+    WebkitBoxOrient: 'vertical',
+    overflow: 'hidden'
+  }}>
+    <strong>{voice}:</strong> {comment}
+  </div>
+</div>
+```
+
+### 6. Energy Pool Trigger System
+
+**Location**: `frontend/src/App.tsx` (useEffect polling logic)
+
+**How it works**:
+1. Poll every 5 seconds
+2. Calculate weighted character count: `getWeightedLength(text)`
+3. Compare with previous poll: `weightChange = currentWeight - lastWeight`
+4. If `weightChange > 0`: accumulate energy
+5. If `energy >= 40`: trigger backend analysis, consume 40 energy
+6. Preserve remainder energy for next trigger
+
+**Weighting System**:
+```typescript
+function getWeightedLength(text: string): number {
+  let weight = 0;
+  for (let i = 0; i < text.length; i++) {
+    const char = text[i];
+    const code = char.charCodeAt(0);
+
+    // CJK characters: 2 weight
+    if ((code >= 0x4E00 && code <= 0x9FFF) ||
+        (code >= 0x3400 && code <= 0x4DBF) ||
+        (code >= 0x3040 && code <= 0x309F) ||
+        (code >= 0x30A0 && code <= 0x30FF)) {
+      weight += 2;
+    }
+    // Sentence endings: 4 weight
+    else if ('.!?„ÄÇÔºÅÔºü\n'.includes(char)) {
+      weight += 4;
+    }
+    // Chinese comma: 0 weight (ignored)
+    else if (char === 'Ôºå') {
+      weight += 0;
+    }
+    // Other characters: 1 weight
+    else {
+      weight += 1;
+    }
+  }
+  return weight;
+}
+```
+
+**@@@ Quote Weight Hack (CRITICAL NON-OBVIOUS PATTERN)**:
+
+When user quotes a voice comment, the quoted text gets inserted into editor. Without special handling, this would count as "new text" and accumulate energy, triggering unwanted analysis.
+
+**Solution** (must be called after quote insertion):
 ```typescript
 setTimeout(() => {
   lastPollWeightRef.current = getWeightedLength(currentTextRef.current);
   console.log(`üìù Quote inserted, updated baseline weight to ${lastPollWeightRef.current}`);
 }, 0);
 ```
 
-After inserting a quote, we immediately update `lastPollWeightRef` to include the quote's weight. This "moves the baseline forward" so the next polling cycle sees no weight change from the quote. The `setTimeout(..., 0)` ensures we wait for the editor's `handleTextChange` to update `currentTextRef.current` first.
+This "moves the baseline forward" so next poll sees zero weight change from the quote.
 
-Without this hack: Quote inserted ‚Üí next poll sees +50 weight ‚Üí accumulates 50 energy ‚Üí unwanted analysis
-With this hack: Quote inserted ‚Üí baseline updated ‚Üí next poll sees 0 weight change ‚Üí no energy accumulated ‚úÖ
+**Why `setTimeout(..., 0)`?** Ensures we wait for editor's `handleTextChange` to update `currentTextRef.current` first (event loop microtask ordering).
 
-### Stateful Voice Analysis
-- **Location**: `backend/stateful_analyzer.py`
-- **Features**:
-  - Session-based state management (UUID isolation)
-  - Pruning of deleted comments
-  - Density enforcement (1 comment per sentence)
-  - No debouncing (allows multiple LLM calls on same text)
-  - Removed "one persona only once" restriction
+### 7. LLM Prompt for Comment Generation
 
-### Voice Customization
-- **Location**: `frontend/src/components/VoiceSettings.tsx`
-- **Features**:
-  - Full CRUD for voice personas
-  - Import/Export JSON configurations
-  - Text-based icon/color selection (not emoji/hex)
-  - localStorage persistence
-  - Reset to defaults
+**Location**: `backend/stateless_analyzer.py:19-137`
 
-## üêõ Troubleshooting
+**CRITICAL: Explicit Overlap Avoidance** (added after user request):
+
+The prompt now explicitly shows already highlighted phrases and instructs LLM not to overlap:
+
+```python
+# Build list of applied comments with their phrases
+existing_summary = ""
+highlighted_phrases = []
+if applied_comments:
+    existing_summary = "\n\nALREADY APPLIED COMMENTS (do not repeat or overlap with these):\n"
+    for c in applied_comments:
+        phrase = c.get('phrase', '')
+        highlighted_phrases.append(phrase)
+        existing_summary += f"- {c.get('voice', 'Unknown')} on \"{phrase}\": {c.get('comment', '')}\n"
+    existing_summary += f"\nüëâ These phrases are already highlighted: {highlighted_phrases}\n"
+    existing_summary += "üëâ Choose a DIFFERENT phrase that does NOT overlap with any of these!\n"
+
+prompt = f"""You are analyzing internal dialogue as distinct inner voice personas.
+
+Analyze this text and identify ONE NEW voice that wants to comment:
+
+"{text}"
+
+Available voice personas (ONLY use these):
+{voice_list}
+{existing_summary}
+
+Find ONE NEW voice to comment:
+1. Extract a SHORT phrase (2-6 words) that triggered it - MUST be EXACT text from above
+2. Choose a voice persona from the available list
+3. Write what this voice is saying (1-2 sentences)
+
+RULES:
+- Return ONLY ONE comment
+- DO NOT repeat any applied comments
+- DO NOT choose phrases that overlap or intersect with already highlighted phrases
+- Your chosen phrase must be completely separate from existing highlights
+- DO NOT CREATE NEW VOICE NAMES - Only use from the available list
+- Return null if nothing is worth commenting on
+- Phrase MUST be EXACT substring from text
+- Only comment on complete sentences (ending with .!?„ÄÇÔºÅÔºü)
+- Write in the SAME LANGUAGE as the text"""
+```
+
+**Why explicit list matters**: LLMs need upfront context to avoid overlapping. Showing the exact list of highlighted phrases prevents collisions.
+
+### 8. Collision Detection in Engine
+
+**Location**: `frontend/src/engine/EditorEngine.ts` (applyVoiceComment method)
+
+The engine filters out comments whose phrases overlap with existing highlights:
+
+```typescript
+applyVoiceComment(comment: Commentor) {
+  // Check for collision with existing highlights
+  const text = this.getFullText();
+  const existingHighlights = this.state.commentors
+    .filter(c => c.appliedAt)
+    .map(c => {
+      const index = text.toLowerCase().indexOf(c.phrase.toLowerCase());
+      return { start: index, end: index + c.phrase.length };
+    })
+    .filter(h => h.start !== -1);
+
+  const newIndex = text.toLowerCase().indexOf(comment.phrase.toLowerCase());
+  if (newIndex === -1) return;
+
+  const newStart = newIndex;
+  const newEnd = newIndex + comment.phrase.length;
+
+  // Check for overlap
+  const hasCollision = existingHighlights.some(h =>
+    (newStart >= h.start && newStart < h.end) ||
+    (newEnd > h.start && newEnd <= h.end) ||
+    (newStart <= h.start && newEnd >= h.end)
+  );
+
+  if (hasCollision) {
+    console.log(`‚ö†Ô∏è Collision detected for "${comment.phrase}", skipping`);
+    return;
+  }
+
+  // Apply comment...
+}
+```
+
+### 9. Font Loading Strategy (FOIT Prevention)
+
+**Problem**: Flash of Invisible Text while fonts load.
+
+**Solution** (`frontend/index.html` + `frontend/src/App.css`):
+
+```html
+<!-- index.html: Preload critical fonts -->
+<link rel="preload" href="/Excalifont-Regular.woff2" as="font" type="font/woff2" crossorigin />
+<link rel="preload" href="/Xiaolai-Regular.ttf" as="font" type="font/ttf" crossorigin />
+```
+
+```css
+/* App.css: Use font-display: swap */
+@font-face {
+  font-family: 'Excalifont';
+  src: url('/Excalifont-Regular.woff2') format('woff2');
+  font-display: swap;  /* Show fallback immediately, swap when loaded */
+  unicode-range: U+0000-00FF, U+0100-017F, U+0180-024F, U+1E00-1EFF, U+2000-206F, U+20A0-20CF, U+2100-214F;
+}
+
+@font-face {
+  font-family: 'Xiaolai';
+  src: url('/Xiaolai-Regular.ttf') format('truetype');
+  font-display: swap;
+  unicode-range: U+4E00-9FFF, U+3400-4DBF, U+20000-2A6DF, U+F900-FAFF, U+3000-303F;
+}
+```
+
+**Why unicode-range?** Browser only downloads font if page uses characters in that range. Excalifont for Latin, Xiaolai for CJK.
+
+### 10. Per-Cell Text State Management (IME Composition)
+
+**Problem**: Chinese/Japanese IME composition causing flickering and incorrect state updates.
+
+**Solution** (`frontend/src/App.tsx:449-513`):
+
+```typescript
+// Track local text per cell ID
+const [localTexts, setLocalTexts] = useState<Map<string, string>>(new Map());
+const [composingCells, setComposingCells] = useState<Set<string>>(new Set());
+
+const handleTextChange = useCallback((cellId: string, newText: string) => {
+  setLocalTexts(prev => {
+    const next = new Map(prev);
+    next.set(cellId, newText);
+    return next;
+  });
+
+  // Only update engine if NOT composing
+  if (!composingCells.has(cellId) && engineRef.current) {
+    engineRef.current.updateTextCell(cellId, newText);
+  }
+}, [composingCells]);
+
+const handleCompositionStart = useCallback((cellId: string) => {
+  setComposingCells(prev => new Set(prev).add(cellId));
+}, []);
+
+const handleCompositionEnd = useCallback((cellId: string, e: React.CompositionEvent<HTMLTextAreaElement>) => {
+  setComposingCells(prev => {
+    const next = new Set(prev);
+    next.delete(cellId);
+    return next;
+  });
+
+  const newText = e.currentTarget.value;
+  setLocalTexts(prev => {
+    const next = new Map(prev);
+    next.set(cellId, newText);
+    return next;
+  });
+
+  if (engineRef.current) {
+    engineRef.current.updateTextCell(cellId, newText);
+  }
+}, []);
+```
+
+**Why separate local state?** During IME composition, we don't want to trigger engine updates (which would cause re-render and lose composition state). Only commit to engine on composition end.
+
+### 11. Cursor-Based Comment Navigation
+
+**Desktop**: Show comment in right margin when cursor is in highlighted phrase (`frontend/src/App.tsx:392-447`)
+
+**Mobile**: Show popup at bottom when cursor is in highlighted phrase (`frontend/src/App.tsx:1044-1084`)
+
+```typescript
+useEffect(() => {
+  if (!state || !cursorCellId) return;
+
+  const cell = state.cells.find(c => c.id === cursorCellId);
+  if (!cell || cell.type !== 'text') return;
+
+  const cellText = (cell as TextCell).content;
+  const appliedComments = state.commentors.filter(c => c.appliedAt);
+
+  // Find comment at cursor position
+  let foundComment: Commentor | null = null;
+  for (const comment of appliedComments) {
+    const index = cellText.toLowerCase().indexOf(comment.phrase.toLowerCase());
+    if (index !== -1) {
+      const start = index;
+      const end = index + comment.phrase.length;
+
+      if (cursorPosition >= start && cursorPosition <= end) {
+        foundComment = comment;
+        break;
+      }
+    }
+  }
+
+  // Mobile: Set active comment for popup
+  if (isMobile) {
+    setMobileActiveComment(foundComment);
+  }
+
+  // Desktop: Navigate to comment in group
+  if (!isMobile && foundComment) {
+    commentGroups.forEach((group, groupKey) => {
+      if (group.cellId !== cursorCellId) return;
+
+      const commentIndex = group.comments.findIndex(c => c.id === foundComment!.id);
+      if (commentIndex !== -1) {
+        setGroupPages(prev => {
+          const next = new Map(prev);
+          if (next.get(groupKey) !== commentIndex) {
+            next.set(groupKey, commentIndex);
+          }
+          return next;
+        });
+      }
+    });
+  }
+}, [cursorPosition, cursorCellId, state, commentGroups, isMobile]);
+```
+
+### 12. Agent Chat Widget System
+
+**Trigger**: Type `@` in text ‚Üí dropdown appears
+
+**Components**:
+- `AgentDropdown` (`frontend/src/components/AgentDropdown.tsx`) - voice selection dropdown
+- `ChatWidget` (`frontend/src/engine/ChatWidget.ts`) - data model for chat widget
+- `ChatWidgetUI` (`frontend/src/components/ChatWidgetUI.tsx`) - UI component
+
+**Flow**:
+1. User types `@` ‚Üí dropdown shows available voices
+2. User selects voice ‚Üí `ChatWidget` created and inserted as cell
+3. User sends message ‚Üí backend `/api/chat` endpoint called with:
+   - Voice config
+   - Conversation history
+   - Current message
+   - **All text from all text cells** (unified context)
+   - Meta prompt (optional)
+   - State prompt (optional, from StateChooser)
+4. Response displayed in chat widget
+
+**Key Code** (`frontend/src/App.tsx:630-684`):
+```typescript
+const handleChatSend = useCallback(async (widgetId: string, message: string) => {
+  const widgetCell = state.cells.find(c => c.type === 'widget' && c.id === widgetId);
+  const widgetData = widgetCell.data as ChatWidgetData;
+  const chatWidget = ChatWidget.fromData(widgetData);
+
+  // Add user message optimistically
+  chatWidget.addUserMessage(message);
+  engineRef.current.updateWidgetData(widgetId, chatWidget.getData());
+
+  setChatProcessing(prev => new Set(prev).add(widgetId));
+
+  try {
+    // Get ALL text from all text cells as unified context
+    const allText = state.cells
+      .filter(c => c.type === 'text')
+      .map(c => (c as TextCell).content)
+      .join('');
+
+    const metaPrompt = getMetaPrompt();
+    const statePrompt = selectedState && stateConfig.states[selectedState]
+      ? stateConfig.states[selectedState].prompt
+      : '';
+
+    const response = await chatWithVoice(
+      widgetData.voiceConfig.name,  // Use display name, not key
+      widgetData.voiceConfig,
+      chatWidget.getConversationHistory().slice(0, -1),
+      message,
+      allText,
+      metaPrompt,
+      statePrompt
+    );
+
+    chatWidget.addAssistantMessage(response);
+    engineRef.current.updateWidgetData(widgetId, chatWidget.getData());
+  } catch (error) {
+    console.error('Chat failed:', error);
+    chatWidget.addAssistantMessage('Sorry, I encountered an error.');
+    engineRef.current.updateWidgetData(widgetId, chatWidget.getData());
+  } finally {
+    setChatProcessing(prev => {
+      const next = new Set(prev);
+      next.delete(widgetId);
+      return next;
+    });
+  }
+}, [state, selectedState, stateConfig]);
+```
+
+### 13. State Chooser System
+
+**Purpose**: User selects emotional state ‚Üí influences LLM analysis
+
+**Components**:
+- `StateChooser` (`frontend/src/components/StateChooser.tsx`) - UI component
+- State config stored in localStorage (`state-config` key)
+- Selected state stored in localStorage (`selected-state` key)
+
+**Integration Points**:
+1. **Voice comment analysis**: State prompt appended to LLM prompt
+2. **Chat widget**: State prompt included in context
+
+**Key Code** (`frontend/src/App.tsx:530-533`):
+```typescript
+const handleStateChoose = useCallback((stateId: string) => {
+  setSelectedState(stateId);
+  localStorage.setItem('selected-state', stateId);
+}, []);
+```
+
+### 14. Mobile Optimizations
+
+**Differences from desktop**:
+1. **No left sidebar** - hidden on mobile
+2. **Floating toolbar** - top right corner (Start Fresh + Insert Agent)
+3. **Comment popup** - bottom of screen instead of right margin
+4. **No horizontal scroll** - `overflowX: 'hidden'`, `touchAction: 'pan-y'`
+
+**Detection** (`frontend/src/utils/mobileDetect.ts`):
+```typescript
+export function useMobile(): boolean {
+  const [isMobile, setIsMobile] = useState(false);
+
+  useEffect(() => {
+    const checkMobile = () => {
+      setIsMobile(window.innerWidth < 768);
+    };
+
+    checkMobile();
+    window.addEventListener('resize', checkMobile);
+    return () => window.removeEventListener('resize', checkMobile);
+  }, []);
+
+  return isMobile;
+}
+```
+
+### 15. Voice Settings System
+
+**Location**: `frontend/src/components/VoiceSettings.tsx`
+
+**Features**:
+- Add/Edit/Delete voice personas
+- Import/Export JSON configuration
+- Reset to defaults (from backend)
+- Text-based icon/color selection (not emoji/hex pickers)
+
+**Storage**: localStorage (`voice-configs` key)
+
+**Icon Options**: brain, heart, question, cloud, masks, eye, fist, lightbulb, shield, wind, fire, compass
+
+**Color Options**: blue, pink, yellow, green, purple
+
+**Integration**: Voice configs passed to EditorEngine and used in backend API calls
+
+---
+
+## üêõ Known Issues & Troubleshooting
 
 ### Frontend not updating after deployment
 ```bash
@@ -235,6 +727,19 @@ ssh -i ~/Codebase/serverManagement/keys/Jeffry.pem root@101.201.227.31 \
 # Redeploy PolyCLI and restart backend completely
 ```
 
+### Comments not appearing
+1. Check backend logs for LLM errors
+2. Verify energy >= 40 (see stats bar at bottom)
+3. Check if text has complete sentences (ends with .!?„ÄÇÔºÅÔºü)
+4. Verify voice configs are enabled in settings
+
+### Highlights overlapping
+- LLM prompt explicitly shows existing phrases
+- Engine has collision detection as backup
+- If still happening: check LLM model quality
+
+---
+
 ## üìä Monitoring
 
 ### Check Backend Logs
@@ -262,6 +767,8 @@ ssh -i ~/Codebase/serverManagement/keys/Jeffry.pem root@101.201.227.31 "
 "
 ```
 
+---
+
 ## üîê Security Notes
 
 - **API Key**: Stored in environment variable on server (not in code)
@@ -271,12 +778,141 @@ ssh -i ~/Codebase/serverManagement/keys/Jeffry.pem root@101.201.227.31 "
 - **HTTPS**: All traffic encrypted via Let's Encrypt
 - **Session Isolation**: UUID-based with TTL cleanup
 
+---
+
+## üìö File Structure Reference
+
+### Frontend Key Files
+
+```
+frontend/
+‚îú‚îÄ‚îÄ src/
+‚îÇ   ‚îú‚îÄ‚îÄ App.tsx                    # Main application component
+‚îÇ   ‚îÇ                              # - Comment positioning logic (lines 998-1042)
+‚îÇ   ‚îÇ                              # - Energy pool system (useEffect polling)
+‚îÇ   ‚îÇ                              # - Per-cell text management
+‚îÇ   ‚îÇ                              # - Comment grouping algorithm
+‚îÇ   ‚îÇ                              # - Mobile/desktop responsiveness
+‚îÇ   ‚îÇ
+‚îÇ   ‚îú‚îÄ‚îÄ App.css                    # Styles + font loading
+‚îÇ   ‚îÇ                              # - Font-display: swap for FOIT prevention
+‚îÇ   ‚îÇ                              # - Watercolor highlight effects
+‚îÇ   ‚îÇ                              # - Animations
+‚îÇ   ‚îÇ
+‚îÇ   ‚îú‚îÄ‚îÄ engine/
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EditorEngine.ts        # Core state management
+‚îÇ   ‚îÇ   ‚îÇ                          # - Collision detection
+‚îÇ   ‚îÇ   ‚îÇ                          # - Cell management
+‚îÇ   ‚îÇ   ‚îÇ                          # - Comment application
+‚îÇ   ‚îÇ   ‚îÇ
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChatWidget.ts          # Chat widget data model
+‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ChatWidget.tsx         # (unused, logic in App.tsx)
+‚îÇ   ‚îÇ
+‚îÇ   ‚îú‚îÄ‚îÄ components/
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ VoiceSettings.tsx      # Voice persona CRUD
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StateChooser.tsx       # Emotional state selector
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AgentDropdown.tsx      # @ voice selection dropdown
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ChatWidgetUI.tsx       # Chat widget UI
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CalendarView.tsx       # Memory calendar (localStorage-based)
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AnalysisView.tsx       # Session analysis
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AboutView.tsx          # About page
+‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LeftSidebar.tsx        # Navigation sidebar
+‚îÇ   ‚îÇ
+‚îÇ   ‚îú‚îÄ‚îÄ api/
+‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ voiceApi.ts            # Backend API calls
+‚îÇ   ‚îÇ                              # - /api/analyze (voice comments)
+‚îÇ   ‚îÇ                              # - /api/chat (agent chat)
+‚îÇ   ‚îÇ                              # - /api/voices (voice configs)
+‚îÇ   ‚îÇ
+‚îÇ   ‚îú‚îÄ‚îÄ utils/
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ voiceStorage.ts        # localStorage utilities
+‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mobileDetect.ts        # Mobile detection hook
+‚îÇ   ‚îÇ
+‚îÇ   ‚îî‚îÄ‚îÄ types/
+‚îÇ       ‚îî‚îÄ‚îÄ voice.ts               # TypeScript interfaces
+‚îÇ
+‚îú‚îÄ‚îÄ index.html                     # Font preloading
+‚îú‚îÄ‚îÄ vite.config.ts                 # Build config (base path!)
+‚îî‚îÄ‚îÄ package.json                   # Dependencies
+```
+
+### Backend Key Files
+
+```
+backend/
+‚îú‚îÄ‚îÄ server.py                      # Main server (currently unused?)
+‚îú‚îÄ‚îÄ server_stateless.py            # Stateless server (NOT USED - ignore this)
+‚îú‚îÄ‚îÄ stateless_analyzer.py          # LLM prompt + analysis logic
+‚îÇ                                  # - Explicit overlap avoidance
+‚îÇ                                  # - Voice selection
+‚îÇ                                  # - Phrase extraction
+‚îÇ
+‚îú‚îÄ‚îÄ config.py                      # Voice archetypes + model config
+‚îú‚îÄ‚îÄ models.json                    # API credentials (gitignored)
+‚îî‚îÄ‚îÄ .venv/                         # Python virtual environment
+```
+
+---
+
+## üéØ Critical Patterns to Remember
+
+### Pattern 1: Scroll-Independent Positioning
+Always use `offsetTop` for absolute positioning in scrollable containers. Never use `getBoundingClientRect()` unless you specifically need viewport-relative coordinates.
+
+### Pattern 2: Quote Weight Hack
+When inserting text programmatically that should NOT count toward energy accumulation, immediately update the baseline weight reference:
+```typescript
+setTimeout(() => {
+  lastPollWeightRef.current = getWeightedLength(currentTextRef.current);
+}, 0);
+```
+
+### Pattern 3: IME Composition Handling
+Never update state during composition. Track composing cells separately and only commit on composition end.
+
+### Pattern 4: Collision Detection
+Always check for overlapping highlights both in LLM prompt (upfront) and in engine (backup). LLMs are not 100% reliable.
+
+### Pattern 5: Per-Cell State Management
+In multi-cell editors, always track state per cell ID. Never use array indices (they change when cells are added/deleted).
+
+### Pattern 6: Mobile-First Responsiveness
+Use `useMobile()` hook to detect screen size, then conditionally render different layouts (not just CSS media queries).
+
+### Pattern 7: Energy Pool Polling
+Poll state at fixed intervals, calculate deltas, accumulate energy only on positive changes. Ignore deletions.
+
+### Pattern 8: Font Loading Strategy
+Preload critical fonts in HTML, use `font-display: swap` in CSS, specify unicode-range to avoid downloading unused fonts.
+
+---
+
 ## üìö Related Documentation
 
 - **Server Infrastructure**: `~/Codebase/serverManagement/CLAUDE.md`
 - **README**: `README.md` (user-facing documentation)
 - **PolyCLI**: `~/Codebase/PolyCLI/README.md`
 
 ---
-*Last updated: 2025-10-21*
-*Version: v1.2.0-energy-pool*
+
+## üîÑ Recent Changes (Last Session)
+
+### Comment Box Width Expansion
+- **Changed**: `maxWidth` from 400px to 600px
+- **Changed**: `height: 54px` to `minHeight: 54px`
+- **Changed**: Removed ellipsis cutoff, added 3-line clamp
+- **Result**: Comments now expand horizontally before wrapping, show up to 3 full lines
+
+### LLM Prompt Overlap Avoidance
+- **Added**: Explicit list of already highlighted phrases in prompt
+- **Added**: Instructions to avoid overlapping with existing highlights
+- **Result**: LLM now receives upfront context about existing highlights
+
+### Comment Positioning Fine-Tuning
+- **Iteratively adjusted**: Vertical offset from 1.0 ‚Üí 0.5 ‚Üí 0.7 lineHeight
+- **Result**: Perfect alignment with highlighted text
+
+---
+
+*Last updated: 2025-01-XX*
+*Version: v1.3.0-dynamic-width*

*** FILE: frontend/src/App.tsx ***
@@ -7,7 +7,8 @@ import './App.css';
 import {
   FaSync,
   FaBrain, FaHeart, FaQuestion, FaCloud, FaTheaterMasks, FaEye,
-  FaFistRaised, FaLightbulb, FaShieldAlt, FaWind, FaFire, FaCompass
+  FaFistRaised, FaLightbulb, FaShieldAlt, FaWind, FaFire, FaCompass,
+  FaAlignRight
 } from 'react-icons/fa';
 import LeftSidebar from './components/LeftSidebar';
 import VoiceSettings from './components/VoiceSettings';
@@ -23,7 +24,17 @@ import { getDefaultVoices, chatWithVoice } from './api/voiceApi';
 import { useMobile } from './utils/mobileDetect';
 
 // @@@ Left Toolbar Component - floating toolbelt within left margin
-function LeftToolbar({ onStartFresh, onInsertAgent }: { onStartFresh: () => void; onInsertAgent: () => void }) {
+function LeftToolbar({
+  onStartFresh,
+  onInsertAgent,
+  onToggleAlign,
+  isAligned
+}: {
+  onStartFresh: () => void;
+  onInsertAgent: () => void;
+  onToggleAlign: () => void;
+  isAligned: boolean;
+}) {
   return (
     <div style={{
       position: 'sticky',
@@ -93,6 +104,31 @@ function LeftToolbar({ onStartFresh, onInsertAgent }: { onStartFresh: () => void
       >
         @
       </button>
+
+      <button
+        onClick={onToggleAlign}
+        title={isAligned ? "Unalign Comments" : "Align Comments Right"}
+        style={{
+          width: '36px',
+          height: '36px',
+          border: 'none',
+          borderRadius: '4px',
+          backgroundColor: isAligned ? '#e3f2fd' : '#fff',
+          cursor: 'pointer',
+          display: 'flex',
+          alignItems: 'center',
+          justifyContent: 'center',
+          transition: 'all 0.2s ease'
+        }}
+        onMouseEnter={(e) => {
+          e.currentTarget.style.backgroundColor = isAligned ? '#bbdefb' : '#f0f0f0';
+        }}
+        onMouseLeave={(e) => {
+          e.currentTarget.style.backgroundColor = isAligned ? '#e3f2fd' : '#fff';
+        }}
+      >
+        <FaAlignRight size={18} color={isAligned ? '#1976d2' : '#333'} />
+      </button>
     </div>
   );
 }
@@ -174,8 +210,8 @@ function CommentGroupCard({
         left: `${position.left}px`,
         transform: `translateY(-50%) ${isHovered ? 'scale(1.02)' : 'scale(1)'}`,
         minWidth: '200px',
-        maxWidth: '400px',
-        height: '54px',
+        maxWidth: '600px',  // @@@ Increased from 400px to allow more expansion
+        minHeight: '54px',  // @@@ Changed from fixed height to minHeight for vertical expansion
         padding: '8px 12px',
         background: colors.gradient,
         borderLeft: `2px solid ${colors.glow}`,
@@ -200,16 +236,16 @@ function CommentGroupCard({
       <div style={{
         display: 'flex',
         gap: '10px',
-        height: '100%',
-        alignItems: 'center'
+        alignItems: 'flex-start'  // @@@ Changed from 'center' to align top for multi-line text
       }}>
         <div style={{
           display: 'flex',
           flexDirection: 'column',
           alignItems: 'center',
-          justifyContent: 'center',
+          justifyContent: 'flex-start',  // @@@ Changed from 'center' to top-align with text
           flexShrink: 0,
-          width: '24px'
+          width: '24px',
+          paddingTop: '2px'  // @@@ Slight padding to align icon with first line
         }}>
           <Icon size={15} color={colors.text} style={{ opacity: 0.75 }} />
           {comments.length > 1 && (
@@ -227,13 +263,14 @@ function CommentGroupCard({
 
         <div style={{
           flex: 1,
-          overflow: 'hidden',
-          textOverflow: 'ellipsis',
+          color: colors.text,
+          opacity: 0.85,
+          wordWrap: 'break-word',  // @@@ Allow text to wrap instead of ellipsis
+          overflowWrap: 'break-word',
           display: '-webkit-box',
-          WebkitLineClamp: 3,
+          WebkitLineClamp: 3,  // @@@ Limit to 3 lines
           WebkitBoxOrient: 'vertical',
-          color: colors.text,
-          opacity: 0.85
+          overflow: 'hidden'
         }}>
           <strong style={{ fontWeight: 600 }}>{currentComment.voice}:</strong> {currentComment.comment}
         </div>
@@ -283,6 +320,9 @@ export default function App() {
   const [refsReady, setRefsReady] = useState(0);
   const refsReadyTriggered = useRef(false);
 
+  // @@@ Comment alignment state
+  const [commentsAligned, setCommentsAligned] = useState(false);
+
   // @@@ Reset refs ready flag when returning to writing view
   useEffect(() => {
     if (currentView === 'writing') {
@@ -715,6 +755,11 @@ export default function App() {
     }, 0);
   }, [state]);
 
+  // @@@ Toggle comment alignment
+  const handleToggleAlign = useCallback(() => {
+    setCommentsAligned(prev => !prev);
+  }, []);
+
   // @@@ Handle @ key press for agent dropdown
   const handleKeyDown = useCallback((cellId: string, e: React.KeyboardEvent<HTMLTextAreaElement>) => {
     if (e.key === '@' && !composingCells.has(cellId)) {
@@ -945,7 +990,12 @@ export default function App() {
               flexShrink: 0,
               marginLeft: '12px'
             }}>
-              <LeftToolbar onStartFresh={handleStartFresh} onInsertAgent={handleInsertAgent} />
+              <LeftToolbar
+                onStartFresh={handleStartFresh}
+                onInsertAgent={handleInsertAgent}
+                onToggleAlign={handleToggleAlign}
+                isAligned={commentsAligned}
+              />
             </div>
           )}
 
@@ -1139,29 +1189,38 @@ export default function App() {
                 </div>
 
                 {/* Comments layer (absolute positioned) - hide on mobile */}
-                {!isMobile && Array.from(commentGroups.entries()).map(([groupKey, group]) => {
-                  const currentIndex = groupPages.get(groupKey) || 0;
+                {!isMobile && (() => {
+                  // @@@ Calculate global max line width across all groups for alignment
+                  const globalMaxLineWidth = Math.max(
+                    0,
+                    ...Array.from(commentGroups.values()).map(g => g.maxLineWidth)
+                  );
+
+                  return Array.from(commentGroups.entries()).map(([groupKey, group]) => {
+                    const currentIndex = groupPages.get(groupKey) || 0;
 
-                  // @@@ Get the specific textarea for this group's cell
-                  const cellTextarea = textareaRefs.current.get(group.cellId);
-                  if (!cellTextarea) return null;
+                    // @@@ Get the specific textarea for this group's cell
+                    const cellTextarea = textareaRefs.current.get(group.cellId);
+                    if (!cellTextarea) return null;
 
-                  // @@@ Use offsetTop relative to the content container (with maxWidth: 600px)
-                  // This div is at line 1031 with position: relative
-                  const cellWrapper = cellTextarea.parentElement; // The div with position: relative
-                  if (!cellWrapper) return null;
+                    // @@@ Use offsetTop relative to the content container (with maxWidth: 600px)
+                    // This div is at line 1031 with position: relative
+                    const cellWrapper = cellTextarea.parentElement; // The div with position: relative
+                    if (!cellWrapper) return null;
 
-                  const cellOffsetTop = cellWrapper.offsetTop;
+                    const cellOffsetTop = cellWrapper.offsetTop;
 
-                  // @@@ Calculate line height from textarea styles
-                  const computedStyle = window.getComputedStyle(cellTextarea);
-                  const fontSize = parseFloat(computedStyle.fontSize) || 18;
-                  const lineHeightRatio = parseFloat(computedStyle.lineHeight) / fontSize || 1.8;
-                  const lineHeight = fontSize * lineHeightRatio;
+                    // @@@ Calculate line height from textarea styles
+                    const computedStyle = window.getComputedStyle(cellTextarea);
+                    const fontSize = parseFloat(computedStyle.fontSize) || 18;
+                    const lineHeightRatio = parseFloat(computedStyle.lineHeight) / fontSize || 1.8;
+                    const lineHeight = fontSize * lineHeightRatio;
 
-                  const containerPadding = parseFloat(window.getComputedStyle(cellWrapper.parentElement || cellWrapper).paddingLeft) || 20;
-                  const gap = Math.max(30, window.innerWidth * 0.02);
-                  const leftPosition = containerPadding + group.maxLineWidth + gap;
+                    const containerPadding = parseFloat(window.getComputedStyle(cellWrapper.parentElement || cellWrapper).paddingLeft) || 20;
+                    const gap = Math.max(30, window.innerWidth * 0.02);
+                    // @@@ Use global max width when aligned, otherwise use group's max width
+                    const lineWidthToUse = commentsAligned ? globalMaxLineWidth : group.maxLineWidth;
+                    const leftPosition = containerPadding + lineWidthToUse + gap;
 
                   // @@@ Position using offsetTop (scroll-independent)
                   // centerY is already relative to cell's top, so just add:
@@ -1182,8 +1241,9 @@ export default function App() {
                         left: leftPosition
                       }}
                     />
-                  );
-                })}
+                    );
+                  });
+                })()}
 
                 {/* @@@ Mobile comment popup - show when cursor is in highlighted area */}
                 {isMobile && mobileActiveComment && (

*** FILE: frontend/src/engine/EditorEngine.ts ***
@@ -82,8 +82,8 @@ export function computeWeight(text: string): number {
 
 // @@@ Extract completed sentences (for backend analysis)
 export function getCompletedSentences(text: string): string {
-  // Split by sentence boundaries
-  const parts = text.split(/([.!?„ÄÇÔºÅÔºü]+)/);
+  // Split by sentence boundaries (including Chinese comma and newline)
+  const parts = text.split(/([.!?„ÄÇÔºÅÔºüÔºå\n]+)/);
 
   let result = '';
   for (let i = 0; i < parts.length - 1; i += 2) {
