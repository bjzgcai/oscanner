*** MODIFIED: backend/database.py (+118/-0) ***
@@ -946,6 +946,124 @@ def delete_session(user_id: int, session_id: str):
     finally:
         db.close()
 
+# ========== Timeline Auto-Generation Helpers ==========
+
+def get_users_with_activity_on_date(target_date: str, timezone: str = 'Asia/Shanghai') -> list[int]:
+    """
+    Get user IDs who updated sessions on target_date (local timezone).
+
+    Args:
+        target_date: Date string in YYYY-MM-DD format (local timezone)
+        timezone: Timezone name (default: Asia/Shanghai for Beijing)
+
+    Returns:
+        List of user_ids with non-empty sessions on that date
+
+    @@@ Timezone handling - SQLite stores UTC, we convert to local timezone for date matching
+    """
+    from datetime import datetime
+    from zoneinfo import ZoneInfo
+
+    db = get_db()
+    try:
+        # @@@ Convert target_date (local) to UTC range for database query
+        # Example: 2025-01-17 in Beijing = 2025-01-16 16:00 UTC to 2025-01-17 16:00 UTC
+        tz = ZoneInfo(timezone)
+        local_date = datetime.strptime(target_date, '%Y-%m-%d').replace(tzinfo=tz)
+
+        # Get start and end of day in UTC
+        start_of_day_local = local_date.replace(hour=0, minute=0, second=0, microsecond=0)
+        end_of_day_local = local_date.replace(hour=23, minute=59, second=59, microsecond=999999)
+
+        start_utc = start_of_day_local.astimezone(ZoneInfo('UTC'))
+        end_utc = end_of_day_local.astimezone(ZoneInfo('UTC'))
+
+        # Query sessions updated in this UTC range
+        rows = db.execute("""
+            SELECT DISTINCT user_id, editor_state_json
+            FROM user_sessions
+            WHERE updated_at >= ? AND updated_at <= ?
+        """, (start_utc.isoformat(), end_utc.isoformat())).fetchall()
+
+        # Filter users with non-empty content
+        user_ids = []
+        for row in rows:
+            try:
+                state = json.loads(row['editor_state_json'])
+                # Check if has any text cells with content
+                has_content = any(
+                    cell.get('type') == 'text' and cell.get('content', '').strip()
+                    for cell in state.get('cells', [])
+                )
+                if has_content and row['user_id'] not in user_ids:
+                    user_ids.append(row['user_id'])
+            except (json.JSONDecodeError, KeyError):
+                continue
+
+        return user_ids
+    finally:
+        db.close()
+
+def extract_text_from_sessions_on_date(user_id: int, target_date: str, timezone: str = 'Asia/Shanghai') -> str:
+    """
+    Extract all text from user's sessions updated on target_date (local timezone).
+
+    Args:
+        user_id: User ID
+        target_date: Date string in YYYY-MM-DD format (local timezone)
+        timezone: Timezone name (default: Asia/Shanghai for Beijing)
+
+    Returns:
+        Concatenated text from all text cells, joined with double newlines
+
+    @@@ Replicates frontend's getAllNotesFromSessions() logic but date-filtered
+    @@@ Timezone handling - SQLite stores UTC, we convert to local timezone for date matching
+    """
+    from datetime import datetime
+    from zoneinfo import ZoneInfo
+
+    db = get_db()
+    try:
+        # @@@ Convert target_date (local) to UTC range for database query
+        tz = ZoneInfo(timezone)
+        local_date = datetime.strptime(target_date, '%Y-%m-%d').replace(tzinfo=tz)
+
+        start_of_day_local = local_date.replace(hour=0, minute=0, second=0, microsecond=0)
+        end_of_day_local = local_date.replace(hour=23, minute=59, second=59, microsecond=999999)
+
+        start_utc = start_of_day_local.astimezone(ZoneInfo('UTC'))
+        end_utc = end_of_day_local.astimezone(ZoneInfo('UTC'))
+
+        # Get sessions updated in this UTC range
+        rows = db.execute("""
+            SELECT editor_state_json
+            FROM user_sessions
+            WHERE user_id = ?
+              AND updated_at >= ?
+              AND updated_at <= ?
+            ORDER BY updated_at DESC
+        """, (user_id, start_utc.isoformat(), end_utc.isoformat())).fetchall()
+
+        # Extract text from each session
+        all_text = []
+        for row in rows:
+            try:
+                state = json.loads(row['editor_state_json'])
+                # @@@ Same logic as frontend: filter text cells, extract content
+                text = '\n\n'.join(
+                    cell['content']
+                    for cell in state.get('cells', [])
+                    if cell.get('type') == 'text' and cell.get('content', '').strip()
+                )
+                if text.strip():
+                    all_text.append(text)
+            except (json.JSONDecodeError, KeyError):
+                continue
+
+        return '\n\n'.join(all_text)
+    finally:
+        db.close()
+
 # ========== Daily Pictures ==========
 
 def save_daily_picture(user_id: int, date: str, image_base64: str, prompt: str = None, thumbnail_base64: str = None):

*** ADDED: backend/scheduler.py (+169/-0) ***
@@ -0,0 +1,169 @@
+#!/usr/bin/env python3
+"""
+Timeline auto-generation scheduler for Ink & Memory.
+
+Generates daily timeline images for users at midnight (Beijing time by default).
+Runs concurrently for all users with activity on the previous day.
+"""
+
+import asyncio
+from concurrent.futures import ThreadPoolExecutor, as_completed
+from datetime import datetime, timedelta
+from zoneinfo import ZoneInfo
+import database
+from server import generate_daily_picture
+
+
+async def generate_for_user(user_id: int, text: str, date: str) -> dict:
+    """
+    Generate timeline image for a single user (async wrapper).
+
+    Args:
+        user_id: User ID
+        text: Text content from user's sessions on that date
+        date: Date string (YYYY-MM-DD)
+
+    Returns:
+        dict with success status and metadata
+    """
+    try:
+        # @@@ Check if image already exists for this date (avoid duplicates)
+        existing_pictures = database.get_daily_pictures(user_id, limit=1000)
+        if any(p['date'] == date for p in existing_pictures):
+            print(f"â­ï¸  User {user_id}: Image already exists for {date}, skipping")
+            return {"success": True, "skipped": True, "user_id": user_id, "date": date}
+
+        # Call the existing PolyCLI session function (runs in thread pool)
+        print(f"ðŸŽ¨ User {user_id}: Generating image for {date} ({len(text)} chars)")
+        loop = asyncio.get_event_loop()
+        result = await loop.run_in_executor(
+            None,
+            lambda: generate_daily_picture(text, user_id, target_date=date)
+        )
+
+        if result and 'image_base64' in result:
+            # Save to database with explicit date
+            database.save_daily_picture(
+                user_id=user_id,
+                date=date,
+                image_base64=result['image_base64'],
+                thumbnail_base64=result.get('thumbnail_base64'),
+                prompt=result.get('prompt')
+            )
+            print(f"âœ… User {user_id}: Successfully generated and saved image for {date}")
+            return {"success": True, "user_id": user_id, "date": date}
+        else:
+            print(f"âŒ User {user_id}: Generation failed - no image returned")
+            return {"success": False, "error": "No image returned", "user_id": user_id, "date": date}
+
+    except Exception as e:
+        print(f"âŒ User {user_id}: Error generating image for {date}: {e}")
+        return {"success": False, "error": str(e), "user_id": user_id, "date": date}
+
+
+async def generate_timeline_images_for_date(target_date: str, timezone: str = 'Asia/Shanghai', max_concurrent: int = 5):
+    """
+    Generate timeline images for all users with activity on target_date.
+
+    Args:
+        target_date: Date string (YYYY-MM-DD) in local timezone
+        timezone: Timezone name (default: Asia/Shanghai for Beijing)
+        max_concurrent: Maximum concurrent generations (rate limiting)
+
+    Returns:
+        dict with statistics: total, success, failed, skipped
+    """
+    print(f"\n{'='*60}")
+    print(f"ðŸ“… Timeline Auto-Generation Started")
+    print(f"   Date: {target_date} ({timezone})")
+    print(f"   Max concurrent: {max_concurrent}")
+    print(f"{'='*60}\n")
+
+    try:
+        # Step 1: Get users with activity on this date
+        user_ids = database.get_users_with_activity_on_date(target_date, timezone)
+        print(f"ðŸ“Š Found {len(user_ids)} users with activity on {target_date}")
+
+        if not user_ids:
+            print("â„¹ï¸  No users with activity, exiting")
+            return {"total": 0, "success": 0, "failed": 0, "skipped": 0}
+
+        # Step 2: Extract text for each user
+        tasks = []
+        for user_id in user_ids:
+            try:
+                text = database.extract_text_from_sessions_on_date(user_id, target_date, timezone)
+                if text.strip():
+                    # Create async task with semaphore for rate limiting
+                    task = generate_for_user(user_id, text, target_date)
+                    tasks.append(task)
+                else:
+                    print(f"â­ï¸  User {user_id}: No text content, skipping")
+            except Exception as e:
+                print(f"âŒ User {user_id}: Error extracting text: {e}")
+                continue
+
+        print(f"ðŸš€ Starting generation for {len(tasks)} users (batched: {max_concurrent} concurrent)")
+
+        # Step 3: Run with rate limiting (semaphore)
+        semaphore = asyncio.Semaphore(max_concurrent)
+
+        async def bounded_generate(task):
+            async with semaphore:
+                return await task
+
+        results = await asyncio.gather(*[bounded_generate(task) for task in tasks], return_exceptions=True)
+
+        # Step 4: Summarize results
+        success_count = sum(1 for r in results if isinstance(r, dict) and r.get('success') and not r.get('skipped'))
+        failed_count = sum(1 for r in results if isinstance(r, dict) and not r.get('success'))
+        skipped_count = sum(1 for r in results if isinstance(r, dict) and r.get('skipped'))
+        exception_count = sum(1 for r in results if isinstance(r, Exception))
+
+        print(f"\n{'='*60}")
+        print(f"âœ… Timeline Auto-Generation Completed")
+        print(f"   Total: {len(tasks)}")
+        print(f"   Success: {success_count}")
+        print(f"   Skipped: {skipped_count}")
+        print(f"   Failed: {failed_count + exception_count}")
+        print(f"{'='*60}\n")
+
+        return {
+            "total": len(tasks),
+            "success": success_count,
+            "failed": failed_count + exception_count,
+            "skipped": skipped_count
+        }
+
+    except Exception as e:
+        print(f"âŒ Timeline auto-generation failed: {e}")
+        import traceback
+        traceback.print_exc()
+        return {"total": 0, "success": 0, "failed": 0, "skipped": 0, "error": str(e)}
+
+
+def get_previous_day(timezone: str = 'Asia/Shanghai') -> str:
+    """
+    Get previous day's date in YYYY-MM-DD format (local timezone).
+
+    Args:
+        timezone: Timezone name
+
+    Returns:
+        Date string in YYYY-MM-DD format
+    """
+    tz = ZoneInfo(timezone)
+    now = datetime.now(tz)
+    yesterday = now - timedelta(days=1)
+    return yesterday.strftime('%Y-%m-%d')
+
+
+# @@@ Scheduler job function (called by APScheduler)
+async def daily_generation_job(timezone: str = 'Asia/Shanghai'):
+    """
+    Daily job to generate timeline images for yesterday.
+
+    Called at midnight in the specified timezone.
+    """
+    target_date = get_previous_day(timezone)
+    await generate_timeline_images_for_date(target_date, timezone)

*** MODIFIED: backend/server.py (+91/-3) ***
@@ -1,6 +1,7 @@
 #!/usr/bin/env python3
 """FastAPI-based voice analysis server with sync API support."""
 
+import asyncio
 import httpx
 from fastapi import FastAPI, HTTPException, Depends, Header
 from fastapi.middleware.cors import CORSMiddleware
@@ -419,15 +420,28 @@ def analyze_patterns(all_notes: str, user_id: int):
     description="Generate an artistic image based on user's daily notes",
     params={
         "all_notes": {"type": "str"},
-        "user_id": {"type": "int"}
+        "user_id": {"type": "int"},
+        "target_date": {"type": "str"}  # Optional: YYYY-MM-DD format
     },
     category="Creative"
 )
-def generate_daily_picture(all_notes: str, user_id: int):
-    """Generate an image based on the essence of user's daily notes."""
+def generate_daily_picture(all_notes: str, user_id: int, target_date: str = None):
+    """Generate an image based on the essence of user's daily notes.
+
+    Args:
+        all_notes: Text content from user's notes
+        user_id: User ID
+        target_date: Optional date string (YYYY-MM-DD). If None, uses today.
+    """
+    from datetime import datetime
+
+    if target_date is None:
+        target_date = datetime.now().strftime('%Y-%m-%d')
+
     print(f"\n{'='*60}")
     print(f"ðŸŽ¨ generate_daily_picture() called")
     print(f"   Notes length: {len(all_notes)} chars")
+    print(f"   Target date: {target_date}")
     print(f"{'='*60}\n")
 
     import requests
@@ -654,6 +668,45 @@ def generate_daily_picture(all_notes: str, user_id: int):
     allow_headers=["*"],
 )
 
+# ========== Timeline Auto-Generation Scheduler ==========
+
+from apscheduler.schedulers.asyncio import AsyncIOScheduler
+import scheduler as timeline_scheduler
+
+# Create scheduler instance
+timeline_gen_scheduler = AsyncIOScheduler()
+
+@app.on_event("startup")
+async def startup_scheduler():
+    """Start the timeline auto-generation scheduler on app startup."""
+    print("\n" + "="*60)
+    print("ðŸ“… Starting Timeline Auto-Generation Scheduler")
+    print("   Schedule: Daily at 00:00 (midnight, Asia/Shanghai timezone)")
+    print("   Generates timeline images for previous day")
+    print("="*60 + "\n")
+
+    # @@@ asyncio.run() creates new event loop for scheduler thread
+    timeline_gen_scheduler.add_job(
+        lambda: asyncio.run(timeline_scheduler.daily_generation_job()),
+        'cron',
+        hour=0,
+        minute=0,
+        timezone='Asia/Shanghai',
+        id='daily_timeline_generation',
+        name='Generate timeline images for yesterday',
+        replace_existing=True
+    )
+
+    timeline_gen_scheduler.start()
+    print("âœ… Scheduler started - next run at midnight (00:00 Asia/Shanghai)\n")
+
+@app.on_event("shutdown")
+async def shutdown_scheduler():
+    """Shutdown the scheduler gracefully."""
+    print("\nðŸ“… Shutting down timeline scheduler...")
+    timeline_gen_scheduler.shutdown(wait=False)
+    print("âœ… Scheduler shutdown complete\n")
+
 # ========== Request/Response Models ==========
 
 class RegisterRequest(BaseModel):
@@ -1193,6 +1246,41 @@ def get_default_voices():
     """Get default voice configurations"""
     return config.VOICE_ARCHETYPES
 
+@app.post("/api/admin/trigger-timeline-generation")
+async def trigger_timeline_generation(date: str = None, timezone: str = 'Asia/Shanghai'):
+    """
+    Manually trigger timeline image generation for a specific date (testing/admin).
+
+    Args:
+        date: Target date in YYYY-MM-DD format (defaults to yesterday)
+        timezone: Timezone name (default: Asia/Shanghai)
+
+    Returns:
+        Generation statistics: total, success, failed, skipped
+    """
+    if date is None:
+        date = timeline_scheduler.get_previous_day(timezone)
+
+    print(f"ðŸ”§ Manual trigger: Generating timeline images for {date}")
+
+    try:
+        result = await timeline_scheduler.generate_timeline_images_for_date(date, timezone)
+        return {
+            "success": True,
+            "date": date,
+            "timezone": timezone,
+            **result
+        }
+    except Exception as e:
+        import traceback
+        traceback.print_exc()
+        return {
+            "success": False,
+            "error": str(e),
+            "date": date,
+            "timezone": timezone
+        }
+
 # ========== Deck & Voice Management ==========
 
 class DeckCreateRequest(BaseModel):
