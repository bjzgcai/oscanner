*** MODIFIED: backend/scheduler.py (+10/-9) ***
@@ -21,7 +21,7 @@
 from server import generate_daily_picture
 
 
-async def generate_for_user(user_id: int, text: str, date: str) -> dict:
+async def generate_for_user(user_id: int, text: str, date: str, timezone: str) -> dict:
     """
     Generate timeline image for a single user (async wrapper).
 
@@ -34,18 +34,19 @@ async def generate_for_user(user_id: int, text: str, date: str) -> dict:
         dict with success status and metadata
     """
     try:
-        # @@@ Check if image already exists for this date (avoid duplicates)
-        existing_pictures = database.get_daily_pictures(user_id, limit=1000)
-        if any(p['date'] == date for p in existing_pictures):
-            print(f"‚è≠Ô∏è  User {user_id}: Image already exists for {date}, skipping")
-            return {"success": True, "skipped": True, "user_id": user_id, "date": date}
-
         # Call the existing PolyCLI session function (runs in thread pool)
         print(f"üé® User {user_id}: Generating image for {date} ({len(text)} chars)")
         loop = asyncio.get_event_loop()
         result = await loop.run_in_executor(
             None,
-            lambda: generate_daily_picture(text, user_id, target_date=date)
+            lambda: generate_daily_picture(
+                user_id=user_id,
+                target_date=date,
+                timezone=timezone,
+                notes_override=text,
+                skip_if_exists=True,
+                dry_run=False,
+            )
         )
 
         if result and 'image_base64' in result:
@@ -102,7 +103,7 @@ async def generate_timeline_images_for_date(target_date: str, timezone: str = 'A
                 text = database.extract_text_from_sessions_on_date(user_id, target_date, timezone)
                 if text.strip():
                     # Create async task with semaphore for rate limiting
-                    task = generate_for_user(user_id, text, target_date)
+                    task = generate_for_user(user_id, text, target_date, timezone)
                     tasks.append(task)
                 else:
                     print(f"‚è≠Ô∏è  User {user_id}: No text content, skipping")

*** MODIFIED: backend/server.py (+161/-63) ***
@@ -538,30 +538,55 @@ def analyze_patterns(
         return {"patterns": []}
 
 
-@session_def(
-    name="Generate Daily Picture",
-    description="Generate an artistic image based on user's daily notes",
-    params={
-        "user_id": {"type": "int"},
-        "target_date": {"type": "str"},  # Optional: YYYY-MM-DD format
-    },
-    category="Creative",
-)
-def generate_daily_picture(user_id: int, target_date: str = None):
-    """Generate an image based on the essence of user's daily notes.
+def _today_in_tz(tz_name: str) -> str:
+    from zoneinfo import ZoneInfo
+    now = datetime.now(ZoneInfo(tz_name))
+    return now.strftime("%Y-%m-%d")
 
-    Args:
-        user_id: User ID
-        target_date: Optional date string (YYYY-MM-DD). If None, uses today.
-    """
-    from datetime import datetime
 
-    notes = _load_all_notes_text(user_id)
-    if not notes.strip():
-        return {"image_base64": "", "thumbnail_base64": "", "prompt": ""}
+def _generate_picture_for_date(
+    user_id: int,
+    target_date: Optional[str] = None,
+    *,
+    timezone: str = "Asia/Shanghai",
+    notes_override: Optional[str] = None,
+    skip_if_exists: bool = False,
+    dry_run: bool = False,
+):
+    """
+    Shared generator for daily pictures.
 
-    if target_date is None:
-        target_date = datetime.now().strftime("%Y-%m-%d")
+    - Extracts notes for the given date (or uses override).
+    - Generates description + image.
+    - Saves to DB unless dry_run=True.
+    """
+    target_date = target_date or _today_in_tz(timezone)
+    target_date = target_date.strip()
+
+    if skip_if_exists and not dry_run:
+        existing = database.get_daily_pictures_range(user_id, target_date, target_date, limit=1)
+        if existing:
+            return {
+                "skipped": True,
+                "reason": "already exists",
+                "date": target_date,
+                "image_base64": existing[0]["base64"],
+                "thumbnail_base64": existing[0]["base64"],
+                "prompt": existing[0].get("prompt") or "",
+            }
+
+    notes = notes_override if notes_override is not None else database.extract_text_from_sessions_on_date(
+        user_id, target_date, timezone
+    )
+    if not (notes or "").strip():
+        return {
+            "skipped": True,
+            "reason": "no notes for date",
+            "date": target_date,
+            "image_base64": "",
+            "thumbnail_base64": "",
+            "prompt": "",
+        }
 
     print(f"\n{'=' * 60}")
     print(f"üé® generate_daily_picture() called")
@@ -589,9 +614,7 @@ def generate_daily_picture(user_id: int, target_date: str = None):
                 recent_prompts_text += "\n‚ö†Ô∏è IMPORTANT: Create something COMPLETELY DIFFERENT from all previous descriptions above!\n"
                 recent_prompts_text += "‚ö†Ô∏è Use different: setting, objects, style, mood, time of day, colors, composition.\n"
                 recent_prompts_text += "‚ö†Ô∏è Be creative and avoid repetition!\n"
-                print(
-                    f"üìã Found {len(recent_prompts_list)} recent prompts to avoid duplication"
-                )
+                print(f"üìã Found {len(recent_prompts_list)} recent prompts to avoid duplication")
     except Exception as e:
         print(f"‚ö†Ô∏è Could not fetch recent prompts: {e}")
 
@@ -646,7 +669,7 @@ def generate_daily_picture(user_id: int, target_date: str = None):
     )
 
     if claude_response.status_code != 200:
-        return {"image_base64": None, "error": "Failed to create image description"}
+        return {"image_base64": None, "error": "Failed to create image description", "date": target_date}
 
     claude_data = claude_response.json()
     image_description = (
@@ -657,7 +680,7 @@ def generate_daily_picture(user_id: int, target_date: str = None):
     )
 
     if not image_description:
-        return {"image_base64": None, "error": "Failed to create image description"}
+        return {"image_base64": None, "error": "Failed to create image description", "date": target_date}
 
     print(f"üìù Image description: {image_description}")
 
@@ -681,9 +704,7 @@ def generate_daily_picture(user_id: int, target_date: str = None):
                 config.IMAGE_RETRY_BASE_TIMEOUT
                 + (attempt - 1) * config.IMAGE_RETRY_TIMEOUT_INCREMENT
             )
-            print(
-                f"üé® Generating image (attempt {attempt}/{config.IMAGE_RETRY_MAX_ATTEMPTS}, timeout={timeout_seconds}s)..."
-            )
+            print(f"üé® Generating image (attempt {attempt}/{config.IMAGE_RETRY_MAX_ATTEMPTS}, timeout={timeout_seconds}s)...")
             response = requests.post(
                 url,
                 headers=headers,
@@ -694,12 +715,12 @@ def generate_daily_picture(user_id: int, target_date: str = None):
             if response.status_code != 200:
                 print(f"‚ùå Error: {response.status_code}")
                 if attempt < config.IMAGE_RETRY_MAX_ATTEMPTS:
-                    print(f"‚è≥ Retrying in 2 seconds...")
+                    print("‚è≥ Retrying in 2 seconds...")
                     import time
 
                     time.sleep(2)
                     continue
-                return {"image_base64": None, "error": "Image generation failed"}
+                return {"image_base64": None, "error": "Image generation failed", "date": target_date}
 
             data = response.json()
 
@@ -736,69 +757,116 @@ def generate_daily_picture(user_id: int, target_date: str = None):
 
                             # Full JPEG (quality 85)
                             full_output = BytesIO()
-                            img.save(
-                                full_output, format="JPEG", quality=85, optimize=True
-                            )
-                            full_jpeg = base64.b64encode(full_output.getvalue()).decode(
-                                "utf-8"
-                            )
+                            img.save(full_output, format="JPEG", quality=85, optimize=True)
+                            full_jpeg = base64.b64encode(full_output.getvalue()).decode("utf-8")
 
                             # Thumbnail JPEG (400px width, quality 60)
                             thumb_width = 400
                             thumb_height = int(img.height * (thumb_width / img.width))
-                            thumb_img = img.resize(
-                                (thumb_width, thumb_height), Image.Resampling.LANCZOS
-                            )
+                            thumb_img = img.resize((thumb_width, thumb_height), Image.Resampling.LANCZOS)
 
                             thumb_output = BytesIO()
-                            thumb_img.save(
-                                thumb_output, format="JPEG", quality=60, optimize=True
-                            )
-                            thumb_jpeg = base64.b64encode(
-                                thumb_output.getvalue()
-                            ).decode("utf-8")
-
-                            print(f"‚úÖ Image generated successfully")
+                            thumb_img.save(thumb_output, format="JPEG", quality=60, optimize=True)
+                            thumb_jpeg = base64.b64encode(thumb_output.getvalue()).decode("utf-8")
+
+                            print("‚úÖ Image generated successfully")
                             print(f"   Original PNG: {len(base64_data)} chars")
-                            print(
-                                f"   Full JPEG: {len(full_jpeg)} chars ({100 * len(full_jpeg) / len(base64_data):.1f}%)"
-                            )
-                            print(
-                                f"   Thumbnail: {len(thumb_jpeg)} chars ({100 * len(thumb_jpeg) / len(base64_data):.1f}%)"
-                            )
-
-                            return {
+                            print(f"   Full JPEG: {len(full_jpeg)} chars ({100 * len(full_jpeg) / len(base64_data):.1f}%)")
+                            print(f"   Thumbnail: {len(thumb_jpeg)} chars ({100 * len(thumb_jpeg) / len(base64_data):.1f}%)")
+
+                            result = {
                                 "image_base64": full_jpeg,
                                 "thumbnail_base64": thumb_jpeg,
                                 "prompt": image_description,
+                                "date": target_date,
                             }
+                            if not dry_run:
+                                database.save_daily_picture(
+                                    user_id=user_id,
+                                    date=target_date,
+                                    image_base64=full_jpeg,
+                                    prompt=image_description,
+                                    thumbnail_base64=thumb_jpeg,
+                                )
+                            return result
                         except Exception as e:
                             print(f"‚ö†Ô∏è JPEG conversion failed: {e}, using original PNG")
-                            return {
+                            result = {
                                 "image_base64": base64_data,
                                 "thumbnail_base64": base64_data,  # Fallback to full image
                                 "prompt": image_description,
+                                "date": target_date,
                             }
+                            if not dry_run:
+                                database.save_daily_picture(
+                                    user_id=user_id,
+                                    date=target_date,
+                                    image_base64=base64_data,
+                                    prompt=image_description,
+                                    thumbnail_base64=base64_data,
+                                )
+                            return result
 
             if attempt < config.IMAGE_RETRY_MAX_ATTEMPTS:
-                print(f"‚ö†Ô∏è No image in response, retrying...")
+                print("‚ö†Ô∏è No image in response, retrying...")
                 import time
 
                 time.sleep(2)
                 continue
-            return {"image_base64": None, "error": "No image in response"}
+            return {"image_base64": None, "error": "No image in response", "date": target_date}
 
         except Exception as e:
             print(f"‚ùå Exception on attempt {attempt}: {e}")
             if attempt < config.IMAGE_RETRY_MAX_ATTEMPTS:
-                print(f"‚è≥ Retrying in 2 seconds...")
+                print("‚è≥ Retrying in 2 seconds...")
                 import time
 
                 time.sleep(2)
                 continue
-            return {"image_base64": None, "error": str(e)}
+            return {"image_base64": None, "error": str(e), "date": target_date}
 
-    return {"image_base64": None, "error": "All retry attempts failed"}
+    return {"image_base64": None, "error": "All retry attempts failed", "date": target_date}
+
+
+@session_def(
+    name="Generate Daily Picture",
+    description="Generate an artistic image based on user's daily notes",
+    params={
+        "user_id": {"type": "int"},
+        "target_date": {"type": "str"},  # Optional: YYYY-MM-DD format
+        "notes_override": {"type": "str"},
+        "dry_run": {"type": "bool"},
+        "skip_if_exists": {"type": "bool"},
+    },
+    category="Creative",
+)
+def generate_daily_picture(
+    user_id: int,
+    target_date: str = None,
+    notes_override: str = None,
+    dry_run: bool = True,
+    skip_if_exists: bool = False,
+    timezone: str = "Asia/Shanghai",
+):
+    """
+    Generate an image for a specific date.
+
+    Defaults to dry_run=True so the caller decides whether to persist.
+    """
+    result = _generate_picture_for_date(
+        user_id=user_id,
+        target_date=target_date,
+        timezone=timezone,
+        notes_override=notes_override,
+        skip_if_exists=skip_if_exists,
+        dry_run=dry_run,
+    )
+    # PolyCLI sessions should fail loudly if no image produced
+    if result.get("skipped"):
+        raise ValueError(result.get("reason") or "Generation skipped")
+    if not result.get("image_base64"):
+        raise ValueError(result.get("error") or "Generation returned no image")
+    return result
 
 
 # ========== FastAPI Application ==========
@@ -878,7 +946,14 @@ class LoginRequest(BaseModel):
 
 class TokenResponse(BaseModel):
     token: str
-    user: dict
+
+
+class GeneratePictureRequest(BaseModel):
+    target_date: Optional[str] = None
+    notes_override: Optional[str] = None
+    dry_run: bool = False
+    skip_if_exists: bool = False
+    timezone: Optional[str] = "Asia/Shanghai"
 
 
 class ImportDataRequest(BaseModel):
@@ -1448,6 +1523,29 @@ def get_pictures(limit: int = 30, current_user: dict = Depends(get_current_user)
     pictures = database.get_daily_pictures(user_id, limit)
     return {"pictures": pictures}
 
+
+@app.post("/api/pictures/generate")
+def generate_picture_endpoint(
+    request: GeneratePictureRequest,
+    current_user: dict = Depends(get_current_user)
+):
+    """
+    Generate a picture for a specific date.
+    - If dry_run=True, returns the image but does not save.
+    - If skip_if_exists=True, returns existing image without regenerating.
+    """
+    user_id = current_user["user_id"]
+    tz = request.timezone or "Asia/Shanghai"
+    result = _generate_picture_for_date(
+        user_id=user_id,
+        target_date=request.target_date,
+        timezone=tz,
+        notes_override=request.notes_override,
+        skip_if_exists=request.skip_if_exists,
+        dry_run=request.dry_run,
+    )
+    return result
+
 @app.get("/api/pictures/range")
 def get_pictures_range(
     start_date: Optional[str] = None,

*** ADDED: backend/tests/picture_dry_run.py (+72/-0) ***
@@ -0,0 +1,72 @@
+#!/usr/bin/env python3
+"""
+Standalone dry-run tester for daily picture generation.
+
+Usage:
+  python backend/tests/picture_dry_run.py --token TOKEN [--base-url http://127.0.0.1:8765] [--date YYYY-MM-DD] [--notes "smoke"]
+
+Does not write to DB (uses dry_run=true). Exits non-zero on failure.
+"""
+
+import argparse
+import json
+import sys
+import urllib.request
+import urllib.error
+
+
+def main():
+    parser = argparse.ArgumentParser(description="Dry-run picture generation (no DB write).")
+    parser.add_argument("--base-url", default="http://127.0.0.1:8765", help="Backend base URL")
+    parser.add_argument("--token", required=True, help="Bearer token for auth")
+    parser.add_argument("--date", dest="target_date", help="Target date YYYY-MM-DD (default: today)")
+    parser.add_argument("--notes", dest="notes_override", default="smoke test", help="Override notes text for generation")
+    parser.add_argument("--timeout", type=int, default=60, help="Request timeout seconds")
+    args = parser.parse_args()
+
+    url = f"{args.base_url.rstrip('/')}/api/pictures/generate"
+    payload = {
+        "target_date": args.target_date,
+        "notes_override": args.notes_override,
+        "dry_run": True,
+        "skip_if_exists": False,
+    }
+
+    data = json.dumps(payload).encode("utf-8")
+    req = urllib.request.Request(
+        url,
+        data=data,
+        headers={
+            "Content-Type": "application/json",
+            "Authorization": f"Bearer {args.token}",
+        },
+    )
+
+    try:
+        with urllib.request.urlopen(req, timeout=args.timeout) as resp:
+            body = resp.read().decode("utf-8")
+            result = json.loads(body)
+    except urllib.error.HTTPError as e:
+        body = e.read().decode("utf-8", errors="ignore")
+        sys.stderr.write(f"HTTP error: {e.code} {e.reason}\n")
+        if body:
+            sys.stderr.write(f"Body: {body}\n")
+        sys.exit(1)
+    except Exception as e:
+        sys.stderr.write(f"Request failed: {e}\n")
+        sys.exit(1)
+
+    image_b64 = result.get("image_base64")
+    if not image_b64:
+        sys.stderr.write(f"No image_base64 in response: {result}\n")
+        sys.exit(1)
+
+    thumb_len = len(result.get("thumbnail_base64") or image_b64)
+    prompt = (result.get("prompt") or "").strip()
+    print(f"‚úÖ Dry-run generated image (base64 length: {len(image_b64)}, thumb length: {thumb_len})")
+    if prompt:
+        print(f"Prompt: {prompt[:120]}{'...' if len(prompt) > 120 else ''}")
+
+
+if __name__ == "__main__":
+    main()

*** MODIFIED: frontend/src/api/voiceApi.ts (+12/-7) ***
@@ -295,8 +295,11 @@ export async function analyzePatterns(): Promise<any[]> {
 /**
  * Generate a daily picture based on user's notes (PolyCLI direct call)
  */
-export async function generateDailyPicture(): Promise<{ image_base64: string; thumbnail_base64?: string; prompt: string }> {
+export async function generateDailyPicture(targetDate?: string, timezone?: string): Promise<{ image_base64: string; thumbnail_base64?: string; prompt: string; date?: string }> {
   const token = localStorage.getItem(STORAGE_KEYS.AUTH_TOKEN);
+  const params: Record<string, any> = {};
+  if (targetDate) params.target_date = targetDate;
+  if (timezone) params.timezone = timezone;
 
   const response = await fetch(`${API_BASE}/polycli/api/trigger-sync`, {
     method: 'POST',
@@ -306,7 +309,7 @@ export async function generateDailyPicture(): Promise<{ image_base64: string; th
     },
     body: JSON.stringify({
       session_id: 'generate_daily_picture',
-      params: { },
+      params,
       timeout: 60
     })
   });
@@ -317,15 +320,17 @@ export async function generateDailyPicture(): Promise<{ image_base64: string; th
     throw new Error(data.error || 'Image generation failed');
   }
 
-  if (data.result?.image_base64) {
+  const res: any = data.result || {};
+  if (res.image_base64) {
     return {
-      image_base64: data.result.image_base64,
-      thumbnail_base64: data.result.thumbnail_base64,
-      prompt: data.result.prompt || 'Generated from your notes'
+      image_base64: res.image_base64,
+      thumbnail_base64: res.thumbnail_base64,
+      prompt: res.prompt || 'Generated from your notes',
+      date: res.date
     };
   }
 
-  throw new Error('Image generation failed - no image in response');
+  throw new Error(res.error || res.reason || 'Image generation failed - no image in response');
 }
 
 // ========== Authenticated Endpoints (require login) ==========

*** MODIFIED: frontend/src/components/CollectionsView.tsx (+3/-2) ***
@@ -783,7 +783,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin
 
     try {
       const { generateDailyPicture, saveDailyPicture } = await import('../api/voiceApi');
-      const { image_base64, thumbnail_base64, prompt } = await generateDailyPicture();
+      const { image_base64, thumbnail_base64, prompt } = await generateDailyPicture(dateStr, timezone);
 
       if (!image_base64) {
         alert('No notes found to generate an image. Please write and save entries first.');
@@ -807,7 +807,8 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, timezone }: Timelin
       });
     } catch (error) {
       console.error('Image generation failed:', error);
-      alert('Failed to generate image. Please try again.');
+      const message = error instanceof Error ? error.message : 'Failed to generate image. Please try again.';
+      alert(message);
     } finally {
       setGeneratingForDate(null);
     }
