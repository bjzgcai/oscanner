*** MODIFIED: backend/database.py (+15/-5) ***
@@ -96,12 +96,18 @@ def create_tables(db):
       meta_prompt TEXT,
       state_config_json TEXT,
       selected_state TEXT,
+      timezone TEXT,
       first_login_completed INTEGER DEFAULT 0,
       updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
       FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
     )
     """)
 
+    try:
+        db.execute("ALTER TABLE user_preferences ADD COLUMN timezone TEXT")
+    except Exception:
+        pass
+
     # Auth sessions
     db.execute("""
     CREATE TABLE IF NOT EXISTS auth_sessions (
@@ -1290,7 +1296,7 @@ def get_friend_picture_full(user_id: int, friend_id: int, date: str):
 # ========== User Preferences ==========
 
 def save_preferences(user_id: int, voice_configs: dict = None, meta_prompt: str = None,
-                    state_config: dict = None, selected_state: str = None):
+                    state_config: dict = None, selected_state: str = None, timezone: str = None):
     """Save or update user preferences."""
     db = get_db()
     try:
@@ -1313,6 +1319,9 @@ def save_preferences(user_id: int, voice_configs: dict = None, meta_prompt: str
             if selected_state is not None:
                 updates.append("selected_state = ?")
                 params.append(selected_state)
+            if timezone is not None:
+                updates.append("timezone = ?")
+                params.append(timezone)
 
             if updates:
                 updates.append("updated_at = CURRENT_TIMESTAMP")
@@ -1321,13 +1330,14 @@ def save_preferences(user_id: int, voice_configs: dict = None, meta_prompt: str
         else:
             # Insert
             db.execute("""
-            INSERT INTO user_preferences (user_id, voice_configs_json, meta_prompt, state_config_json, selected_state)
-            VALUES (?, ?, ?, ?, ?)
+            INSERT INTO user_preferences (user_id, voice_configs_json, meta_prompt, state_config_json, selected_state, timezone)
+            VALUES (?, ?, ?, ?, ?, ?)
             """, (user_id,
                   json.dumps(voice_configs) if voice_configs else None,
                   meta_prompt,
                   json.dumps(state_config) if state_config else None,
-                  selected_state))
+                  selected_state,
+                  timezone))
 
         db.commit()
     finally:
@@ -1339,7 +1349,7 @@ def get_preferences(user_id: int):
     try:
         row = db.execute("""
         SELECT voice_configs_json, meta_prompt, state_config_json, selected_state,
-               first_login_completed, updated_at
+               timezone, first_login_completed, updated_at
         FROM user_preferences
         WHERE user_id = ?
         """, (user_id,)).fetchone()

*** MODIFIED: backend/scheduler.py (+7/-0) ***
@@ -6,6 +6,13 @@
 Runs concurrently for all users with activity on the previous day.
 """
 
+import os
+import time
+
+os.environ.setdefault('TZ', 'UTC')
+if hasattr(time, 'tzset'):
+    time.tzset()
+
 import asyncio
 from concurrent.futures import ThreadPoolExecutor, as_completed
 from datetime import datetime, timedelta

*** MODIFIED: backend/server.py (+9/-1) ***
@@ -1,6 +1,13 @@
 #!/usr/bin/env python3
 """FastAPI-based voice analysis server with sync API support."""
 
+import os
+import time
+
+os.environ.setdefault('TZ', 'UTC')
+if hasattr(time, 'tzset'):
+    time.tzset()
+
 import asyncio
 import httpx
 from fastapi import FastAPI, HTTPException, Depends, Header
@@ -1242,7 +1249,8 @@ def save_preferences_endpoint(
         voice_configs=request.get('voice_configs'),
         meta_prompt=request.get('meta_prompt'),
         state_config=request.get('state_config'),
-        selected_state=request.get('selected_state')
+        selected_state=request.get('selected_state'),
+        timezone=request.get('timezone')
     )
 
     return {"success": True}

*** MODIFIED: frontend/src/App.tsx (+96/-35) ***
@@ -299,6 +299,50 @@ export default function App() {
   const prevInspirationRef = useRef<VoiceInspiration | null>(null);
   const [_suggestionSnapshot, setSuggestionSnapshot] = useState<string>('');  // Not used yet
   const suggestionTimerRef = useRef<number | null>(null);
+  const browserTimezone = useMemo(() => {
+    try {
+      return Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
+    } catch {
+      return 'UTC';
+    }
+  }, []);
+  const timezoneSyncRef = useRef<string | null>(null);
+
+  const ensureStateForPersistence = useCallback((): EditorState | null => {
+    if (engineRef.current) {
+      const engineState = engineRef.current.getState();
+      if (!engineState.createdAt) {
+        engineState.createdAt = new Date().toISOString().split('T')[0];
+        setState({ ...engineState });
+      }
+      return engineState;
+    }
+
+    if (state && !state.createdAt) {
+      const today = new Date().toISOString().split('T')[0];
+      const nextState = { ...state, createdAt: today };
+      setState(nextState);
+      return nextState;
+    }
+
+    return state;
+  }, [state]);
+
+  const getFirstLineFromState = useCallback((editorState: EditorState) => {
+    const firstTextCell = editorState.cells.find(c => c.type === 'text') as TextCell | undefined;
+    return firstTextCell?.content.split('\n')[0].trim() || 'Untitled';
+  }, []);
+
+  const saveSessionToDatabase = useCallback(async (editorState: EditorState, firstLine?: string) => {
+    const line = firstLine ?? getFirstLineFromState(editorState);
+    const { saveSession } = await import('./api/voiceApi');
+    const sessionId = editorState.currentEntryId || crypto.randomUUID();
+    await saveSession(sessionId, editorState, line);
+    if (engineRef.current) {
+      engineRef.current.setCurrentEntryId(sessionId);
+    }
+    return sessionId;
+  }, [getFirstLineFromState]);
 
   // @@@ Detect if this is a new inspiration appearing (different from previous)
   // Only check appearing when NOT disappearing (to avoid conflict)
@@ -463,6 +507,29 @@ export default function App() {
     checkMigration();
   }, [isAuthenticated, isLoading]);
 
+  useEffect(() => {
+    if (!isAuthenticated) return;
+    const timezone = browserTimezone || 'UTC';
+    if (!timezone) return;
+    if (timezoneSyncRef.current === timezone) return;
+
+    const syncTimezone = async () => {
+      try {
+        const { getPreferences, savePreferences } = await import('./api/voiceApi');
+        const prefs = await getPreferences();
+        if ((prefs?.timezone || 'UTC') !== timezone) {
+          await savePreferences({ timezone });
+        }
+      } catch (error) {
+        console.error('Failed to sync timezone preference:', error);
+      } finally {
+        timezoneSyncRef.current = timezone;
+      }
+    };
+
+    syncTimezone();
+  }, [isAuthenticated, browserTimezone]);
+
   // Initialize engine
   useEffect(() => {
     const sessionId = crypto.randomUUID ? crypto.randomUUID() : Date.now().toString();
@@ -670,32 +737,27 @@ export default function App() {
 
   // @@@ Auto-save to database for authenticated users
   useEffect(() => {
-    if (!isAuthenticated || !state) return;
-
-    // @@@ currentEntryId is always defined after engine initialization
-    if (!state.currentEntryId) {
-      console.error('BUG: currentEntryId should always be defined after engine init');
-      return;
-    }
+    if (!isAuthenticated) return;
 
     const autoSaveTimer = setTimeout(async () => {
-      try {
-        // @@@ Auto-save: update content only, preserve existing name
-        // Date comes from created_at, so we don't include it in name
-        const firstTextCell = state.cells.find(c => c.type === 'text') as TextCell | undefined;
-        const firstLine = firstTextCell?.content.split('\n')[0].trim() || 'Untitled';
+      const currentState = ensureStateForPersistence();
+      if (!currentState) return;
+      if (!currentState.currentEntryId) {
+        console.error('BUG: currentEntryId should always be defined after engine init');
+        return;
+      }
 
-        const { saveSession } = await import('./api/voiceApi');
-        const sessionId = state.currentEntryId || crypto.randomUUID();
-        await saveSession(sessionId, state, firstLine);
+      try {
+        const firstLine = getFirstLineFromState(currentState);
+        await saveSessionToDatabase(currentState, firstLine);
         console.log('Auto-saved to database');
       } catch (error) {
         console.error('Auto-save failed:', error);
       }
-    }, 3000); // Save 3 seconds after last change
+    }, 3000);
 
     return () => clearTimeout(autoSaveTimer);
-  }, [state, isAuthenticated]);
+  }, [ensureStateForPersistence, getFirstLineFromState, isAuthenticated, saveSessionToDatabase, state]);
 
   // @@@ Group comments by 2-row blocks, accounting for widgets between cells
   const commentGroups = useMemo(() => {
@@ -1152,31 +1214,25 @@ export default function App() {
   }, [isAuthenticated]);
 
   const handleSaveToday = useCallback(async () => {
-    if (!state || !engineRef.current) return;
+    if (!engineRef.current) return;
+    const currentState = ensureStateForPersistence();
+    if (!currentState) return;
 
     try {
-      // @@@ Save to database if authenticated, localStorage if guest
-      if (isAuthenticated) {
-        // @@@ Save with title only (date comes from created_at)
-        const firstTextCell = state.cells.find(c => c.type === 'text') as TextCell | undefined;
-        const firstLine = firstTextCell?.content.split('\n')[0].trim() || 'Untitled';
-
-        // Save to database
-        const { saveSession } = await import('./api/voiceApi');
-        const sessionId = state.currentEntryId || crypto.randomUUID();
-        await saveSession(sessionId, state, firstLine);
+      const hadExistingId = Boolean(currentState.currentEntryId);
+      let updatedFlag = hadExistingId;
 
-        // Update current entry ID in engine state
-        engineRef.current.setCurrentEntryId(sessionId);
+      if (isAuthenticated) {
+        const firstLine = getFirstLineFromState(currentState);
+        const savedSessionId = await saveSessionToDatabase(currentState, firstLine);
+        engineRef.current.setCurrentEntryId(savedSessionId);
       } else {
-        // Guest mode: save to localStorage
-        const entryId = saveEntryToToday(state);
+        const entryId = saveEntryToToday(currentState);
         engineRef.current.setCurrentEntryId(entryId);
       }
 
-      // Show toast notification
       const toast = document.createElement('div');
-      toast.textContent = state.currentEntryId ? 'Saved (updated)' : 'Saved';
+      toast.textContent = updatedFlag ? 'Saved (updated)' : 'Saved';
       toast.style.cssText = `
         position: fixed;
         top: 70px;
@@ -1221,7 +1277,7 @@ export default function App() {
         setTimeout(() => document.body.removeChild(toast), 300);
       }, 2000);
     }
-  }, [state, isAuthenticated]);
+  }, [ensureStateForPersistence, getFirstLineFromState, isAuthenticated, saveSessionToDatabase]);
 
   const handleLoadEntry = useCallback((entry: CalendarEntry) => {
     if (engineRef.current) {
@@ -1235,6 +1291,11 @@ export default function App() {
         setSelectedState(loadedState.selectedState);
       }
 
+      if (!loadedState.createdAt) {
+        loadedState.createdAt = new Date().toISOString().split('T')[0];
+        engineRef.current.loadState(loadedState);
+      }
+
       // @@@ Trigger textarea resize after loading entry
       setRefsReady(prev => prev + 1);
 

*** MODIFIED: frontend/src/api/voiceApi.ts (+1/-0) ***
@@ -500,6 +500,7 @@ export async function savePreferences(preferences: {
   meta_prompt?: string;
   state_config?: any;
   selected_state?: string;
+  timezone?: string;
 }): Promise<void> {
   const response = await fetch(`${API_BASE}/api/preferences`, {
     method: 'POST',

*** MODIFIED: frontend/src/components/CalendarPopup.tsx (+2/-32) ***
@@ -8,6 +8,7 @@ import {
   deleteEntry,
   type CalendarEntry
 } from '../utils/calendarStorage';
+import { loadSessionsGroupedByDate } from '../utils/sessionGrouping';
 import { useAuth } from '../contexts/AuthContext';
 
 interface Props {
@@ -31,38 +32,7 @@ export default function CalendarPopup({ onLoadEntry, onClose, currentEntryId }:
         try {
           // Load from database - sessions imported during migration
           const { listSessions, getSession } = await import('../api/voiceApi');
-          const sessions = await listSessions();
-
-          // Group sessions by date (extract from session name which has format "YYYY-MM-DD - FirstLine")
-          const grouped: Record<string, CalendarEntry[]> = {};
-
-          for (const session of sessions) {
-            // @@@ Skip unnamed sessions (working drafts not saved yet)
-            if (!session.name) continue;
-
-            const fullSession = await getSession(session.id);
-
-            // @@@ BUGFIX: Extract date from timestamp (format: "2025-11-02 10:42:17" or "2025-11-02T10:42:17")
-            // Just take first 10 characters to get "YYYY-MM-DD"
-            let dateKey = session.created_at?.substring(0, 10) || getTodayKey();
-
-            // If name starts with YYYY-MM-DD format, use that
-            if (session.name && /^\d{4}-\d{2}-\d{2}/.test(session.name)) {
-              dateKey = session.name.split(' - ')[0];
-            }
-
-            if (!grouped[dateKey]) {
-              grouped[dateKey] = [];
-            }
-
-            grouped[dateKey].push({
-              id: session.id,
-              timestamp: new Date(session.created_at || Date.now()).getTime(),
-              state: fullSession.editor_state,
-              firstLine: session.name
-            });
-          }
-
+          const grouped = await loadSessionsGroupedByDate(listSessions, getSession, { requireName: true });
           setCalendarData(grouped);
         } catch (error) {
           console.error('Failed to load calendar from database:', error);

*** MODIFIED: frontend/src/components/CollectionsView.tsx (+82/-37) ***
@@ -6,6 +6,8 @@ import { useAuth } from '../contexts/AuthContext';
 import { STORAGE_KEYS } from '../constants/storageKeys';
 import { getDateLocale } from '../i18n';
 import type { Friend } from '../api/voiceApi';
+import { extractFirstLine } from '../utils/calendarStorage';
+import { loadSessionsGroupedByDate } from '../utils/sessionGrouping';
 
 // @@@ TypeScript interfaces
 interface TimelineDay {
@@ -222,6 +224,7 @@ interface TimelineCardProps {
   isGenerating: boolean;
   placeholder: string;
   textByDate: Map<string, string>;
+  firstLineByDate: Map<string, string>;
   dateLocale: string;
   t: (key: string, options?: any) => string;
   onImageClick: (picture: TimelinePicture) => void;
@@ -237,6 +240,7 @@ function renderTimelineCard({
   isGenerating,
   placeholder,
   textByDate,
+  firstLineByDate,
   dateLocale,
   t,
   onImageClick,
@@ -245,7 +249,8 @@ function renderTimelineCard({
   customDescription
 }: TimelineCardProps) {
   const cardCursor = dayData?.picture && !isGenerating ? 'pointer' : 'default';
-  const textContent = dayData && textByDate.get(day.date);
+  const textContent = textByDate.get(day.date);
+  const firstLine = firstLineByDate.get(day.date);
   const commentCount = dayData?.comments?.length || 0;
 
   let description = placeholder;
@@ -255,6 +260,8 @@ function renderTimelineCard({
     description = t('timeline.generating');
   } else if (day.isToday && !dayData?.picture) {
     description = placeholder;
+  } else if (firstLine) {
+    description = firstLine;
   } else if (textContent) {
     description = getTextPreview(textContent);
   } else if (commentCount > 0) {
@@ -456,6 +463,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF
   const [starredComments, setStarredComments] = useState<Commentor[]>([]);
   const [allCommentsByDate, setAllCommentsByDate] = useState<Map<string, Commentor[]>>(new Map());
   const [textByDate, setTextByDate] = useState<Map<string, string>>(new Map());
+  const [firstLineByDate, setFirstLineByDate] = useState<Map<string, string>>(new Map());
   const [pictures, setPictures] = useState<TimelinePicture[]>([]);
   const [generatingForDate, setGeneratingForDate] = useState<string | null>(null);
   const [viewingImage, setViewingImage] = useState<{ base64: string; full_base64?: string; prompt: string; date: string; origin?: 'self' | 'friend'; friendId?: number } | null>(null);
@@ -489,9 +497,10 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF
   const [, setLoadingFriends] = useState(false);
   const [friendLoadError, setFriendLoadError] = useState<string | null>(null);
   const [, setFriendTimelineError] = useState<string | null>(null);
-  const [, setLoadingFriendTimeline] = useState(false);
+  const [loadingFriendTimeline, setLoadingFriendTimeline] = useState(false);
   const scrollContainerRef = useRef<HTMLDivElement | null>(null);
   const emptyTextMap = useMemo(() => new Map<string, string>(), []);
+  const emptyFirstLineMap = useMemo(() => new Map<string, string>(), []);
   const allTimelineDays = useMemo(() => generateTimelineDays(), []);
   const filteredFriends = useMemo(() => {
     const term = friendSearchTerm.trim().toLowerCase();
@@ -547,29 +556,54 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF
   const orderedRecentFriends = orderedFriendIds
     .map(id => friendMap.get(id))
     .filter((friend): friend is Friend => Boolean(friend));
+  const friendTimelineByDate = useMemo(() => {
+    const map = new Map<string, TimelineEntryData>();
+    friendPictures.forEach(pic => {
+      map.set(pic.date, { picture: pic, comments: [] });
+    });
+    return map;
+  }, [friendPictures]);
+  const friendHasVisibleCards = useMemo(() => {
+    if (!selectedFriendId) return false;
+    return allTimelineDays.some(day => Boolean(friendTimelineByDate.get(day.date)?.picture));
+  }, [selectedFriendId, friendTimelineByDate, allTimelineDays]);
+
+  useEffect(() => {
+    console.debug('[Timeline] friend hint state', {
+      selectedFriendId,
+      isFriendPickerOpen,
+      friendPicturesCount: friendPictures.length,
+      loadingFriendTimeline,
+      visibleFriendCards: friendHasVisibleCards
+    });
+  }, [selectedFriendId, isFriendPickerOpen, friendPictures.length, loadingFriendTimeline, friendHasVisibleCards]);
 
   useEffect(() => {
     const loadTimelineData = async () => {
       // @@@ Load all comments grouped by date from database if authenticated, localStorage if guest
       if (isAuthenticated) {
         try {
           const { listSessions, getSession } = await import('../api/voiceApi');
-          const sessions = await listSessions();
+          const groupedEntries = await loadSessionsGroupedByDate(listSessions, getSession, { requireName: true });
+
           const allStarred: Commentor[] = [];
           const commentsByDate = new Map<string, Commentor[]>();
           const textByDateMap = new Map<string, string>();
+          const firstLineMap = new Map<string, string>();
 
-          for (const session of sessions) {
-            try {
-              const fullSession = await getSession(session.id);
-              const comments = fullSession.editor_state?.commentors || [];
+          Object.entries(groupedEntries).forEach(([dateKey, entries]) => {
+            if (entries.length > 0 && !firstLineMap.has(dateKey)) {
+              firstLineMap.set(dateKey, entries[0].firstLine);
+            }
 
-              // Collect starred comments for timeline cards
+            entries.forEach(entry => {
+              const state = entry.state;
+              if (!state) return;
+
+              const comments = state.commentors || [];
               const starred = comments.filter((c: Commentor) => c.feedback === 'star');
               allStarred.push(...starred);
 
-              // Group ALL comments by date (for image modal display)
-              // @@@ Use each comment's appliedAt timestamp (not session's created_at) to handle timezone properly
               comments.filter((c: Commentor) => c.appliedAt).forEach((comment: Commentor) => {
                 const commentDate = new Date(comment.appliedAt || comment.computedAt);
                 const date = getLocalDateString(commentDate);
@@ -579,29 +613,23 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF
                 commentsByDate.get(date)!.push(comment);
               });
 
-              // @@@ Extract text from session and group by creation date
-              if (fullSession.editor_state?.createdAt && fullSession.editor_state?.cells) {
-                const sessionDate = fullSession.editor_state.createdAt; // Already in YYYY-MM-DD format
-                const text = fullSession.editor_state.cells
-                  .filter((c: any) => c.type === 'text')
-                  .map((c: any) => c.content)
-                  .join(' ')
-                  .trim();
-
-                if (text) {
-                  // Append text for this date (sessions can have multiple entries per day)
-                  const existingText = textByDateMap.get(sessionDate) || '';
-                  textByDateMap.set(sessionDate, existingText ? `${existingText} ${text}` : text);
-                }
+              const text = state.cells
+                ?.filter((c: any) => c.type === 'text')
+                .map((c: any) => c.content)
+                .join(' ')
+                .trim();
+
+              if (text) {
+                const existingText = textByDateMap.get(dateKey) || '';
+                textByDateMap.set(dateKey, existingText ? `${existingText} ${text}` : text);
               }
-            } catch (err) {
-              console.error(`Failed to load session ${session.id}:`, err);
-            }
-          }
+            });
+          });
 
           setStarredComments(allStarred);
           setAllCommentsByDate(commentsByDate);
           setTextByDate(textByDateMap);
+          setFirstLineByDate(firstLineMap);
         } catch (error) {
           console.error('Failed to load comments from database:', error);
         }
@@ -622,9 +650,30 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF
               commentsByDate.set(today, allComments);
             }
             setAllCommentsByDate(commentsByDate);
+
+            const guestTextMap = new Map<string, string>();
+            const guestFirstLineMap = new Map<string, string>();
+            if (state.cells) {
+              const dateKey = state.createdAt || getLocalDateString();
+              const combined = state.cells
+                .filter((c: any) => c.type === 'text')
+                .map((c: any) => c.content)
+                .join(' ')
+                .trim();
+
+              if (combined) {
+                guestTextMap.set(dateKey, combined);
+              }
+              guestFirstLineMap.set(dateKey, extractFirstLine(state));
+            }
+            setTextByDate(guestTextMap);
+            setFirstLineByDate(guestFirstLineMap);
           } catch (e) {
             console.error('Failed to load comments:', e);
           }
+        } else {
+          setTextByDate(new Map());
+          setFirstLineByDate(new Map());
         }
       }
 
@@ -745,12 +794,6 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF
     }
     timelineByDate.get(date)!.picture = pic;
   });
-
-  const friendTimelineByDate = new Map<string, TimelineEntryData>();
-  friendPictures.forEach(pic => {
-    friendTimelineByDate.set(pic.date, { picture: pic, comments: [] });
-  });
-
   useEffect(() => {
     if (!isAuthenticated || !selectedFriendId) {
       setFriendPictures([]);
@@ -1034,7 +1077,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF
           const isActive = friend.friend_id === selectedFriendId;
           return (
             <button
-              key={friend.id}
+              key={friend.friend_id}
               onClick={() => handleFriendSelection(friend.friend_id)}
               style={{
                 width: '42px',
@@ -1106,7 +1149,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF
         </div>
       )}
 
-      {selectedFriendId && !isFriendPickerOpen && friendPictures.length === 0 && (
+      {selectedFriendId && !isFriendPickerOpen && !loadingFriendTimeline && !friendHasVisibleCards && (
         <div style={{
           position: 'fixed',
           right: '6.5rem',
@@ -1237,7 +1280,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF
                 const isSelected = friend.friend_id === selectedFriendId;
                 return (
                   <button
-                    key={friend.id}
+                    key={friend.friend_id}
                     onClick={() => handleFriendSelection(friend.friend_id)}
                     style={{
                       border: isSelected ? '1px solid #2c2c2c' : '1px solid #d0c4b0',
@@ -1307,6 +1350,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF
                   onImageClick: handleImageClick,
                   onGenerate: handleGenerateForDate,
                   textByDate,
+                  firstLineByDate,
                   t,
                   dateLocale,
                   placeholder
@@ -1355,6 +1399,7 @@ function TimelinePage({ isVisible, voiceConfigs, dateLocale, friendToSelect, onF
                     isGenerating: false,
                     onImageClick: handleFriendImageClick,
                     textByDate: emptyTextMap,
+                    firstLineByDate: emptyFirstLineMap,
                     t,
                     dateLocale,
                     placeholder,

*** MODIFIED: frontend/src/components/FriendsView.tsx (+6/-2) ***
@@ -245,7 +245,9 @@ export default function FriendsView({ isVisible, onViewFriendTimeline }: Props)
             ) : (
               <div style={{ display: 'flex', flexDirection: 'column', gap: 16 }}>
                 {friends.map(friend => (
-                  <div key={friend.id} style={{
+                  <div
+                    key={friend.friend_id ?? friend.id ?? ('friend-' + (friend.friend_email ?? 'unknown'))}
+                    style={{
                     background: '#fff',
                     border: '1px solid #d0c4b0',
                     borderRadius: 8,
@@ -342,7 +344,9 @@ export default function FriendsView({ isVisible, onViewFriendTimeline }: Props)
             ) : (
               <div style={{ display: 'flex', flexDirection: 'column', gap: 16 }}>
                 {requests.map(request => (
-                  <div key={request.id} style={{
+                  <div
+                    key={request.id ?? ('request-' + (request.requester_email ?? 'unknown'))}
+                    style={{
                     background: '#fff',
                     border: '1px solid #d0c4b0',
                     borderRadius: 8,

*** ADDED: frontend/src/utils/sessionGrouping.ts (+84/-0) ***
@@ -0,0 +1,84 @@
+import type { CalendarEntry } from './calendarStorage';
+import { extractFirstLine, getTodayKey } from './calendarStorage';
+import type { EditorState } from '../engine/EditorEngine';
+
+type ListSessionsFn = () => Promise<any[]>;
+type GetSessionFn = (id: string) => Promise<any>;
+
+function normalizeTimestamp(raw?: string | null): Date | null {
+  if (!raw) return null;
+  const normalized = raw.includes('T') ? raw : raw.replace(' ', 'T');
+  const withZone = /[zZ]$/.test(normalized) ? normalized : `${normalized}Z`;
+  const parsed = Date.parse(withZone);
+  if (Number.isNaN(parsed)) {
+    return null;
+  }
+  return new Date(parsed);
+}
+
+export function getSessionDateKey(session: any, state?: EditorState): string {
+  const name = session?.name;
+  if (name && /^\d{4}-\d{2}-\d{2}/.test(name)) {
+    return name.split(' - ')[0];
+  }
+
+  if (state?.createdAt) {
+    return state.createdAt;
+  }
+
+  const timestamp = normalizeTimestamp(session?.updated_at || session?.created_at);
+  if (timestamp) {
+    return timestamp.toISOString().substring(0, 10);
+  }
+
+  return getTodayKey();
+}
+
+function getEntryFirstLine(sessionName: string | undefined, state?: EditorState): string {
+  if (sessionName && sessionName.trim().length > 0) {
+    return sessionName.trim();
+  }
+  if (state) {
+    return extractFirstLine(state);
+  }
+  return 'Untitled';
+}
+
+export async function loadSessionsGroupedByDate(
+  listSessions: ListSessionsFn,
+  getSession: GetSessionFn,
+  options: { requireName?: boolean } = {}
+): Promise<Record<string, CalendarEntry[]>> {
+  const { requireName = false } = options;
+  const sessions = await listSessions();
+  const grouped: Record<string, CalendarEntry[]> = {};
+
+  for (const session of sessions) {
+    if (requireName && !session.name) continue;
+
+    try {
+      const fullSession = await getSession(session.id);
+      if (!fullSession?.editor_state) continue;
+
+      const dateKey = getSessionDateKey(session, fullSession.editor_state);
+      const firstLine = getEntryFirstLine(session.name, fullSession.editor_state);
+      if (!grouped[dateKey]) {
+        grouped[dateKey] = [];
+      }
+
+      const timestamp = normalizeTimestamp(session?.created_at || session?.updated_at);
+      const displayTimestamp = timestamp ? timestamp.getTime() : Date.now();
+
+      grouped[dateKey].push({
+        id: session.id,
+        timestamp: displayTimestamp,
+        state: fullSession.editor_state,
+        firstLine
+      });
+    } catch (error) {
+      console.error(`Failed to load session ${session.id}:`, error);
+    }
+  }
+
+  return grouped;
+}
