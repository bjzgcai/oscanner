*** MODIFIED: backend/server.py (+4/-2) ***
@@ -125,7 +125,7 @@ def chat_with_voice(voice_name: str, voice_config: dict, conversation_history: l
     },
     category="Analysis"
 )
-def analyze_text(text: str, session_id: str, voices: dict = None, applied_comments: list = None, meta_prompt: str = "", state_prompt: str = ""):
+def analyze_text(text: str, session_id: str, voices: dict = None, applied_comments: list = None, meta_prompt: str = "", state_prompt: str = "", overlapped_phrases: list = None):
     """
     Stateless analysis - returns ONE new comment based on text and applied comments.
 
@@ -136,6 +136,7 @@ def analyze_text(text: str, session_id: str, voices: dict = None, applied_commen
         applied_comments: List of already applied comments (to avoid duplicates)
         meta_prompt: Additional instructions that apply to all voices
         state_prompt: User's current emotional state prompt
+        overlapped_phrases: Phrases that were rejected due to overlap (feedback loop)
 
     Returns:
         Dictionary with single new voice (or empty list)
@@ -144,14 +145,15 @@ def analyze_text(text: str, session_id: str, voices: dict = None, applied_commen
     print(f"üéØ Stateless analyze_text() called")
     print(f"   Text: {text[:100]}...")
     print(f"   Applied comments: {len(applied_comments or [])}")
+    print(f"   Overlapped phrases: {len(overlapped_phrases or [])}")
     print(f"   Meta prompt: {repr(meta_prompt)[:100]}")
     print(f"   State prompt: {repr(state_prompt)[:100]}")
     print(f"{'='*60}\n")
 
     agent = PolyAgent(id="voice-analyzer")
 
     # Get voices from stateless analyzer
-    result = analyze_stateless(agent, text, applied_comments or [], voices, meta_prompt, state_prompt)
+    result = analyze_stateless(agent, text, applied_comments or [], voices, meta_prompt, state_prompt, overlapped_phrases or [])
 
     print(f"‚úÖ Returning {result['new_voices_added']} new voice(s)")
 

*** MODIFIED: backend/stateless_analyzer.py (+11/-1) ***
@@ -16,7 +16,7 @@ class VoiceTrigger(BaseModel):
 class SingleVoiceAnalysis(BaseModel):
     voice: Optional[VoiceTrigger] = Field(description="Single voice trigger, or None if nothing to comment")
 
-def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict], voices: dict = None, meta_prompt: str = "", state_prompt: str = "") -> dict:
+def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict], voices: dict = None, meta_prompt: str = "", state_prompt: str = "", overlapped_phrases: List[str] = None) -> dict:
     """
     Stateless analysis - receives applied comments, returns ONE new comment.
 
@@ -27,10 +27,12 @@ def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict],
         voices: Voice configuration
         meta_prompt: Additional instructions that apply to all voices
         state_prompt: User's current emotional state prompt
+        overlapped_phrases: Phrases that were rejected due to overlap (feedback loop)
 
     Returns:
         Dict with single new voice (or empty list if none)
     """
+    overlapped_phrases = overlapped_phrases or []
     print(f"\n{'='*60}")
     print(f"üìä Stateless Analysis")
     print(f"   Text: {text[:100]}...")
@@ -58,6 +60,14 @@ def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict],
         existing_summary += f"\nüëâ These phrases are already highlighted: {highlighted_phrases}\n"
         existing_summary += "üëâ Choose a DIFFERENT phrase that does NOT overlap with any of these!\n"
 
+    # @@@ Add overlapped phrases feedback (phrases that were rejected due to overlap)
+    if overlapped_phrases:
+        existing_summary += f"\n\nREJECTED PHRASES (these overlapped with existing highlights):\n"
+        for phrase in overlapped_phrases:
+            existing_summary += f"- \"{phrase}\" (REJECTED - do NOT suggest this again)\n"
+        existing_summary += f"\n‚ö†Ô∏è AVOID these phrases: {overlapped_phrases}\n"
+        existing_summary += "‚ö†Ô∏è The system already tried these and rejected them - choose something completely different!\n"
+
     prompt = f"""You are analyzing internal dialogue as distinct inner voice personas.
 
 Analyze this text and identify ONE NEW voice that wants to comment:

*** MODIFIED: frontend/src/api/voiceApi.ts (+4/-4) ***
@@ -45,14 +45,14 @@ interface StatusResponse {
 /**
  * Trigger voice analysis session
  */
-export async function triggerAnalysis(text: string, sessionId: string, voices?: any, appliedComments?: any[], metaPrompt?: string, statePrompt?: string): Promise<string> {
+export async function triggerAnalysis(text: string, sessionId: string, voices?: any, appliedComments?: any[], metaPrompt?: string, statePrompt?: string, overlappedPhrases?: string[]): Promise<string> {
   console.log('üì§ Sending trigger request...');
   const response = await fetch(`${API_BASE}/api/trigger`, {
     method: 'POST',
     headers: { 'Content-Type': 'application/json' },
     body: JSON.stringify({
       session_id: 'analyze_text',
-      params: { text, session_id: sessionId, voices, applied_comments: appliedComments || [], meta_prompt: metaPrompt || '', state_prompt: statePrompt || '' }
+      params: { text, session_id: sessionId, voices, applied_comments: appliedComments || [], meta_prompt: metaPrompt || '', state_prompt: statePrompt || '', overlapped_phrases: overlappedPhrases || [] }
     })
   });
 
@@ -104,8 +104,8 @@ export async function getAnalysisResult(exec_id: string): Promise<StatusResponse
 /**
  * Analyze text and return voices with metadata (all-in-one)
  */
-export async function analyzeText(text: string, sessionId: string, voices?: any, appliedComments?: any[], metaPrompt?: string, statePrompt?: string) {
-  const exec_id = await triggerAnalysis(text, sessionId, voices, appliedComments, metaPrompt, statePrompt);
+export async function analyzeText(text: string, sessionId: string, voices?: any, appliedComments?: any[], metaPrompt?: string, statePrompt?: string, overlappedPhrases?: string[]) {
+  const exec_id = await triggerAnalysis(text, sessionId, voices, appliedComments, metaPrompt, statePrompt, overlappedPhrases);
   const result = await getAnalysisResult(exec_id);
   // @@@ Return both voices and new_voices_added for energy refund mechanism
   return {

*** MODIFIED: frontend/src/engine/EditorEngine.ts (+11/-1) ***
@@ -11,6 +11,7 @@ export interface EditorState {
   commentors: Commentor[];
   tasks: Task[];
   weightPath: WeightEntry[];
+  overlappedPhrases: string[];  // @@@ Phrases rejected due to overlap (feedback to backend)
   sessionId: string;
   currentEntryId?: string;  // Track which calendar entry is being edited (for overwrite on save)
 }
@@ -126,6 +127,7 @@ export class EditorEngine {
       commentors: [],
       tasks: [],
       weightPath: [],
+      overlappedPhrases: [],
       sessionId
     };
   }
@@ -301,6 +303,10 @@ export class EditorEngine {
       }
 
       if (hasOverlap) {
+        // @@@ Track overlapped phrase for backend feedback
+        if (!this.state.overlappedPhrases.includes(commentor.phrase)) {
+          this.state.overlappedPhrases.push(commentor.phrase);
+        }
         skippedAny = true;
         continue;
       }
@@ -376,7 +382,7 @@ export class EditorEngine {
         ? stateConfig.states[selectedState].prompt
         : '';
 
-      const result = await analyzeText(text, this.state.sessionId, backendVoices, appliedCommentors, metaPrompt, statePrompt);
+      const result = await analyzeText(text, this.state.sessionId, backendVoices, appliedCommentors, metaPrompt, statePrompt, this.state.overlappedPhrases);
 
       // Backend returns at most ONE voice
       if (result.voices.length > 0) {
@@ -656,6 +662,10 @@ export class EditorEngine {
   // @@@ Load state from storage
   loadState(state: EditorState) {
     this.state = state;
+    // @@@ Ensure overlappedPhrases field exists (migration for old state)
+    if (!this.state.overlappedPhrases) {
+      this.state.overlappedPhrases = [];
+    }
     // Recompute used energy from applied commentors
     this.usedEnergy = this.state.commentors.filter(c => c.appliedAt).length * this.threshold;
     this.notifyChange();
