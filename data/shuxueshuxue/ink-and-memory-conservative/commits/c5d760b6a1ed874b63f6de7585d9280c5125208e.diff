*** MODIFIED: backend/stateless_analyzer.py (+9/-4) ***
@@ -7,7 +7,7 @@
 import config
 
 class VoiceTrigger(BaseModel):
-    phrase: str = Field(description="Exact trigger phrase from text (verbatim, 2-6 words)")
+    phrase: str = Field(description="Exact trigger phrase from text (verbatim, 2-4 words, avoid punctuation)")
     voice: str = Field(description="Voice archetype name from the available list")
     comment: str = Field(description="What this voice is saying (as if speaking)")
     icon: str = Field(description="Icon identifier")
@@ -69,19 +69,24 @@ def analyze_stateless(agent: PolyAgent, text: str, applied_comments: List[dict],
 {existing_summary}
 
 Find ONE NEW voice to comment:
-1. Extract a SHORT phrase (2-6 words) that triggered it - MUST be EXACT text from above
+1. Extract a SHORT phrase (2-4 words) that triggered it - MUST be EXACT text from above
 2. Choose a voice persona from the available list
 3. Write what this voice is saying (1-2 sentences)
 
-RULES:
+CRITICAL RULES:
 - Return ONLY ONE comment
 - DO NOT repeat any applied comments
 - DO NOT choose phrases that overlap or intersect with already highlighted phrases
 - Your chosen phrase must be completely separate from existing highlights
 - DO NOT CREATE NEW VOICE NAMES - Only use from the available list
 - Return null if nothing is worth commenting on
-- Phrase MUST be EXACT substring from text
+- Phrase MUST be EXACT substring from text - verify by checking character-by-character
+- IGNORE text inside quotation marks ("..." or '...') - only highlight the author's own words
+- DO NOT extract phrases from quoted responses, references, or examples
+- Only comment on what the AUTHOR wrote, not what they are quoting or citing
 - Only comment on complete sentences (ending with .!?ã€‚ï¼ï¼Ÿ)
+- Prefer SHORT highlights without punctuation (e.g., "feel anxious" not "I feel anxious.")
+- Keep highlights tight and focused - avoid including sentence endings
 - Write in the SAME LANGUAGE as the text"""
 
     # @@@ Add meta prompt if available

*** MODIFIED: frontend/src/App.tsx (+9/-5) ***
@@ -25,6 +25,7 @@ import { getVoices, getMetaPrompt, getStateConfig } from './utils/voiceStorage';
 import { getDefaultVoices, chatWithVoice } from './api/voiceApi';
 import { useMobile } from './utils/mobileDetect';
 import { CommentGroupCard } from './components/CommentCard';
+import { findNormalizedPhrase } from './utils/textNormalize';
 
 // @@@ Left Toolbar Component - floating toolbelt within left margin
 function LeftToolbar({
@@ -461,7 +462,7 @@ export default function App() {
       state.commentors
         .filter(c => c.appliedAt)
         .forEach(commentor => {
-          const index = text.toLowerCase().indexOf(commentor.phrase.toLowerCase());
+          const index = findNormalizedPhrase(text, commentor.phrase);
           if (index === -1) return;
 
           const visualLineNumber = charToVisualLine[index] || 0;
@@ -578,7 +579,7 @@ export default function App() {
     // Find comment at cursor position within this cell's text
     let foundComment: Commentor | null = null;
     for (const comment of appliedComments) {
-      const index = cellText.toLowerCase().indexOf(comment.phrase.toLowerCase());
+      const index = findNormalizedPhrase(cellText, comment.phrase);
       if (index !== -1) {
         const start = index;
         const end = index + comment.phrase.length;
@@ -674,8 +675,11 @@ export default function App() {
   }, []);
 
   const handlePaste = useCallback((cellId: string, e: React.ClipboardEvent<HTMLTextAreaElement>) => {
+    // @@@ Store element reference (not value!) - browser inserts paste AFTER this handler
+    const textarea = e.currentTarget;
     setTimeout(() => {
-      const newText = e.currentTarget.value;
+      // @@@ Now read value - paste has been inserted by browser
+      const newText = textarea.value;
       setLocalTexts(prev => {
         const next = new Map(prev);
         next.set(cellId, newText);
@@ -1009,7 +1013,7 @@ export default function App() {
     // Find highlights in this specific text
     const highlights: Array<{ start: number; end: number; comment: Commentor }> = [];
     appliedComments.forEach(comment => {
-      const index = text.toLowerCase().indexOf(comment.phrase.toLowerCase());
+      const index = findNormalizedPhrase(text, comment.phrase);
       if (index !== -1) {
         highlights.push({
           start: index,
@@ -1069,7 +1073,7 @@ export default function App() {
 
   const lastEntry = state.weightPath[state.weightPath.length - 1];
   const currentEnergy = lastEntry?.energy || 0;
-  const usedEnergy = state.commentors.filter(c => c.appliedAt).length * 40;
+  const usedEnergy = state.commentors.filter(c => c.appliedAt).length * 50;
   const unusedEnergy = currentEnergy - usedEnergy;
   const appliedComments = state.commentors.filter(c => c.appliedAt);
 

*** MODIFIED: frontend/src/components/CollectionsView.tsx (+35/-1) ***
@@ -1,5 +1,6 @@
 import { useState, useEffect, useRef } from 'react';
 import type { Commentor } from '../engine/EditorEngine';
+import { findNormalizedPhrase } from '../utils/textNormalize';
 
 // @@@ TypeScript interfaces
 interface TimelineDay {
@@ -25,6 +26,39 @@ export default function CollectionsView() {
   );
 }
 
+// @@@ Extract complete sentence containing a phrase
+function extractCompleteSentence(text: string, phrase: string): string {
+  // Find phrase position (with normalization)
+  const phraseIndex = findNormalizedPhrase(text, phrase);
+  if (phraseIndex === -1) {
+    return phrase; // Fallback if phrase not found
+  }
+
+  // Sentence ending markers
+  const sentenceEndings = '.!?ã€‚ï¼ï¼Ÿ\n';
+
+  // Find sentence start - go backwards to find previous sentence ending or start of text
+  let sentenceStart = 0;
+  for (let i = phraseIndex - 1; i >= 0; i--) {
+    if (sentenceEndings.includes(text[i])) {
+      sentenceStart = i + 1;
+      break;
+    }
+  }
+
+  // Find sentence end - go forwards to find next sentence ending
+  let sentenceEnd = text.length;
+  for (let i = phraseIndex + phrase.length; i < text.length; i++) {
+    if (sentenceEndings.includes(text[i])) {
+      sentenceEnd = i + 1;
+      break;
+    }
+  }
+
+  // Extract sentence and trim whitespace
+  return text.slice(sentenceStart, sentenceEnd).trim();
+}
+
 // @@@ Helper to get icon emoji
 function getIconForVoice(icon: string): string {
   const iconMap: Record<string, string> = {
@@ -686,7 +720,7 @@ function TimelinePage() {
                               overflowWrap: 'anywhere',
                               minWidth: 0
                             }}>
-                              "{comment.phrase}"
+                              "{extractCompleteSentence(comment.textSnapshot || '', comment.phrase)}"
                             </div>
                             <div style={{
                               fontSize: '13px',

*** MODIFIED: frontend/src/components/VoiceSettings.tsx (+0/-4) ***
@@ -82,15 +82,11 @@ export default function VoiceSettings({ defaultVoices, onSave }: Props) {
   };
 
   const handleDefault = () => {
-    console.log('ðŸ”„ Use Default clicked');
-    console.log('Current voices:', voices);
-    console.log('Default voices:', defaultVoices);
     clearVoices();
     localStorage.removeItem('meta-prompt');
     localStorage.removeItem('state-config');
     // Deep copy to force React to re-render
     const freshDefaults = JSON.parse(JSON.stringify(defaultVoices));
-    console.log('Fresh defaults:', freshDefaults);
     setVoices(freshDefaults);
     setMetaPrompt(getMetaPrompt());
     setStateConfig(getStateConfig());

*** REMOVED: frontend/src/config/voices.ts (+0/-13) ***
@@ -1,13 +0,0 @@
-export const VOICE_TRIGGERS = [
-  { phrase: 'i feel', voice: 'Logic', comment: 'Feelings are just chemical reactions.', color: 'blue', icon: 'brain' },
-  { phrase: 'i think', voice: 'Emotion', comment: 'But what does your heart say?', color: 'pink', icon: 'heart' },
-  { phrase: 'should i', voice: 'Doubt', comment: 'Are you sure you even want to know?', color: 'yellow', icon: 'question' },
-] as const;
-
-export const MEMORY_VOICE = {
-  voice: 'Memory',
-  comment: 'This reminds me of something you wrote before...',
-  color: 'green',
-  icon: 'cloud',
-  minLength: 50,
-} as const;

*** MODIFIED: frontend/src/engine/EditorEngine.ts (+60/-13) ***
@@ -2,6 +2,9 @@
  * Clean editor engine based on trace-based energy model
  */
 
+import { findNormalizedPhrase } from '../utils/textNormalize';
+import { debugLogger } from '../utils/debugLogger';
+
 // @@@ Core data model - cells + commentors + tasks + WeightPath
 export interface EditorState {
   cells: Cell[];
@@ -110,7 +113,7 @@ export function getCompletedSentences(text: string): string {
 export class EditorEngine {
   private state: EditorState;
   private usedEnergy: number = 0;
-  private threshold: number = 40;
+  private threshold: number = 50;
   private commentorWaitlist: Commentor[] = [];
   private sentCache: Map<string, string> = new Map(); // Track sent sentences -> commentor hash
   private onStateChange?: (state: EditorState) => void;
@@ -170,7 +173,9 @@ export class EditorEngine {
 
     // @@@ If comments were skipped, invalidate cache to allow fresh request
     if (result.skippedAny && !result.appliedAny) {
-      console.log(`ðŸ”„ Comments were skipped, invalidating cache to allow fresh request`);
+      debugLogger.log('skip', 'Comments were skipped, invalidating cache to allow fresh request', {
+        waitlistLength: this.commentorWaitlist.length
+      });
       const completedSentences = getCompletedSentences(combinedText);
       if (completedSentences) {
         this.sentCache.delete(completedSentences);
@@ -238,15 +243,32 @@ export class EditorEngine {
 
       // Check if text still matches (current text starts with snapshot)
       if (!text.startsWith(commentor.textSnapshot)) {
-        console.log(`â­ï¸ Skipped outdated commentor: ${commentor.voice}`);
+        debugLogger.log('skip', `Skipped outdated commentor: ${commentor.voice}`, {
+          voice: commentor.voice,
+          phrase: commentor.phrase,
+          reason: 'text snapshot mismatch'
+        });
         skippedAny = true;
         continue;
       }
 
-      // @@@ Check for overlap with existing highlights
-      const phraseIndex = text.toLowerCase().indexOf(commentor.phrase.toLowerCase());
+      // @@@ Check for overlap with existing highlights (with normalized matching)
+      const phraseIndex = findNormalizedPhrase(text, commentor.phrase);
       if (phraseIndex === -1) {
-        console.log(`â­ï¸ Skipped commentor (phrase not found): ${commentor.voice}`);
+        // @@@ Deep debugging - show character codes
+        const phraseChars = Array.from(commentor.phrase.slice(0, 30)).map(c => `${c}(${c.charCodeAt(0)})`).join(' ');
+        const textSnippet = text.includes('transcend') ? text.substring(text.indexOf('transcend'), text.indexOf('transcend') + 50) : '';
+        const textChars = textSnippet ? Array.from(textSnippet.slice(0, 30)).map(c => `${c}(${c.charCodeAt(0)})`).join(' ') : '';
+
+        debugLogger.log('phrase_not_found', `Skipped commentor (phrase not found): ${commentor.voice}`, {
+          voice: commentor.voice,
+          phrase: commentor.phrase,
+          phraseCharCodes: phraseChars,
+          textLength: text.length,
+          fullText: text,
+          textSnippet: textSnippet,
+          textCharCodes: textChars
+        });
         skippedAny = true;
         continue;
       }
@@ -257,7 +279,7 @@ export class EditorEngine {
       // Check overlap with all applied commentors
       let hasOverlap = false;
       for (const applied of this.state.commentors.filter(c => c.appliedAt)) {
-        const appliedIndex = text.toLowerCase().indexOf(applied.phrase.toLowerCase());
+        const appliedIndex = findNormalizedPhrase(text, applied.phrase);
         if (appliedIndex === -1) continue;
 
         const appliedStart = appliedIndex;
@@ -266,7 +288,14 @@ export class EditorEngine {
         // Check if ranges overlap: [phraseStart, phraseEnd) overlaps with [appliedStart, appliedEnd)
         if (phraseStart < appliedEnd && phraseEnd > appliedStart) {
           hasOverlap = true;
-          console.log(`âš ï¸ Skipped overlapping commentor: "${commentor.phrase}" overlaps with "${applied.phrase}"`);
+          debugLogger.log('overlap', `Skipped overlapping commentor: "${commentor.phrase}" overlaps with "${applied.phrase}"`, {
+            newVoice: commentor.voice,
+            newPhrase: commentor.phrase,
+            newRange: [phraseStart, phraseEnd],
+            existingVoice: applied.voice,
+            existingPhrase: applied.phrase,
+            existingRange: [appliedStart, appliedEnd]
+          });
           break;
         }
       }
@@ -281,8 +310,15 @@ export class EditorEngine {
       this.state.commentors.push(commentor);
       this.usedEnergy += this.threshold;
       appliedAny = true;
-      console.log(`âœ… Applied commentor: ${commentor.voice} on "${commentor.phrase}"`);
-      console.log(`   Energy: used ${this.usedEnergy}/${currentEnergy} (${currentEnergy - this.usedEnergy} remaining)`);
+      debugLogger.log('apply', `Applied commentor: ${commentor.voice} on "${commentor.phrase}"`, {
+        voice: commentor.voice,
+        phrase: commentor.phrase,
+        comment: commentor.comment,
+        usedEnergy: this.usedEnergy,
+        totalEnergy: currentEnergy,
+        remainingEnergy: currentEnergy - this.usedEnergy,
+        waitlistRemaining: this.commentorWaitlist.length
+      });
     }
 
     if (appliedAny) {
@@ -356,11 +392,19 @@ export class EditorEngine {
           textSnapshot: text
         };
         this.commentorWaitlist.push(commentor);
-        console.log(`ðŸ“¥ Added 1 commentor to waitlist: ${commentor.voice}`);
+        debugLogger.log('waitlist', `Added 1 commentor to waitlist: ${commentor.voice}`, {
+          voice: commentor.voice,
+          phrase: commentor.phrase,
+          comment: commentor.comment,
+          waitlistLength: this.commentorWaitlist.length
+        });
       } else {
-        console.log(`ðŸ“­ No new commentor from backend`);
+        debugLogger.log('request', 'No new commentor from backend', {
+          appliedCount: this.state.commentors.filter(c => c.appliedAt).length
+        });
       }
     } catch (error) {
+      debugLogger.log('request', 'Analysis failed', { error: String(error) });
       console.error('Analysis failed:', error);
     } finally {
       this.isRequesting = false;
@@ -393,7 +437,10 @@ export class EditorEngine {
 
     // @@@ If comments were skipped but not applied, invalidate cache
     if (result.skippedAny && !result.appliedAny) {
-      console.log(`ðŸ”„ All pending comments were skipped, invalidating cache`);
+      debugLogger.log('skip', 'All pending comments were skipped, invalidating cache', {
+        waitlistLength: this.commentorWaitlist.length,
+        willRetry: true
+      });
       const completedSentences = getCompletedSentences(text);
       if (completedSentences) {
         this.sentCache.delete(completedSentences);

*** MODIFIED: frontend/src/extensions/VoiceHighlight.ts (+3/-2) ***
@@ -1,6 +1,7 @@
 import { Extension } from '@tiptap/core';
 import { Plugin, PluginKey } from '@tiptap/pm/state';
 import { Decoration, DecorationSet } from '@tiptap/pm/view';
+import { findNormalizedPhrase } from '../utils/textNormalize';
 
 export interface VoiceTrigger {
   phrase: string;
@@ -98,10 +99,10 @@ export const VoiceHighlight = Extension.create<VoiceHighlightOptions>({
 
 function findHighlights(doc: any, triggers: VoiceTrigger[]): DecorationSet {
   const decorations: Decoration[] = [];
-  const text = doc.textContent.toLowerCase();
+  const text = doc.textContent;
 
   triggers.forEach(({ phrase, color }) => {
-    const pos = text.indexOf(phrase.toLowerCase());
+    const pos = findNormalizedPhrase(text, phrase);
 
     if (pos !== -1) {
       // Convert text position to document position

*** ADDED: frontend/src/utils/debugLogger.ts (+148/-0) ***
@@ -0,0 +1,148 @@
+/**
+ * Centralized debug logger for highlight application
+ * Collects all events in a structured format for easy debugging
+ */
+
+interface LogEntry {
+  timestamp: number;
+  category: 'waitlist' | 'skip' | 'overlap' | 'apply' | 'phrase_not_found' | 'energy' | 'collision' | 'request';
+  message: string;
+  data?: any;
+}
+
+class DebugLogger {
+  private logs: LogEntry[] = [];
+  private maxLogs: number = 200;
+  private enabled: boolean = true;
+
+  log(category: LogEntry['category'], message: string, data?: any) {
+    if (!this.enabled) return;
+
+    this.logs.push({
+      timestamp: Date.now(),
+      category,
+      message,
+      data
+    });
+
+    // Keep only last N logs
+    if (this.logs.length > this.maxLogs) {
+      this.logs = this.logs.slice(-this.maxLogs);
+    }
+  }
+
+  // @@@ Main export function - get formatted debug string
+  getDebugString(): string {
+    const startTime = this.logs[0]?.timestamp || Date.now();
+
+    let output = '='.repeat(80) + '\n';
+    output += 'HIGHLIGHT APPLICATION DEBUG LOG\n';
+    output += `Total entries: ${this.logs.length}\n`;
+    output += `Time range: ${new Date(startTime).toLocaleTimeString()} - ${new Date(this.logs[this.logs.length - 1]?.timestamp || Date.now()).toLocaleTimeString()}\n`;
+    output += '='.repeat(80) + '\n\n';
+
+    // Group by category
+    const byCategory = this.logs.reduce((acc, log) => {
+      if (!acc[log.category]) acc[log.category] = [];
+      acc[log.category].push(log);
+      return acc;
+    }, {} as Record<string, LogEntry[]>);
+
+    // Category icons
+    const icons = {
+      request: 'ðŸ“¤',
+      waitlist: 'â³',
+      skip: 'â­ï¸',
+      overlap: 'âš ï¸',
+      apply: 'âœ…',
+      phrase_not_found: 'âŒ',
+      energy: 'âš¡',
+      collision: 'ðŸ’¥'
+    };
+
+    // Print by category
+    for (const [category, entries] of Object.entries(byCategory)) {
+      const icon = icons[category as keyof typeof icons] || 'ðŸ“';
+      output += `\n${icon} ${category.toUpperCase()} (${entries.length} entries)\n`;
+      output += '-'.repeat(80) + '\n';
+
+      entries.forEach((entry, idx) => {
+        const relativeTime = ((entry.timestamp - startTime) / 1000).toFixed(2);
+        output += `[+${relativeTime}s] ${entry.message}\n`;
+
+        if (entry.data) {
+          const dataStr = typeof entry.data === 'string'
+            ? entry.data
+            : JSON.stringify(entry.data, null, 2);
+          output += `  Data: ${dataStr}\n`;
+        }
+
+        if (idx < entries.length - 1) output += '\n';
+      });
+    }
+
+    output += '\n' + '='.repeat(80) + '\n';
+    output += 'END DEBUG LOG\n';
+    output += '='.repeat(80) + '\n';
+
+    return output;
+  }
+
+  // Print to console
+  dump() {
+    console.log(this.getDebugString());
+  }
+
+  // Copy to clipboard (if available)
+  async copyToClipboard() {
+    const text = this.getDebugString();
+    try {
+      await navigator.clipboard.writeText(text);
+      console.log('âœ… Debug log copied to clipboard!');
+      return true;
+    } catch (err) {
+      console.error('Failed to copy to clipboard:', err);
+      console.log('Debug log:');
+      this.dump();
+      return false;
+    }
+  }
+
+  clear() {
+    this.logs = [];
+    console.log('ðŸ—‘ï¸ Debug log cleared');
+  }
+
+  enable() {
+    this.enabled = true;
+  }
+
+  disable() {
+    this.enabled = false;
+  }
+
+  getStats() {
+    const byCategory = this.logs.reduce((acc, log) => {
+      acc[log.category] = (acc[log.category] || 0) + 1;
+      return acc;
+    }, {} as Record<string, number>);
+
+    return {
+      total: this.logs.length,
+      byCategory,
+      enabled: this.enabled
+    };
+  }
+}
+
+// Global singleton
+export const debugLogger = new DebugLogger();
+
+// Expose to window for easy console access
+if (typeof window !== 'undefined') {
+  (window as any).debugLogger = debugLogger;
+  (window as any).dumpLogs = () => debugLogger.dump();
+  (window as any).copyLogs = () => debugLogger.copyToClipboard();
+  (window as any).clearLogs = () => debugLogger.clear();
+  (window as any).logStats = () => console.table(debugLogger.getStats());
+}

*** ADDED: frontend/src/utils/textNormalize.ts (+27/-0) ***
@@ -0,0 +1,27 @@
+/**
+ * Normalize text for matching - handles punctuation variations
+ * Converts smart quotes, em-dashes, etc. to standard ASCII equivalents
+ */
+export function normalizeForMatching(text: string): string {
+  return text
+    .toLowerCase()
+    // Smart quotes to straight quotes
+    .replace(/[\u201C\u201D]/g, '"')    // Smart double quotes (U+201C, U+201D) â†’ straight double quote
+    .replace(/[\u2018\u2019]/g, "'")    // Smart single quotes (U+2018, U+2019) â†’ straight single quote
+    // Dashes to hyphen
+    .replace(/[\u2014\u2013]/g, '-')    // Em-dash (U+2014), en-dash (U+2013) â†’ hyphen
+    // Ellipsis to three dots
+    .replace(/\u2026/g, '...');          // Ellipsis (U+2026) â†’ three dots
+}
+
+/**
+ * Find phrase in text with normalization
+ * Returns the index in the original text, or -1 if not found
+ */
+export function findNormalizedPhrase(text: string, phrase: string): number {
+  const normalizedText = normalizeForMatching(text);
+  const normalizedPhrase = normalizeForMatching(phrase);
+
+  const index = normalizedText.indexOf(normalizedPhrase);
+  return index;
+}
