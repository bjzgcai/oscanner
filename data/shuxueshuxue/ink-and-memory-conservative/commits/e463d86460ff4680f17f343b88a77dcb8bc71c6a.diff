*** MODIFIED: .gitignore (+1/-0) ***
@@ -3,6 +3,7 @@ backend/.venv/
 backend/models.json
 backend/.polycache/
 backend/benchmark/
+backend/test_crud.py
 __pycache__/
 *.pyc
 AGENTS.md

*** MODIFIED: backend/database.py (+383/-0) ***
@@ -287,6 +287,389 @@ def seed_system_decks():
     db.close()
     print("âœ… System decks seeded (3 decks, 16 voices)")
 
+# ========== Deck CRUD ==========
+
+def get_user_decks(user_id: int):
+    """
+    Get all decks visible to user (system decks + user's own decks).
+    Returns list of deck dicts with voice counts.
+    """
+    db = get_db()
+    try:
+        rows = db.execute("""
+        SELECT d.*, COUNT(v.id) as voice_count
+        FROM decks d
+        LEFT JOIN voices v ON d.id = v.deck_id AND v.enabled = 1
+        WHERE d.is_system = 1 OR d.owner_id = ?
+        GROUP BY d.id
+        ORDER BY d.order_index, d.created_at
+        """, (user_id,)).fetchall()
+        return [dict(row) for row in rows]
+    finally:
+        db.close()
+
+def get_deck_with_voices(user_id: int, deck_id: str):
+    """
+    Get full deck details with all voices.
+    Returns None if deck doesn't exist or user doesn't have access.
+    """
+    db = get_db()
+    try:
+        # Get deck
+        deck_row = db.execute("""
+        SELECT * FROM decks
+        WHERE id = ? AND (is_system = 1 OR owner_id = ?)
+        """, (deck_id, user_id)).fetchone()
+
+        if not deck_row:
+            return None
+
+        deck = dict(deck_row)
+
+        # Get voices in this deck
+        voice_rows = db.execute("""
+        SELECT * FROM voices
+        WHERE deck_id = ?
+        ORDER BY order_index, created_at
+        """, (deck_id,)).fetchall()
+
+        deck['voices'] = [dict(row) for row in voice_rows]
+        return deck
+    finally:
+        db.close()
+
+def create_deck(user_id: int, name: str, description: str = None,
+                name_zh: str = None, name_en: str = None,
+                description_zh: str = None, description_en: str = None,
+                icon: str = None, color: str = None,
+                order_index: int = None) -> str:
+    """
+    Create a new user deck. Returns deck_id.
+    """
+    import uuid
+
+    db = get_db()
+    try:
+        deck_id = str(uuid.uuid4())
+
+        # Get max order_index if not provided
+        if order_index is None:
+            max_order = db.execute(
+                "SELECT MAX(order_index) as max_order FROM decks WHERE owner_id = ?",
+                (user_id,)
+            ).fetchone()['max_order']
+            order_index = (max_order or 0) + 1
+
+        db.execute("""
+        INSERT INTO decks (id, name, name_zh, name_en, description, description_zh, description_en,
+                          icon, color, is_system, owner_id, enabled, order_index)
+        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 0, ?, 1, ?)
+        """, (deck_id, name, name_zh, name_en, description, description_zh, description_en,
+              icon, color, user_id, order_index))
+
+        db.commit()
+        return deck_id
+    finally:
+        db.close()
+
+def update_deck(user_id: int, deck_id: str, updates: dict) -> bool:
+    """
+    Update a user's deck. Only works if user owns the deck.
+    Returns True if updated, False if not found or permission denied.
+
+    Updates dict can contain: name, name_zh, name_en, description, description_zh,
+    description_en, icon, color, enabled, order_index
+    """
+    db = get_db()
+    try:
+        # Check ownership
+        deck = db.execute(
+            "SELECT owner_id FROM decks WHERE id = ?",
+            (deck_id,)
+        ).fetchone()
+
+        if not deck or deck['owner_id'] != user_id:
+            return False
+
+        # Build update query
+        allowed_fields = ['name', 'name_zh', 'name_en', 'description', 'description_zh',
+                         'description_en', 'icon', 'color', 'enabled', 'order_index']
+
+        update_fields = []
+        params = []
+        for field in allowed_fields:
+            if field in updates:
+                update_fields.append(f"{field} = ?")
+                params.append(updates[field])
+
+        if not update_fields:
+            return True  # No updates
+
+        update_fields.append("updated_at = CURRENT_TIMESTAMP")
+        params.append(deck_id)
+
+        db.execute(
+            f"UPDATE decks SET {', '.join(update_fields)} WHERE id = ?",
+            params
+        )
+        db.commit()
+        return True
+    finally:
+        db.close()
+
+def delete_deck(user_id: int, deck_id: str) -> bool:
+    """
+    Delete a user's deck. Only works if user owns the deck.
+    Cascades to delete all voices in the deck.
+    Returns True if deleted, False if not found or permission denied.
+    """
+    db = get_db()
+    try:
+        # Check ownership
+        deck = db.execute(
+            "SELECT owner_id FROM decks WHERE id = ?",
+            (deck_id,)
+        ).fetchone()
+
+        if not deck or deck['owner_id'] != user_id:
+            return False
+
+        db.execute("DELETE FROM decks WHERE id = ?", (deck_id,))
+        db.commit()
+        return True
+    finally:
+        db.close()
+
+def fork_deck(user_id: int, deck_id: str) -> str:
+    """
+    Fork a deck (usually system deck) to create user's own copy.
+    Copies deck + all voices. Returns new deck_id.
+    """
+    import uuid
+
+    db = get_db()
+    try:
+        # Get source deck
+        source_deck = db.execute("SELECT * FROM decks WHERE id = ?", (deck_id,)).fetchone()
+        if not source_deck:
+            raise ValueError(f"Deck {deck_id} not found")
+
+        # Create new deck ID
+        new_deck_id = str(uuid.uuid4())
+
+        # Copy deck
+        db.execute("""
+        INSERT INTO decks (id, name, name_zh, name_en, description, description_zh, description_en,
+                          icon, color, is_system, parent_id, owner_id, enabled, order_index)
+        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 0, ?, ?, 1, ?)
+        """, (new_deck_id,
+              source_deck['name'],
+              source_deck['name_zh'],
+              source_deck['name_en'],
+              source_deck['description'],
+              source_deck['description_zh'],
+              source_deck['description_en'],
+              source_deck['icon'],
+              source_deck['color'],
+              deck_id,  # parent_id tracks fork source
+              user_id,
+              source_deck['order_index']))
+
+        # Copy all voices
+        source_voices = db.execute(
+            "SELECT * FROM voices WHERE deck_id = ? ORDER BY order_index",
+            (deck_id,)
+        ).fetchall()
+
+        for voice in source_voices:
+            new_voice_id = str(uuid.uuid4())
+            db.execute("""
+            INSERT INTO voices (id, deck_id, name, name_zh, name_en, system_prompt,
+                              icon, color, is_system, parent_id, owner_id, enabled, order_index)
+            VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, ?, ?, 1, ?)
+            """, (new_voice_id,
+                  new_deck_id,
+                  voice['name'],
+                  voice['name_zh'],
+                  voice['name_en'],
+                  voice['system_prompt'],
+                  voice['icon'],
+                  voice['color'],
+                  voice['id'],  # parent_id tracks fork source
+                  user_id,
+                  voice['order_index']))
+
+        db.commit()
+        return new_deck_id
+    finally:
+        db.close()
+
+# ========== Voice CRUD ==========
+
+def create_voice(user_id: int, deck_id: str, name: str, system_prompt: str,
+                name_zh: str = None, name_en: str = None,
+                icon: str = None, color: str = None,
+                order_index: int = None) -> str:
+    """
+    Create a new voice in a user's deck.
+    Returns voice_id.
+    """
+    import uuid
+
+    db = get_db()
+    try:
+        # Check deck ownership
+        deck = db.execute(
+            "SELECT owner_id FROM decks WHERE id = ?",
+            (deck_id,)
+        ).fetchone()
+
+        if not deck or deck['owner_id'] != user_id:
+            raise ValueError("Deck not found or permission denied")
+
+        voice_id = str(uuid.uuid4())
+
+        # Get max order_index if not provided
+        if order_index is None:
+            max_order = db.execute(
+                "SELECT MAX(order_index) as max_order FROM voices WHERE deck_id = ?",
+                (deck_id,)
+            ).fetchone()['max_order']
+            order_index = (max_order or 0) + 1
+
+        db.execute("""
+        INSERT INTO voices (id, deck_id, name, name_zh, name_en, system_prompt,
+                           icon, color, is_system, owner_id, enabled, order_index)
+        VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, ?, 1, ?)
+        """, (voice_id, deck_id, name, name_zh, name_en, system_prompt,
+              icon, color, user_id, order_index))
+
+        db.commit()
+        return voice_id
+    finally:
+        db.close()
+
+def update_voice(user_id: int, voice_id: str, updates: dict) -> bool:
+    """
+    Update a user's voice. Only works if user owns the voice.
+    Returns True if updated, False if not found or permission denied.
+
+    Updates dict can contain: name, name_zh, name_en, system_prompt,
+    icon, color, enabled, order_index
+    """
+    db = get_db()
+    try:
+        # Check ownership
+        voice = db.execute(
+            "SELECT owner_id FROM voices WHERE id = ?",
+            (voice_id,)
+        ).fetchone()
+
+        if not voice or voice['owner_id'] != user_id:
+            return False
+
+        # Build update query
+        allowed_fields = ['name', 'name_zh', 'name_en', 'system_prompt',
+                         'icon', 'color', 'enabled', 'order_index']
+
+        update_fields = []
+        params = []
+        for field in allowed_fields:
+            if field in updates:
+                update_fields.append(f"{field} = ?")
+                params.append(updates[field])
+
+        if not update_fields:
+            return True  # No updates
+
+        update_fields.append("updated_at = CURRENT_TIMESTAMP")
+        params.append(voice_id)
+
+        db.execute(
+            f"UPDATE voices SET {', '.join(update_fields)} WHERE id = ?",
+            params
+        )
+        db.commit()
+        return True
+    finally:
+        db.close()
+
+def delete_voice(user_id: int, voice_id: str) -> bool:
+    """
+    Delete a user's voice. Only works if user owns the voice.
+    Returns True if deleted, False if not found or permission denied.
+    """
+    db = get_db()
+    try:
+        # Check ownership
+        voice = db.execute(
+            "SELECT owner_id FROM voices WHERE id = ?",
+            (voice_id,)
+        ).fetchone()
+
+        if not voice or voice['owner_id'] != user_id:
+            return False
+
+        db.execute("DELETE FROM voices WHERE id = ?", (voice_id,))
+        db.commit()
+        return True
+    finally:
+        db.close()
+
+def fork_voice(user_id: int, voice_id: str, target_deck_id: str) -> str:
+    """
+    Fork a voice to a user's deck.
+    Returns new voice_id.
+    """
+    import uuid
+
+    db = get_db()
+    try:
+        # Check target deck ownership
+        deck = db.execute(
+            "SELECT owner_id FROM decks WHERE id = ?",
+            (target_deck_id,)
+        ).fetchone()
+
+        if not deck or deck['owner_id'] != user_id:
+            raise ValueError("Target deck not found or permission denied")
+
+        # Get source voice
+        source_voice = db.execute("SELECT * FROM voices WHERE id = ?", (voice_id,)).fetchone()
+        if not source_voice:
+            raise ValueError(f"Voice {voice_id} not found")
+
+        # Create new voice
+        new_voice_id = str(uuid.uuid4())
+
+        # Get max order_index in target deck
+        max_order = db.execute(
+            "SELECT MAX(order_index) as max_order FROM voices WHERE deck_id = ?",
+            (target_deck_id,)
+        ).fetchone()['max_order']
+        order_index = (max_order or 0) + 1
+
+        db.execute("""
+        INSERT INTO voices (id, deck_id, name, name_zh, name_en, system_prompt,
+                           icon, color, is_system, parent_id, owner_id, enabled, order_index)
+        VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, ?, ?, 1, ?)
+        """, (new_voice_id,
+              target_deck_id,
+              source_voice['name'],
+              source_voice['name_zh'],
+              source_voice['name_en'],
+              source_voice['system_prompt'],
+              source_voice['icon'],
+              source_voice['color'],
+              voice_id,  # parent_id tracks fork source
+              user_id,
+              order_index))
+
+        db.commit()
+        return new_voice_id
+    finally:
+        db.close()
+
 # ========== User Management ==========
 
 def create_user(email: str, password_hash: str, display_name: str = None) -> int:
