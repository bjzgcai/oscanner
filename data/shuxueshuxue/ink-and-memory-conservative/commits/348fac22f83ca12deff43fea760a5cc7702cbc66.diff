*** MODIFIED: frontend/index.html (+5/-1) ***
@@ -4,7 +4,11 @@
     <meta charset="UTF-8" />
     <link rel="icon" type="image/svg+xml" href="/vite.svg" />
     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
-    <title>frontend</title>
+    <title>Ink & Memory</title>
+
+    <!-- Preload critical fonts to prevent FOIT (Flash of Invisible Text) -->
+    <link rel="preload" href="/Excalifont-Regular.woff2" as="font" type="font/woff2" crossorigin />
+    <link rel="preload" href="/Xiaolai-Regular.ttf" as="font" type="font/ttf" crossorigin />
   </head>
   <body>
     <div id="root"></div>

*** MODIFIED: frontend/src/App.css (+2/-0) ***
@@ -3,6 +3,7 @@
   src: url('/Excalifont-Regular.woff2') format('woff2');
   font-weight: normal;
   font-style: normal;
+  font-display: swap;
   unicode-range: U+0000-00FF, U+0100-017F, U+0180-024F, U+1E00-1EFF, U+2000-206F, U+20A0-20CF, U+2100-214F;
 }
 
@@ -11,6 +12,7 @@
   src: url('/Xiaolai-Regular.ttf') format('truetype');
   font-weight: normal;
   font-style: normal;
+  font-display: swap;
   unicode-range: U+4E00-9FFF, U+3400-4DBF, U+20000-2A6DF, U+F900-FAFF, U+3000-303F;
 }
 

*** MODIFIED: frontend/src/App.tsx (+32/-27) ***
@@ -283,27 +283,12 @@ export default function App() {
   const [refsReady, setRefsReady] = useState(0);
   const refsReadyTriggered = useRef(false);
 
-  // @@@ Reset refs ready flag when returning to writing view and focus last text cell
+  // @@@ Reset refs ready flag when returning to writing view
   useEffect(() => {
     if (currentView === 'writing') {
       refsReadyTriggered.current = false;
-
-      // Auto-focus last text cell after a short delay to ensure DOM is ready
-      setTimeout(() => {
-        if (!state) return;
-        const lastTextCell = [...state.cells].reverse().find(c => c.type === 'text');
-        if (!lastTextCell) return;
-
-        const textarea = textareaRefs.current.get(lastTextCell.id);
-        if (textarea) {
-          textarea.focus();
-          // Move cursor to end
-          textarea.selectionStart = textarea.value.length;
-          textarea.selectionEnd = textarea.value.length;
-        }
-      }, 100);
     }
-  }, [currentView, state]);
+  }, [currentView]);
 
   // @@@ Fetch default voices from backend
   useEffect(() => {
@@ -947,7 +932,9 @@ export default function App() {
           display: 'flex',
           height: '100vh',
           paddingTop: isMobile ? '0' : '48px',
-          fontFamily: 'system-ui, -apple-system, sans-serif'
+          paddingBottom: '41px',  // @@@ Space for fixed stats bar at bottom
+          fontFamily: 'system-ui, -apple-system, sans-serif',
+          boxSizing: 'border-box'
         }}>
           {/* Left spacer for layout - hide on mobile */}
           {!isMobile && (
@@ -1038,7 +1025,8 @@ export default function App() {
                 flex: 1,
                 position: 'relative',
                 overflow: 'auto',
-                padding: '20px'
+                padding: '20px',
+                paddingBottom: '80px'  // Extra space for smooth scrolling to bottom
               }}>
                 <div style={{
                   position: 'relative',
@@ -1105,6 +1093,11 @@ export default function App() {
                             onClick={(e) => handleCursorChange(cell.id, e)}
                             onKeyUp={(e) => handleCursorChange(cell.id, e)}
                             onKeyDown={(e) => handleKeyDown(cell.id, e)}
+                            onFocus={(e) => {
+                              // @@@ Prevent browser from scrolling element into view on focus
+                              // This stops the "lift up" effect when clicking after scrolling
+                              e.preventDefault();
+                            }}
                             placeholder={idx === 0 ? "Start writing..." : "Continue writing..."}
                             style={{
                               width: '100%',
@@ -1153,18 +1146,30 @@ export default function App() {
                   const cellTextarea = textareaRefs.current.get(group.cellId);
                   if (!cellTextarea) return null;
 
-                  // Calculate position relative to this cell's textarea
-                  const cellRect = cellTextarea.getBoundingClientRect();
-                  const containerRect = containerRef.current?.getBoundingClientRect();
-                  if (!containerRect) return null;
+                  // @@@ Use offsetTop relative to the content container (with maxWidth: 600px)
+                  // This div is at line 1031 with position: relative
+                  const cellWrapper = cellTextarea.parentElement; // The div with position: relative
+                  if (!cellWrapper) return null;
+
+                  const cellOffsetTop = cellWrapper.offsetTop;
+
+                  // @@@ Calculate line height from textarea styles
+                  const computedStyle = window.getComputedStyle(cellTextarea);
+                  const fontSize = parseFloat(computedStyle.fontSize) || 18;
+                  const lineHeightRatio = parseFloat(computedStyle.lineHeight) / fontSize || 1.8;
+                  const lineHeight = fontSize * lineHeightRatio;
 
-                  const containerPadding = parseFloat(window.getComputedStyle(cellTextarea.parentElement || cellTextarea).paddingLeft) || 20;
+                  const containerPadding = parseFloat(window.getComputedStyle(cellWrapper.parentElement || cellWrapper).paddingLeft) || 20;
                   const gap = Math.max(30, window.innerWidth * 0.02);
                   const leftPosition = containerPadding + group.maxLineWidth + gap;
 
-                  // @@@ Position relative to cell's top, not global document
-                  // centerY is already relative to cell's top, so just add cell offset
-                  const topPosition = cellRect.top - containerRect.top + group.centerY;
+                  // @@@ Position using offsetTop (scroll-independent)
+                  // centerY is already relative to cell's top, so just add:
+                  // - cellOffsetTop: position relative to content container
+                  // - 20px: scroll container padding (line 1028)
+                  // - 24px: StateChooser marginBottom (line 1036)
+                  // - subtract 0.7 lineHeight: fine-tune vertical alignment
+                  const topPosition = cellOffsetTop + group.centerY + 20 + 24 - (lineHeight * 0.7);
 
                   return (
                     <CommentGroupCard

*** MODIFIED: frontend/src/engine/EditorEngine.ts (+41/-9) ***
@@ -218,17 +218,49 @@ export class EditorEngine {
       const commentor = this.commentorWaitlist.pop()!;
 
       // Check if text still matches (current text starts with snapshot)
-      if (text.startsWith(commentor.textSnapshot)) {
-        // Apply commentor
-        commentor.appliedAt = Date.now();
-        this.state.commentors.push(commentor);
-        this.usedEnergy += this.threshold;
-        appliedAny = true;
-        console.log(`✅ Applied commentor: ${commentor.voice} on "${commentor.phrase}"`);
-        console.log(`   Energy: used ${this.usedEnergy}/${currentEnergy} (${currentEnergy - this.usedEnergy} remaining)`);
-      } else {
+      if (!text.startsWith(commentor.textSnapshot)) {
         console.log(`⏭️ Skipped outdated commentor: ${commentor.voice}`);
+        continue;
+      }
+
+      // @@@ Check for overlap with existing highlights
+      const phraseIndex = text.toLowerCase().indexOf(commentor.phrase.toLowerCase());
+      if (phraseIndex === -1) {
+        console.log(`⏭️ Skipped commentor (phrase not found): ${commentor.voice}`);
+        continue;
+      }
+
+      const phraseStart = phraseIndex;
+      const phraseEnd = phraseIndex + commentor.phrase.length;
+
+      // Check overlap with all applied commentors
+      let hasOverlap = false;
+      for (const applied of this.state.commentors.filter(c => c.appliedAt)) {
+        const appliedIndex = text.toLowerCase().indexOf(applied.phrase.toLowerCase());
+        if (appliedIndex === -1) continue;
+
+        const appliedStart = appliedIndex;
+        const appliedEnd = appliedIndex + applied.phrase.length;
+
+        // Check if ranges overlap: [phraseStart, phraseEnd) overlaps with [appliedStart, appliedEnd)
+        if (phraseStart < appliedEnd && phraseEnd > appliedStart) {
+          hasOverlap = true;
+          console.log(`⚠️ Skipped overlapping commentor: "${commentor.phrase}" overlaps with "${applied.phrase}"`);
+          break;
+        }
       }
+
+      if (hasOverlap) {
+        continue;
+      }
+
+      // Apply commentor
+      commentor.appliedAt = Date.now();
+      this.state.commentors.push(commentor);
+      this.usedEnergy += this.threshold;
+      appliedAny = true;
+      console.log(`✅ Applied commentor: ${commentor.voice} on "${commentor.phrase}"`);
+      console.log(`   Energy: used ${this.usedEnergy}/${currentEnergy} (${currentEnergy - this.usedEnergy} remaining)`);
     }
 
     if (appliedAny) {
