{
  "cached_at": "2025-12-20T14:33:29.998540",
  "commit_sha": "0b4473799c13cc2679e5305f14268d2c2c523a92",
  "repo": "malabz/Cax",
  "data": {
    "sha": "0b4473799c13cc2679e5305f14268d2c2c523a92",
    "node_id": "C_kwDOPt61otoAKDBiNDQ3Mzc5OWMxM2NjMjY3OWU1MzA1ZjE0MjY4ZDJjMmM1MjNhOTI",
    "commit": {
      "author": {
        "name": "LoadStar822",
        "email": "992247533@qq.com",
        "date": "2025-11-25T09:26:17Z"
      },
      "committer": {
        "name": "LoadStar822",
        "email": "992247533@qq.com",
        "date": "2025-11-25T09:26:17Z"
      },
      "message": "Release 0.3.0",
      "tree": {
        "sha": "4c5588763176308ed3baa521f1871b8d4ed74822",
        "url": "https://api.github.com/repos/malabz/Cax/git/trees/4c5588763176308ed3baa521f1871b8d4ed74822"
      },
      "url": "https://api.github.com/repos/malabz/Cax/git/commits/0b4473799c13cc2679e5305f14268d2c2c523a92",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null,
        "verified_at": null
      }
    },
    "url": "https://api.github.com/repos/malabz/Cax/commits/0b4473799c13cc2679e5305f14268d2c2c523a92",
    "html_url": "https://github.com/malabz/Cax/commit/0b4473799c13cc2679e5305f14268d2c2c523a92",
    "comments_url": "https://api.github.com/repos/malabz/Cax/commits/0b4473799c13cc2679e5305f14268d2c2c523a92/comments",
    "author": {
      "login": "LoadStar822",
      "id": 56856603,
      "node_id": "MDQ6VXNlcjU2ODU2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/56856603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LoadStar822",
      "html_url": "https://github.com/LoadStar822",
      "followers_url": "https://api.github.com/users/LoadStar822/followers",
      "following_url": "https://api.github.com/users/LoadStar822/following{/other_user}",
      "gists_url": "https://api.github.com/users/LoadStar822/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LoadStar822/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LoadStar822/subscriptions",
      "organizations_url": "https://api.github.com/users/LoadStar822/orgs",
      "repos_url": "https://api.github.com/users/LoadStar822/repos",
      "events_url": "https://api.github.com/users/LoadStar822/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LoadStar822/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "committer": {
      "login": "LoadStar822",
      "id": 56856603,
      "node_id": "MDQ6VXNlcjU2ODU2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/56856603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LoadStar822",
      "html_url": "https://github.com/LoadStar822",
      "followers_url": "https://api.github.com/users/LoadStar822/followers",
      "following_url": "https://api.github.com/users/LoadStar822/following{/other_user}",
      "gists_url": "https://api.github.com/users/LoadStar822/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LoadStar822/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LoadStar822/subscriptions",
      "organizations_url": "https://api.github.com/users/LoadStar822/orgs",
      "repos_url": "https://api.github.com/users/LoadStar822/repos",
      "events_url": "https://api.github.com/users/LoadStar822/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LoadStar822/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c7826a78095e1d7bd33955b97df0509f95720b15",
        "url": "https://api.github.com/repos/malabz/Cax/commits/c7826a78095e1d7bd33955b97df0509f95720b15",
        "html_url": "https://github.com/malabz/Cax/commit/c7826a78095e1d7bd33955b97df0509f95720b15"
      }
    ],
    "stats": {
      "total": 1098,
      "additions": 875,
      "deletions": 223
    },
    "files": [
      {
        "sha": "ecf5386ebd5616dda84450d92f56bac1db14c4dc",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/malabz/Cax/blob/0b4473799c13cc2679e5305f14268d2c2c523a92/.gitignore",
        "raw_url": "https://github.com/malabz/Cax/raw/0b4473799c13cc2679e5305f14268d2c2c523a92/.gitignore",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/.gitignore?ref=0b4473799c13cc2679e5305f14268d2c2c523a92",
        "patch": "@@ -4,3 +4,4 @@ jobstore/\n tests/__pycache__/\n cax_all_code.txt\n *.pyc\n+.agentdocs/\n\\ No newline at end of file"
      },
      {
        "sha": "583f0df7b751d166bec9392857fb5daafb098309",
        "filename": "CHANGELOG.md",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/malabz/Cax/blob/0b4473799c13cc2679e5305f14268d2c2c523a92/CHANGELOG.md",
        "raw_url": "https://github.com/malabz/Cax/raw/0b4473799c13cc2679e5305f14268d2c2c523a92/CHANGELOG.md",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/CHANGELOG.md?ref=0b4473799c13cc2679e5305f14268d2c2c523a92",
        "patch": "@@ -2,12 +2,16 @@\n \n All notable changes to this project will be documented in this file.\n \n-## [0.3.0-dev] - Unreleased\n+## [0.3.0] - 2025-11-25\n \n ### UI\n - Rebuilt the alignment browser as an ASCII phylogenetic canvas with clado/phylo modes, proportional branch spacing, subtree focus/return, and RaMAx toggles that repaint the tree in place without the old Textual tree widget.\n - Added search (`/`, `n` / `Shift+N`), zoom, ASCII glyph fallback, and a detail buffer/info modal so large trees stay navigable and summaries remain visible even on narrow terminals.\n \n+### Planner\n+- Skip RaMAx rounds whose ancestors already run with RaMAx, while still honoring cactus overrides inside those subtrees so users can mix modes intentionally.\n+- Suppress `halAppendSubtree` merges when the parent round output was produced by RaMAx, preventing redundant HAL writes.\n+\n ### Tree parsing\n - Alignment nodes now retain branch lengths, support values, and parent links, enabling proportional layouts and state colouring while tolerating unlabeled or missing edges.\n - Newick parsing accepts numeric internal labels as support scores and ignores malformed branch lengths instead of failing the entire parse.\n@@ -16,7 +20,7 @@ All notable changes to this project will be documented in this file.\n - Moved the plan overview/environment rendering helpers into `cax.ui` (retiring `cax.render`) and pointed CLI previews at the shared UI renderer for consistent output and script exports.\n \n ### Tests\n-- Removed the outdated planner-skips and tree-utils tests pending replacement after the parser/UI overhaul.\n+- Added coverage for RaMAx ancestor/descendant overrides in the planner and for bulk RaMAx subtree reversion when toggling individual nodes in the UI.\n \n ## [0.2.2] - 2025-11-08\n "
      },
      {
        "sha": "1210f4c27083cd34a2376146b8ebeea153b1712d",
        "filename": "README.md",
        "status": "modified",
        "additions": 4,
        "deletions": 7,
        "changes": 11,
        "blob_url": "https://github.com/malabz/Cax/blob/0b4473799c13cc2679e5305f14268d2c2c523a92/README.md",
        "raw_url": "https://github.com/malabz/Cax/raw/0b4473799c13cc2679e5305f14268d2c2c523a92/README.md",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/README.md?ref=0b4473799c13cc2679e5305f14268d2c2c523a92",
        "patch": "@@ -1,6 +1,6 @@\n # Cactus-RaMAx\n \n-Cactus-RaMAx helps you remix alignment plans emitted by `cactus-prepare`. You can inspect every round, toggle RaMAx for any subtree, and then run or export the resulting command list. Version `0.2.1` adds a Textual command prompt with an argument wizard, template chooser, and command history so first-time runs need fewer flags before you drop into the UI.\n+Cactus-RaMAx helps you remix alignment plans emitted by `cactus-prepare`. You can inspect every round, toggle RaMAx for any subtree, and then run or export the resulting command list. Version `0.3.0` introduces an ASCII phylogenetic canvas with subtree/single-node toggle scopes, search, proportional branch spacing, and a bottom HUD that summarizes the current node, coverage, and live system metrics.\n \n ## Environment setup\n \n@@ -48,13 +48,10 @@ cax\n \n ### 2. Work inside the UI\n \n-- The left pane renders the cactus progressive tree; press **Space** to toggle the selected subtree between cactus and RaMAx (use **Ctrl+Space** to expand or collapse nodes).\n-- The details pane now includes an environment summary card (RaMAx/cactus paths, versions, GPU, CPU, memory, disk) plus a compact plan overview table that adapts to narrow terminals.\n+- The left pane renders an ASCII phylogenetic canvas with proportional branch spacing; use arrow keys or **h/j/k/l** to move, press **Space** to toggle RaMAx using the current scope, and press **b** to switch the scope between subtree and single node. Press **/** to search node names, then **n** / **Shift+N** to cycle through matches.\n+- The canvas paints cactus vs. RaMAx states inline, annotates branch lengths on dotted leaders, and shows a bottom HUD with identity, subtree/total RaMAx coverage, and live CPU/GPU/memory/disk metrics. Press **i** for a full detail modal of the current node.\n - `E`: edit commands for the selected round or RaMAx replacement in a multi-line editor (press **Ctrl+S** to save).\n-- `R`: run the entire plan; CAX switches to the Run Settings screen so you can review verbose logging and the shared thread count before execution.\n-- Run Settings shows a live plan summary next to the form, and you can drive it entirely with the keyboard (`Tab` / `Shift+Tab` to focus fields, `Ctrl+Enter` to launch, `V` to toggle verbose).\n-- `S`: export all commands to `ramax_commands.txt` inside the chosen output directory.\n-- `P`: refresh the overview table.\n+- `R`: open the Run Settings screen to review verbose logging and the shared thread count, run the plan, or save the generated command list. The screen keeps a live plan summary and is fully keyboard-driven (`Tab` / `Shift+Tab`, **Ctrl+Enter**, **V**).\n - `Q`: quit the UI.\n - Verbose streaming is only controlled via the run-settings dialog so you can review the choice right before execution.\n "
      },
      {
        "sha": "0d91a54c7d439e84e3dd17d3594f1b2b6737f430",
        "filename": "VERSION",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/malabz/Cax/blob/0b4473799c13cc2679e5305f14268d2c2c523a92/VERSION",
        "raw_url": "https://github.com/malabz/Cax/raw/0b4473799c13cc2679e5305f14268d2c2c523a92/VERSION",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/VERSION?ref=0b4473799c13cc2679e5305f14268d2c2c523a92",
        "patch": "@@ -1 +1 @@\n-0.3.0-dev\n+0.3.0"
      },
      {
        "sha": "c8eb2662922ac9c747548eb9a6e485811be13e1e",
        "filename": "cax/__init__.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/malabz/Cax/blob/0b4473799c13cc2679e5305f14268d2c2c523a92/cax%2F__init__.py",
        "raw_url": "https://github.com/malabz/Cax/raw/0b4473799c13cc2679e5305f14268d2c2c523a92/cax%2F__init__.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2F__init__.py?ref=0b4473799c13cc2679e5305f14268d2c2c523a92",
        "patch": "@@ -1,13 +1,12 @@\n \"\"\"Cactus-RaMAx toolkit package.\"\"\"\n-from . import config, parser, planner, render, ui\n+from . import config, parser, planner, ui\n from .models import Plan, PrepareHeader, Round, Step\n from .runner import PlanRunner\n \n __all__ = [\n     \"config\",\n     \"parser\",\n     \"planner\",\n-    \"render\",\n     \"ui\",\n     \"Plan\",\n     \"PrepareHeader\","
      },
      {
        "sha": "429cc8183c9d733cb95a0446268bfcf88874593f",
        "filename": "cax/planner.py",
        "status": "modified",
        "additions": 33,
        "deletions": 19,
        "changes": 52,
        "blob_url": "https://github.com/malabz/Cax/blob/0b4473799c13cc2679e5305f14268d2c2c523a92/cax%2Fplanner.py",
        "raw_url": "https://github.com/malabz/Cax/raw/0b4473799c13cc2679e5305f14268d2c2c523a92/cax%2Fplanner.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fplanner.py?ref=0b4473799c13cc2679e5305f14268d2c2c523a92",
        "patch": "@@ -38,9 +38,7 @@ def build_execution_plan(\n \n     base_dir = base_dir or Path.cwd()\n     commands: list[PlannedCommand] = []\n-\n     tree = tree_utils.build_alignment_tree(plan, base_dir=base_dir)\n-    skip_roots = _compute_skipped_roots(plan, tree)\n \n     for step in plan.preprocess:\n         commands.append(\n@@ -53,12 +51,13 @@ def build_execution_plan(\n         )\n \n     for round_entry in plan.rounds:\n-        if round_entry.root in skip_roots:\n+        if _is_descendant_ramax(round_entry, tree):\n+            # An ancestor already uses RaMAx; running it again here would be redundant.\n             continue\n         commands.extend(_round_commands(plan, round_entry, base_dir, thread_count))\n \n     for step in plan.hal_merges:\n-        if step.root and step.root in skip_roots:\n+        if _skip_halmerge_for_ramax_parent(step, tree):\n             continue\n         commands.append(\n             _from_step(\n@@ -288,19 +287,34 @@ def _has_flag(command: List[str], flag: str) -> bool:\n     return False\n \n \n-def _compute_skipped_roots(plan: Plan, tree: Optional[tree_utils.AlignmentTree]) -> set[str]:\n-    if tree is None:\n-        return set()\n+def _is_descendant_ramax(round_entry: Round, tree: Optional[tree_utils.AlignmentTree]) -> bool:\n+    \"\"\"Skip this round when any ancestor round already uses RaMAx and this round also requests RaMAx, avoiding duplicate alignments.\"\"\"\n \n-    skipped: set[str] = set()\n-    for round_entry in plan.rounds:\n-        node = tree.find(round_entry.root)\n-        if not node:\n-            continue\n-        ancestor = node.parent\n-        while ancestor:\n-            if ancestor.round and ancestor.round.replace_with_ramax:\n-                skipped.add(round_entry.root)\n-                break\n-            ancestor = ancestor.parent\n-    return skipped\n+    if tree is None or not round_entry.replace_with_ramax:\n+        return False\n+    node = tree.find(round_entry.root)\n+    if node is None:\n+        return False\n+    ancestor = node.parent\n+    while ancestor:\n+        if ancestor.round and ancestor.round.replace_with_ramax:\n+            return True\n+        ancestor = ancestor.parent\n+    return False\n+\n+\n+def _skip_halmerge_for_ramax_parent(step: Step, tree: Optional[tree_utils.AlignmentTree]) -> bool:\n+    \"\"\"Skip halAppendSubtree when its parent round was produced by RaMAx to avoid writing HAL twice.\"\"\"\n+\n+    if tree is None or step.root is None:\n+        return False\n+    node = tree.find(step.root)\n+    if node is None:\n+        return False\n+    # Find the nearest ancestor with a round; that node is the halmerge target parent.\n+    parent = node.parent\n+    while parent and parent.round is None:\n+        parent = parent.parent\n+    if parent and parent.round and parent.round.replace_with_ramax:\n+        return True\n+    return False"
      },
      {
        "sha": "c043ac874ba31b12b7bc6ea22e9a78463845c769",
        "filename": "cax/ui.py",
        "status": "modified",
        "additions": 747,
        "deletions": 191,
        "changes": 938,
        "blob_url": "https://github.com/malabz/Cax/blob/0b4473799c13cc2679e5305f14268d2c2c523a92/cax%2Fui.py",
        "raw_url": "https://github.com/malabz/Cax/raw/0b4473799c13cc2679e5305f14268d2c2c523a92/cax%2Fui.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fui.py?ref=0b4473799c13cc2679e5305f14268d2c2c523a92",
        "patch": "@@ -1,23 +1,29 @@\n \"\"\"Textual-based interactive UI for configuring CAX plans.\"\"\"\n from __future__ import annotations\n \n+import itertools\n import math\n import shlex\n+import shutil\n+import subprocess\n from dataclasses import dataclass\n from pathlib import Path\n from typing import Callable, Iterable, Optional\n \n+import psutil\n from textual import events\n from textual.app import App, ComposeResult\n from textual.binding import Binding\n-from textual.containers import Container\n+from textual.containers import Container, Horizontal, Vertical\n from textual.screen import ModalScreen, Screen\n from textual.widgets import Button, Checkbox, Footer, Header, Input, ListItem, ListView, Static, TextArea\n \n from rich.console import Console, Group, RenderableType\n from rich.panel import Panel\n from rich.table import Table\n from rich.text import Text\n+from rich.align import Align\n+from rich.console import Group\n \n from . import planner, tree_utils\n from .models import Plan, Round, RunSettings, Step\n@@ -391,10 +397,9 @@ class AsciiPhylo(Static):\n     AsciiPhylo {\n         width: 1fr;\n         height: 1fr;\n-        border: round $panel-darken-2;\n         padding: 0 1;\n         overflow: hidden;\n-        background: $panel;\n+        background: #0d1117;\n     }\n     \"\"\"\n \n@@ -409,16 +414,11 @@ class AsciiPhylo(Static):\n         Binding(\"j\", \"move_down\", show=False),\n         Binding(\"k\", \"move_up\", show=False),\n         Binding(\"l\", \"move_child\", show=False),\n-        Binding(\"space\", \"toggle_subtree\", \"Toggle RaMAx\"),\n-        Binding(\"f\", \"focus_here\", \"Focus\"),\n-        Binding(\"b\", \"focus_back\", \"Back\"),\n-        Binding(\"g\", \"toggle_mode\", \"Clado/Phylo\"),\n-        Binding(\"+\", \"zoom_in\", \"Zoom in\"),\n-        Binding(\"-\", \"zoom_out\", \"Zoom out\"),\n+        Binding(\"space\", \"toggle_apply\", \"Toggle\"),\n+        Binding(\"b\", \"toggle_scope\", \"Scope node/subtree\"),\n         Binding(\"/\", \"open_search\", \"Search\"),\n         Binding(\"n\", \"search_next\", show=False),\n         Binding(\"shift+n\", \"search_prev\", show=False),\n-        Binding(\"a\", \"toggle_ascii\", \"ASCII mode\"),\n     ]\n \n     def __init__(self, root: tree_utils.AlignmentNode, *, id: str = \"ascii-phylo\"):\n@@ -428,8 +428,8 @@ def __init__(self, root: tree_utils.AlignmentNode, *, id: str = \"ascii-phylo\"):\n         self._stack: list[tree_utils.AlignmentNode] = []\n         self._mode = \"clado\"\n         self._ascii_only = False\n-        self._scale_x = 1.0\n-        self._y_gap = 2\n+        self._scale_x = 1.0  # Controls horizontal/vertical scaling.\n+        self._x_gap = 6  # Leaf spacing on the horizontal grid.\n         self._view_x = 0\n         self._view_y = 0\n         self._ordered_children: dict[tree_utils.AlignmentNode, list[tree_utils.AlignmentNode]] = {}\n@@ -444,6 +444,9 @@ def __init__(self, root: tree_utils.AlignmentNode, *, id: str = \"ascii-phylo\"):\n         self._content_width = 0\n         self._content_height = 0\n         self._visual = Text()\n+        self._toggle_scope: str = \"subtree\"  # node | subtree\n+        self._bulk_root: tree_utils.AlignmentNode | None = None\n+        self._bulk_state: bool | None = None\n \n     def set_detail_callback(\n         self,\n@@ -483,56 +486,107 @@ def action_move_child(self) -> None:\n                 return\n         self._notify(self._cursor, \"Only species leaves under this node.\")\n \n-    def action_toggle_subtree(self) -> None:\n+    def action_toggle_apply(self) -> None:\n+        \"\"\"Toggle apply behavior according to the current scope (single node or subtree).\"\"\"\n+        if self._toggle_scope == \"subtree\":\n+            self._toggle_subtree()\n+        else:\n+            self._toggle_single()\n+\n+    def action_toggle_scope(self) -> None:\n+        \"\"\"Switch scope mode and highlight the current subtree as a cue.\"\"\"\n+        self._toggle_scope = \"subtree\" if self._toggle_scope == \"node\" else \"node\"\n+        scope_label = \"Subtree\" if self._toggle_scope == \"subtree\" else \"Single node\"\n+        self._rebuild_visual()\n+        self.refresh()\n+        self._notify(self._cursor, f\"Scope switched to: {scope_label}\")\n+\n+    def _toggle_single(self) -> None:\n+        if not self._cursor.round:\n+            self._notify(self._cursor, \"No round on this node; nothing to toggle.\")\n+            return\n+        # If a parent subtree was toggled in bulk, revert it first to avoid mixed states.\n+        if self._maybe_revert_bulk(self._cursor):\n+            return\n+        round_entry = self._cursor.round\n+        round_entry.replace_with_ramax = not round_entry.replace_with_ramax\n+        state = \"RaMAx\" if round_entry.replace_with_ramax else \"cactus\"\n+        self._rebuild_visual()\n+        self.refresh()\n+        self._notify(self._cursor, f\"Current round switched to {state}\")\n+\n+    def _toggle_subtree(self) -> None:\n         rounds = list(self._cursor.iter_rounds())\n         if not rounds:\n             self._notify(self._cursor, \"No rounds in this subtree can be toggled.\")\n             return\n         target_state = not all(r.replace_with_ramax for r in rounds)\n         for round_entry in rounds:\n             round_entry.replace_with_ramax = target_state\n+        # Track the latest subtree toggle so child toggles can revert it if needed.\n+        self._bulk_root = self._cursor if target_state else None\n+        self._bulk_state = target_state if target_state else None\n         message = (\n             f\"Toggled {len(rounds)} round(s) to RaMAx\"\n             if target_state\n             else f\"Restored {len(rounds)} round(s) to cactus\"\n         )\n         self._rebuild_visual()\n         self.refresh()\n-        self._notify(self._cursor, message)\n+        self._notify(self._cursor, f\"{message} (scope: subtree)\")\n \n-    def action_focus_here(self) -> None:\n-        if self._cursor is self._root:\n-            return\n-        self._stack.append(self._root)\n-        self._root = self._cursor\n-        self._layout()\n-        self._notify(self._cursor, \"Focused on this subtree.\")\n+    def _maybe_revert_bulk(self, node: tree_utils.AlignmentNode) -> bool:\n+        \"\"\"If a subtree was toggled to RaMAx and the current node lies within it, revert the bulk change first.\"\"\"\n \n-    def action_focus_back(self) -> None:\n-        if not self._stack:\n-            return\n-        self._root = self._stack.pop()\n-        self._layout()\n-        self._notify(self._cursor, \"Returned to previous view.\")\n+        if not (self._bulk_root and self._bulk_state):\n+            return False\n+        if self._bulk_state is not True:\n+            return False\n+        if node is self._bulk_root:\n+            return False\n \n-    def action_toggle_mode(self) -> None:\n-        self._mode = \"phylo\" if self._mode == \"clado\" else \"clado\"\n-        self._layout()\n-        self._notify(self._cursor, f\"Switched to {self._mode} mode.\")\n+        # Check whether the node is within the recorded subtree.\n+        bulk_nodes = self._collect_subtree_nodes(self._bulk_root)\n+        if node not in bulk_nodes:\n+            return False\n \n-    def action_zoom_in(self) -> None:\n-        self._scale_x = min(8.0, self._scale_x * 1.2)\n-        self._layout()\n+        for round_entry in self._bulk_root.iter_rounds():\n+            round_entry.replace_with_ramax = False\n \n-    def action_zoom_out(self) -> None:\n-        self._scale_x = max(0.3, self._scale_x / 1.2)\n-        self._layout()\n+        # Clear bulk tracking flags\n+        self._bulk_root = None\n+        self._bulk_state = None\n \n-    def action_toggle_ascii(self) -> None:\n-        self._ascii_only = not self._ascii_only\n         self._rebuild_visual()\n         self.refresh()\n-        self._notify(self._cursor, \"ASCII mode enabled\" if self._ascii_only else \"Box drawing restored.\")\n+        self._notify(\n+            node,\n+            \"Exited subtree-wide RaMAx; the subtree is restored to cactus. Reselect the subtree before enabling nodes individually.\",\n+        )\n+        self._show_revert_modal()\n+        return True\n+\n+    def _show_revert_modal(self) -> None:\n+        \"\"\"Show a modal hint so the notice is not lost.\"\"\"\n+\n+        try:\n+            app = self.app  # Only available when the Textual app is running; tests may not mount it.\n+        except Exception:\n+            app = None\n+        if app and hasattr(app, \"push_screen\"):\n+            app.push_screen(\n+                InfoModal(\n+                    \"Bulk mode exited\",\n+                    (\n+                        \"The RaMAx toggle for that subtree has been reverted to cactus.\\n\\n\"\n+                        \"Reason: you selected a node inside that subtree while in single-node mode.\\n\\n\"\n+                        \"To reapply in bulk, switch back to subtree mode (press b) and then press space.\"\n+                    ),\n+                )\n+            )\n+\n+    def action_toggle_ascii(self) -> None:\n+        pass\n \n     def action_open_search(self) -> None:\n         prompt = SearchModal(self._search_term or \"\")\n@@ -653,48 +707,60 @@ def order_children(node: tree_utils.AlignmentNode) -> None:\n \n         leaf_index = 0\n \n-        def assign_y(node: tree_utils.AlignmentNode) -> float:\n+        def assign_x(node: tree_utils.AlignmentNode) -> float:\n+            \"\"\"Horizontal layout: leaves are evenly spaced; internal nodes take the mean of their children.\"\"\"\n             nonlocal leaf_index\n             children = self._ordered_children.get(node, [])\n             if not children:\n-                self._y_map[node] = float(leaf_index * self._y_gap)\n+                gap = max(3, int(self._x_gap * self._scale_x))\n+                self._x_map[node] = float(leaf_index * gap)\n                 leaf_index += 1\n-                return self._y_map[node]\n-            child_ys = [assign_y(child) for child in children]\n-            top = min(child_ys)\n-            bottom = max(child_ys)\n-            self._y_map[node] = (top + bottom) / 2\n-            return self._y_map[node]\n+                return self._x_map[node]\n+            child_xs = [assign_x(child) for child in children]\n+            center = sum(child_xs) / len(child_xs)\n+            self._x_map[node] = center\n+            return center\n \n-        assign_y(self._root)\n+        assign_x(self._root)\n \n-        step = max(3, int(6 * self._scale_x))\n-        self._x_map[self._root] = 0\n+        self._y_map[self._root] = 0.0\n+        base_step = max(3, int(4 * self._scale_x))\n+        \n+        # Find the longest branch to normalize the visual spacing.\n+        max_len = 0.0\n+        def find_max_len(node: tree_utils.AlignmentNode) -> None:\n+            nonlocal max_len\n+            if node.length is not None:\n+                max_len = max(max_len, node.length)\n+            for child in node.children:\n+                find_max_len(child)\n+        find_max_len(self._root)\n+        self._max_branch_length = max_len if max_len > 0 else 1.0\n \n-        def assign_x(node: tree_utils.AlignmentNode) -> None:\n-            base = self._x_map[node]\n+        def assign_y(node: tree_utils.AlignmentNode) -> None:\n+            base_y = self._y_map[node]\n             children = self._ordered_children.get(node, [])\n             for child in children:\n                 if self._mode == \"phylo\":\n                     increment = child.length if child.length is not None else 1.0\n                     increment = max(0.1, increment)\n                 else:\n-                    increment = 2.0\n-                delta = max(2, int(increment * step))\n-                self._x_map[child] = base + delta\n-                assign_x(child)\n+                    increment = 1.0\n+                delta = max(2, int(math.ceil(base_step * increment)))\n+                self._y_map[child] = base_y + delta\n+                assign_y(child)\n \n-        assign_x(self._root)\n+        assign_y(self._root)\n \n         self._linear = sorted(\n             self._y_map.keys(),\n             key=lambda node: (self._y_map[node], self._x_map.get(node, 0)),\n         )\n         if self._cursor not in self._linear:\n             self._cursor = self._root\n-        self._content_width = max(self._x_map.values(), default=0) + 40\n+        self._content_width = int(max(self._x_map.values(), default=0)) + 20\n         max_y = math.ceil(max(self._y_map.values(), default=0))\n-        self._content_height = max_y + 10\n+        self._content_height = max_y + 6\n         self._ensure_visible(self._cursor)\n         self._rebuild_visual()\n         self.refresh()\n@@ -733,12 +799,12 @@ def _glyphs(self) -> dict[str, str]:\n         return {\n             \"h\": \"â”€\",\n             \"v\": \"â”‚\",\n-            \"tee\": \"â”œ\",\n-            \"elbow\": \"â””\",\n-            \"top\": \"â”Œ\",\n+            \"tee\": \"â”œâ”€\",\n+            \"elbow\": \"â””â”€\",\n+            \"top\": \"â”Œâ”€\",\n             \"dot\": \"â—\",\n-            \"lite\": \"â—‡\",\n-            \"parent\": \"â—Ž\",\n+            \"lite\": \"â—‹\",\n+            \"parent\": \"â—ˆ\",\n         }\n \n     def _compute_states(self) -> None:\n@@ -790,112 +856,129 @@ def _connector_highlight(self, parent_kind: str | None, child_kind: str | None)\n         return None\n \n     def _rebuild_visual(self) -> None:\n-        if not self._y_map:\n-            self._visual = Text(\"\")\n-            return\n-        self._compute_states()\n-        width = max(40, self.size.width - 2)\n-        height = max(10, self.size.height - 2)\n         glyphs = self._glyphs()\n-        grid = [[\" \" for _ in range(width)] for _ in range(height)]\n-        styles = [[\"\" for _ in range(width)] for _ in range(height)]\n-        label_margin = 2\n-\n-        selected_highlight: set[tree_utils.AlignmentNode] = set()\n-        if self._cursor:\n-            selected_highlight = self._collect_round_nodes(self._cursor)\n-        ramax_highlight: set[tree_utils.AlignmentNode] = {\n-            node\n-            for node in self._y_map.keys()\n-            if node.round and node.round.replace_with_ramax\n-        }\n+        highlight_subtree = self._toggle_scope == \"subtree\"\n+        highlighted_nodes: set[tree_utils.AlignmentNode] = set()\n+        if highlight_subtree and self._cursor:\n+            highlighted_nodes = self._collect_subtree_nodes(self._cursor)\n+\n+        def label_for(node: tree_utils.AlignmentNode) -> str:\n+            \"\"\"Return the full label text without truncation.\"\"\"\n+            name = node.name or \"(unnamed)\"\n+            parts = [name]\n+            if node.round:\n+                # Keep round state only; no extra leaf marker.\n+                tag = \"[RaMAx]\" if node.round.replace_with_ramax else \"[Cactus]\"\n+                parts.append(tag)\n+            return \" \".join(parts)\n+\n+        # Connectors use a fixed four-column indent and consistent heavy glyphs.\n+        tee = \"â”£â”â” \"\n+        elbow = \"â”—â”â” \"\n+        pipe = \"â”ƒ   \"\n+        space = \"    \"\n+\n+        # Pass 1: Build base lines and calculate max width\n+        raw_lines: list[tuple[Text, tree_utils.AlignmentNode]] = []\n+        self._x_map.clear()\n+        self._y_map.clear()\n+        max_width = 0\n+\n+        def walk(node: tree_utils.AlignmentNode, prefix: str, is_last: bool, depth: int) -> None:\n+            connector = \"\" if depth == 0 else (elbow if is_last else tee)\n+            \n+            # --- Icon Selection ---\n+            if not node.children:\n+                # Leaf Node: Nature/Green theme\n+                icon = \"â— \" \n+            else:\n+                # Ancestor Node: Structure/Blue theme\n+                icon = \"â—ˆ \"\n \n-        def highlight_kind(node: tree_utils.AlignmentNode) -> str | None:\n-            if node in selected_highlight:\n-                return \"selected\"\n-            if node in ramax_highlight:\n-                return \"ramax\"\n-            return None\n+            # --- RaMAx State Indicator (Scheme A) ---\n+            indicator_char = \"â”‚\" # Default\n+            indicator_style = \"#6272a4\" \n+\n+            if node.round and node.round.replace_with_ramax:\n+                indicator_char = \"âš\" # Golden bar\n+                indicator_style = \"#fcbf49\"\n \n-        def highlight_color(kind: str | None, default: str) -> str:\n-            if kind == \"ramax\":\n-                return \"#fcbf49\"\n-            if kind == \"selected\":\n-                return \"#4cc9f0\"\n-            return default\n-\n-        def draw_char(x: int, y: int, ch: str, style: str = \"\") -> None:\n-            vx = x - self._view_x\n-            vy = y - self._view_y\n-            if 0 <= vx < width and 0 <= vy < height:\n-                grid[vy][vx] = ch\n-                styles[vy][vx] = style\n-\n-        def draw_branch(parent: tree_utils.AlignmentNode) -> None:\n-            px = self._x_map[parent]\n-            py = int(round(self._y_map[parent]))\n-            children = self._ordered_children.get(parent, [])\n-            if children:\n-                child_ys = [int(round(self._y_map[child])) for child in children]\n-                y0, y1 = min(child_ys), max(child_ys)\n-                parent_kind = highlight_kind(parent)\n-                vertical_style = highlight_color(parent_kind, \"#3c445c\")\n-                for y in range(y0, y1 + 1):\n-                    draw_char(px, y, glyphs[\"v\"], vertical_style)\n-                last_index = len(children) - 1\n-                for index, child in enumerate(children):\n-                    cx = self._x_map[child]\n-                    cy = int(round(self._y_map[child]))\n-                    if len(children) == 1:\n-                        joint = glyphs[\"elbow\"]\n-                    elif index == 0:\n-                        joint = glyphs.get(\"top\", glyphs[\"tee\"])\n-                    elif index == last_index:\n-                        joint = glyphs[\"elbow\"]\n-                    else:\n-                        joint = glyphs[\"tee\"]\n-                    child_kind = highlight_kind(child)\n-                    joint_kind = self._connector_highlight(parent_kind, child_kind)\n-                    connector_style = highlight_color(joint_kind, vertical_style)\n-                    draw_char(px, cy, joint, connector_style)\n-                    for x in range(min(px + 1, cx), cx + 1):\n-                        draw_char(x, cy, glyphs[\"h\"], connector_style)\n-                    if self._mode == \"clado\" and child.length is not None:\n-                        text = f\"{child.length:.3f}\"\n-                        available = max(0, cx - px - 1)\n-                        if available >= len(text):\n-                            start = px + 1 + max(0, (available - len(text)) // 2)\n-                            start = min(start, cx - len(text))\n-                            for offset, ch in enumerate(text):\n-                                draw_char(start + offset, cy, ch, \"#6b768f\")\n-                    draw_branch(child)\n-            style = \"#ffffff\" if parent is self._cursor else self._state_color(parent)\n-            style = highlight_color(highlight_kind(parent), style)\n-            support = parent.support if parent.support is not None else 100.0\n-            if parent.children:\n-                node_char = glyphs.get(\"parent\", \"â—Ž\")\n-            else:\n-                node_char = glyphs[\"dot\"] if support >= 70 else glyphs[\"lite\"]\n-            draw_char(px, py, node_char, style)\n-            label = parent.name or \"(unnamed)\"\n-            label = f\"> {label}\" if parent is self._cursor else f\"  {label}\"\n-            x0 = px + label_margin\n-            for offset, ch in enumerate(label):\n-                draw_char(x0 + offset, py, ch, style)\n-\n-        draw_branch(self._root)\n-        lines: list[Text] = []\n-        for row_chars, row_styles in zip(grid, styles):\n             line = Text()\n-            for ch, style in zip(row_chars, row_styles):\n-                if style:\n-                    line.append(ch, style=style)\n+            line.append(indicator_char, style=indicator_style)\n+            \n+            # Prefix carries the vertical indentation from ancestors; render it with a uniform cool-gray style.\n+            line.append(prefix, style=\"#6272a4\")\n+            if connector:\n+                line.append(connector, style=\"#6272a4\")\n+            \n+            label_text = label_for(node)\n+            display_text_object = Text()\n+\n+            # --- Scheme A: Cursor Highlight ---\n+            if node is self._cursor:\n+                # High-contrast background (bright purple) and bold brackets\n+                display_text_object.append(f\"ã€ {icon}{label_text} ã€‘\", style=\"bold #1e1e2e on #bd93f9\")\n+            \n+            # --- Scheme A: RaMAx State ---\n+            elif node.round and node.round.replace_with_ramax:\n+                display_text_object.append(f\"{icon}{label_text}\", style=\"bold #1e1e2e on #fcbf49\")\n+            \n+            # --- Scheme A: Subtree Scope Highlight ---\n+            elif highlight_subtree and node in highlighted_nodes:\n+                if self._ascii_only:\n+                    display_text_object.append(f\"[ {icon}{label_text} ]\", style=\"bold #1e1e2e on #94a3b8\")\n                 else:\n-                    line.append(ch)\n-            line.rstrip()\n-            lines.append(line)\n-        rendered = Text(\"\\n\").join(lines)\n-        self._visual = rendered\n+                    display_text_object.append(f\"ã€” {icon}{label_text} ã€•\", style=\"bold #1e1e2e on #2d3b55\")\n+            \n+            # --- Default: Leaf vs Ancestor Distinction ---\n+            elif not node.children:\n+                # Leaf: Green, lighter weight\n+                display_text_object.append(f\"{icon}{label_text}\", style=\"#a6e3a1\") \n+            else:\n+                # Ancestor: Blue, Bold\n+                display_text_object.append(f\"{icon}{label_text}\", style=\"bold #89b4fa\")\n+            \n+            line.append(display_text_object)\n+\n+            nonlocal max_width\n+            max_width = max(max_width, line.cell_len)\n+            \n+            y = len(raw_lines)\n+            x = len(prefix) + (0 if depth == 0 else len(connector))\n+            self._x_map[node] = x\n+            self._y_map[node] = y\n+            raw_lines.append((line, node))\n+\n+            children = self._ordered_children.get(node, [])\n+            for idx, child in enumerate(children):\n+                child_is_last = idx == len(children) - 1\n+                child_prefix = prefix + (space if is_last else pipe)\n+                walk(child, child_prefix, child_is_last, depth + 1)\n+\n+        walk(self._root, \"\", True, 0)\n+\n+        # Pass 2: Add dotted leader and branch length\n+        final_lines: list[Text] = []\n+        target_width = max_width + 4 # Reserve gap\n+\n+        for line, node in raw_lines:\n+            if node.length is not None:\n+                current_len = line.cell_len\n+                padding = max(2, target_width - current_len)\n+                dots = \".\" * padding\n+                len_str = f\" {node.length:.4g}\"\n+                \n+                # Append dotted leader and length\n+                line.append(dots, style=\"#6272a4\")\n+                line.append(len_str, style=\"bold cyan\")\n+            final_lines.append(line)\n+\n+        self._linear = sorted(self._y_map.keys(), key=lambda n: (self._y_map[n], self._x_map[n]))\n+        self._content_height = len(final_lines)\n+        self._content_width = max((len(t.plain) for t in final_lines), default=0)\n+        self._view_x = 0\n+        self._view_y = 0\n+        self._visual = Text(\"\\n\").join(final_lines)\n \n     def render(self) -> Text:  # type: ignore[override]\n         return self._visual\n@@ -986,6 +1069,395 @@ def update(self, message: RenderableType | str) -> None:\n             summary_plain = \"\"\n         self.app.sub_title = summary_plain[:80]\n \n+\n+class DashboardHUD(Static):\n+    \"\"\"Bottom HUD panel that shows the current node status and summary.\"\"\"\n+\n+    def __init__(self) -> None:\n+        super().__init__()\n+        self._current_node: tree_utils.AlignmentNode | None = None\n+        self._metrics: dict[str, object] = {}\n+        self._gpu_disabled = False\n+        self._spinner = itertools.cycle(\"â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â \")\n+\n+    def on_mount(self) -> None:  # type: ignore[override]\n+        # Warm up CPU sampling so the first reading is not zero.\n+        try:\n+            psutil.cpu_percent(interval=None)\n+        except Exception:\n+            pass\n+        self._metrics = self._collect_metrics()\n+        self.update(self._render_empty())\n+        self.set_interval(1.0, self._refresh_metrics)\n+\n+    def update_node(self, node: tree_utils.AlignmentNode) -> None:\n+        self._current_node = node\n+        self.update(self._render_dashboard(node))\n+\n+    def update_node_placeholder(self, renderable: RenderableType | str) -> None:\n+        self._current_node = None\n+        self.update(renderable)\n+\n+    def update_message(self, renderable: RenderableType | str) -> None:\n+        self.update(renderable)\n+\n+    def _refresh_metrics(self) -> None:\n+        self._metrics = self._collect_metrics()\n+        if self._current_node:\n+            self.update(self._render_dashboard(self._current_node))\n+\n+    def _render_empty(self) -> Panel:\n+        return Panel(Align.center(\"Waiting for selection...\", vertical=\"middle\"), title=\"System Status\")\n+\n+    def _draw_bar(self, percentage: float, width: int = 15, color: str = \"blue\") -> Text:\n+        percentage = max(0.0, min(1.0, percentage))\n+        filled_len = int(percentage * width)\n+        bar = \"âš\" * filled_len + \"Â·\" * (width - filled_len)\n+        return Text(bar, style=color)\n+\n+    def _info_block(self, label: str, body: RenderableType, *, accent: str = \"white\") -> RenderableType:\n+        title = Text(label, style=f\"bold {accent}\")\n+        return Group(title, body)\n+\n+    def _subtree_stats(self, node: tree_utils.AlignmentNode) -> dict[str, object]:\n+        rounds = list(node.iter_rounds())\n+        total_rounds = len(rounds)\n+        ramax_rounds = sum(1 for r in rounds if r.replace_with_ramax)\n+        hal2fasta = sum(len(r.hal2fasta_steps) for r in rounds)\n+\n+        def _depth(n: tree_utils.AlignmentNode) -> int:\n+            if not n.children:\n+                return 1\n+            return 1 + max(_depth(c) for c in n.children)\n+\n+        def _leaves(n: tree_utils.AlignmentNode) -> int:\n+            if not n.children:\n+                return 1\n+            return sum(_leaves(c) for c in n.children)\n+\n+        jobstore = None\n+        for r in rounds:\n+            for step in (r.blast_step, r.align_step):\n+                if step and step.jobstore:\n+                    jobstore = step.jobstore\n+                    break\n+            if jobstore:\n+                break\n+        return {\n+            \"total_rounds\": total_rounds,\n+            \"ramax_rounds\": ramax_rounds,\n+            \"hal2fasta\": hal2fasta,\n+            \"leaves\": _leaves(node),\n+            \"depth\": _depth(node),\n+            \"jobstore\": jobstore,\n+        }\n+\n+    def _render_dashboard(self, node: tree_utils.AlignmentNode) -> Table:\n+        # Mode and theme color\n+        if node.round:\n+            if node.round.replace_with_ramax:\n+                mode_icon = \"âš¡\"\n+                mode_name = \"RaMAx Accelerated\"\n+                theme_color = \"yellow\"\n+            else:\n+                mode_icon = \"ðŸŒµ\"\n+                mode_name = \"Cactus Classic\"\n+                theme_color = \"cyan\"\n+            file_type = \"HAL\"\n+            target_file = Path(node.round.target_hal).name\n+        else:\n+            mode_icon = \"ðŸŒ¿\"\n+            mode_name = \"Leaf Genome\"\n+            theme_color = \"green\"\n+            file_type = \"FASTA\"\n+            target_file = node.name or \"(leaf)\"\n+\n+        base_dir = getattr(self.app, \"base_dir\", Path.cwd())\n+        grid = Table.grid(expand=True, padding=(0, 2))\n+        grid.add_column(ratio=1)\n+        grid.add_column(ratio=2)\n+        grid.add_column(ratio=1)\n+\n+        # --- Left column: identity card ---\n+        id_table = Table.grid(expand=True, padding=(0, 1))\n+        id_table.add_column(justify=\"right\", style=\"dim #6272a4\", width=8)\n+        id_table.add_column(justify=\"left\", ratio=1)\n+\n+        # Row 1: Node Name\n+        id_table.add_row(\"Node\", Text(f\"{mode_icon} {node.name or 'Unknown'}\", style=\"bold white\"))\n+        \n+        # Row 2: Parent & Length\n+        parent_name = node.parent.name if getattr(node, \"parent\", None) else \"None (Root)\"\n+        length_val = getattr(node, \"length\", None)\n+        length_str = f\"{length_val:.4g}\" if length_val is not None else \"-\"\n+        \n+        meta_info = Text.assemble(\n+            (parent_name, \"white\"),\n+            (\"  Len: \", \"dim #6272a4\"),\n+            (length_str, \"cyan\")\n+        )\n+        id_table.add_row(\"Parent\", meta_info)\n+\n+        # Row 3: Mode\n+        id_table.add_row(\"Mode\", Text(mode_name, style=theme_color))\n+        \n+        # Output Check\n+        out_status = \"white\"\n+        out_info = \"\"\n+        if node.round and node.round.target_hal:\n+            out_path = base_dir / node.round.target_hal\n+            if out_path.exists():\n+                 out_status = \"green\"\n+                 try:\n+                     size = out_path.stat().st_size\n+                     for unit in [\"B\", \"KB\", \"MB\", \"GB\", \"TB\"]:\n+                         if size < 1024:\n+                             break\n+                         size /= 1024\n+                     out_info = f\" ({size:.1f}{unit})\"\n+                 except Exception:\n+                     out_info = \" (Ready)\"\n+            else:\n+                 out_status = \"dim white\"\n+                 out_info = \" (Pending)\"\n+        \n+        # Row 4: Output File\n+        id_table.add_row(\"Output\", Text(f\"{target_file}{out_info}\", overflow=\"ellipsis\", style=out_status))\n+\n+        # Row 5: Workdir / Root\n+        if node.round:\n+            wd_status = \"white\"\n+            if node.round.workdir:\n+                wd_path = base_dir / node.round.workdir\n+                if wd_path.exists() and wd_path.is_dir():\n+                    wd_status = \"green\"\n+                else:\n+                    wd_status = \"dim white\"\n+            workdir_text = node.round.workdir or \"N/A\"\n+            id_table.add_row(\"Workdir\", Text(workdir_text, overflow=\"ellipsis\", style=wd_status))\n+            \n+            if node.round.manual_ramax_command:\n+                id_table.add_row(\"Custom\", Text(\"Manual Command Set\", style=\"bold yellow\"))\n+\n+        identity_panel = Panel(id_table, title=\"[Identity]\", border_style=f\"dim {theme_color}\", padding=(0, 1), height=11)\n+\n+        # --- Middle column: statistics overview ---\n+        stats = self._subtree_stats(node)\n+        \n+        # Get whole-tree statistics\n+        total_stats = stats\n+        if hasattr(self.app, \"alignment_tree\") and self.app.alignment_tree:\n+             total_stats = self._subtree_stats(self.app.alignment_tree.root)\n+\n+        def _make_section(title: str, data: dict, color: str) -> RenderableType:\n+             cov = (data[\"ramax_rounds\"] / data[\"total_rounds\"]) if data[\"total_rounds\"] else 0.0\n+             # Dynamically adjust progress-bar width\n+             mid_width = max(20, self.size.width // 3)\n+             bar_w = max(6, min(15, mid_width - 22))\n+             \n+             bar = self._metric_bar(cov * 100, bar_width=bar_w, accent=color)\n+             cov_txt = f\"{data['ramax_rounds']}/{data['total_rounds']}\"\n+             \n+             # First line: title + progress bar + value\n+             header = Table.grid(expand=True, padding=(0, 1))\n+             header.add_column(style=f\"bold {color}\", width=8)\n+             header.add_column()\n+             header.add_column(justify=\"right\", width=len(cov_txt))\n+             header.add_row(title, bar, Text(cov_txt, style=\"white\"))\n+             \n+             # Second line: detail metrics\n+             details = Text.assemble(\n+                 (\"Leaves: \", \"dim #6272a4\"), (str(data['leaves']), \"white\"), \"  \",\n+                 (\"Depth: \", \"dim #6272a4\"), (str(data['depth']), \"white\"), \"  \",\n+                 (\"H2F: \", \"dim #6272a4\"), (str(data['hal2fasta']), \"white\")\n+             )\n+             return Group(header, details)\n+\n+        sub_group = _make_section(\"Subtree\", stats, \"yellow\")\n+        tot_group = _make_section(\"Total\", total_stats, \"cyan\")\n+        \n+        # Combine sections with an empty line in between\n+        content = Group(sub_group, Text(\" \"), tot_group)\n+        \n+        config_panel = Panel(content, title=\"[Statistics]\", border_style=\"dim white\", padding=(0, 1), height=11)\n+\n+        # Right column: live system metrics\n+        metrics_panel = self._render_metrics_panel()\n+\n+        grid.add_row(identity_panel, config_panel, metrics_panel)\n+        return grid\n+\n+    def _render_metrics_panel(self) -> Panel:\n+        metrics = self._metrics or {}\n+        cpu_percent = metrics.get(\"cpu_percent\")\n+        mem = metrics.get(\"mem\")\n+        gpus = metrics.get(\"gpus\")\n+        disk = metrics.get(\"disk\")\n+        spinner = next(self._spinner)\n+\n+        # Adjust bar width to work on narrow terminals.\n+        right_width = max(30, self.size.width // 3)\n+        bar_width = max(10, min(30, right_width - 10))\n+\n+        blocks: list[RenderableType] = []\n+\n+        blocks.append(\n+            self._metric_block(\"CPU\", cpu_percent, f\"{cpu_percent:.0f}%\" if isinstance(cpu_percent, (int, float)) else \"-\", \"cyan\", bar_width)\n+        )\n+\n+        if isinstance(mem, dict):\n+            m_percent = mem.get(\"percent\", 0.0)\n+            used = mem.get(\"used_gb\")\n+            total = mem.get(\"total_gb\")\n+            usage = f\"{used:.1f}/{total:.1f} GB\" if used is not None and total is not None else \"\"\n+            blocks.append(\n+                self._metric_block(\"Memory\", m_percent, f\"{m_percent:.0f}% {usage}\".strip(), \"green\", bar_width)\n+            )\n+        else:\n+            blocks.append(self._metric_block(\"Memory\", None, \"N/A\", \"green\", bar_width))\n+\n+        if isinstance(gpus, list) and gpus:\n+            gpu = gpus[0]\n+            g_util = gpu.get(\"util\", 0.0)\n+            g_mem_percent = gpu.get(\"mem_percent\", 0.0)\n+            g_mem = f\"{gpu.get('mem_used', 0):.1f}/{gpu.get('mem_total', 0):.1f} GB\"\n+            detail = f\"{g_util:.0f}% {g_mem} ({g_mem_percent:.0f}%)\"\n+            blocks.append(self._metric_block(\"GPU\", g_util, detail, \"yellow\", bar_width))\n+        else:\n+            blocks.append(self._metric_block(\"GPU\", None, \"Not detected\", \"yellow\", bar_width))\n+\n+        if isinstance(disk, dict):\n+            d_percent = disk.get(\"percent\", 0.0)\n+            d_text = f\"{d_percent:.0f}% {disk.get('used_gb', 0):.1f}/{disk.get('total_gb', 0):.1f} GB\"\n+            blocks.append(self._metric_block(\"Disk\", d_percent, d_text, \"magenta\", bar_width))\n+\n+        table = Table.grid(padding=(0, 0), expand=True)\n+        table.add_column(ratio=1)\n+        for block in blocks:\n+            table.add_row(block)\n+\n+        title = Text.assemble(\n+            (\"[Live] \", \"dim\"),\n+            (\"System resources \", \"white\"),\n+            (spinner, \"cyan\"),\n+        )\n+        return Panel(table, title=title, border_style=\"bright_blue\", padding=(0, 1), height=11)\n+\n+    def _bar_color(self, percent: float) -> str:\n+        if percent >= 85:\n+            return \"red\"\n+        if percent >= 60:\n+            return \"yellow\"\n+        return \"green\"\n+\n+    def _metric_bar(self, percent: float | None, bar_width: int = 22, accent: str = \"green\") -> Text:\n+        if percent is None:\n+            return Text(\"N/A\", style=\"dim\")\n+        pct = max(0.0, min(100.0, float(percent)))\n+        return self._draw_bar(pct / 100.0, width=bar_width, color=self._bar_color(pct))\n+\n+    def _metric_block(\n+        self,\n+        label: str,\n+        percent: float | None,\n+        detail: str,\n+        accent: str,\n+        bar_width: int,\n+    ) -> RenderableType:\n+        title = Text(label, style=f\"bold {accent}\")\n+        bar = self._metric_bar(percent, bar_width=bar_width, accent=accent)\n+        value = Text(detail, style=\"white\")\n+        bar_line = Text.assemble(bar, \"  \", value, no_wrap=True)\n+        return Group(title, bar_line)\n+\n+    def _metric_text(self, percent: float | None, suffix: str = \"\") -> Text:\n+        if percent is None:\n+            return Text(\"-\", style=\"dim\")\n+        return Text(f\"{percent:4.0f}{suffix}\", style=\"white\")\n+\n+    def _collect_metrics(self) -> dict[str, object]:\n+        data: dict[str, object] = {}\n+        try:\n+            cpu_percent = psutil.cpu_percent(interval=None)\n+            data[\"cpu_percent\"] = cpu_percent\n+        except Exception:\n+            pass\n+\n+        try:\n+            mem = psutil.virtual_memory()\n+            data[\"mem\"] = {\n+                \"percent\": mem.percent,\n+                \"used_gb\": mem.used / (1024**3),\n+                \"total_gb\": mem.total / (1024**3),\n+            }\n+        except Exception:\n+            pass\n+\n+        try:\n+            disk = psutil.disk_usage(Path.cwd())\n+            data[\"disk\"] = {\n+                \"percent\": disk.percent,\n+                \"used_gb\": disk.used / (1024**3),\n+                \"total_gb\": disk.total / (1024**3),\n+            }\n+        except Exception:\n+            pass\n+\n+        gpu_stats = self._collect_gpu_metrics()\n+        if gpu_stats:\n+            data[\"gpus\"] = gpu_stats\n+        return data\n+\n+    def _collect_gpu_metrics(self) -> list[dict[str, float]] | None:\n+        if self._gpu_disabled:\n+            return None\n+        if shutil.which(\"nvidia-smi\") is None:\n+            self._gpu_disabled = True\n+            return None\n+        try:\n+            result = subprocess.run(\n+                [\n+                    \"nvidia-smi\",\n+                    \"--query-gpu=utilization.gpu,memory.used,memory.total\",\n+                    \"--format=csv,noheader,nounits\",\n+                ],\n+                capture_output=True,\n+                text=True,\n+                timeout=0.3,\n+                check=True,\n+            )\n+        except (subprocess.SubprocessError, FileNotFoundError):\n+            self._gpu_disabled = True\n+            return None\n+\n+        gpus: list[dict[str, float]] = []\n+        for line in result.stdout.splitlines():\n+            if not line.strip():\n+                continue\n+            parts = [p.strip() for p in line.split(\",\")]\n+            if len(parts) < 3:\n+                continue\n+            try:\n+                util = float(parts[0])\n+                mem_used = float(parts[1])\n+                mem_total = float(parts[2])\n+            except ValueError:\n+                continue\n+            mem_percent = (mem_used / mem_total * 100) if mem_total else 0.0\n+            gpus.append(\n+                {\n+                    \"util\": util,\n+                    \"mem_used\": mem_used / 1024 if mem_used else 0.0,\n+                    \"mem_total\": mem_total / 1024 if mem_total else 0.0,\n+                    \"mem_percent\": mem_percent,\n+                }\n+            )\n+\n+        if not gpus:\n+            self._gpu_disabled = True\n+            return None\n+        return gpus\n+\n class RunSettingsScreen(Screen[RunSettings | None]):\n     \"\"\"Dedicated screen for confirming run-time configuration.\"\"\"\n \n@@ -1359,25 +1831,76 @@ def on_button_pressed(self, event: Button.Pressed) -> None:\n \n class PlanUIApp(App[UIResult]):\n     CSS = \"\"\"\n+    /* Deep Space HUD theme */\n+    $bg-deep: #0f111a;\n+    $bg-panel: #1a1d2e;\n+    $border-bright: #444b6a;\n+    $text-main: #e0def4;\n+    $accent-gold: #f6c177;\n+    $accent-blue: #9ccfd8;\n+    $accent-green: #31748f;\n+\n     Screen {\n         layout: vertical;\n         min-height: 0;\n+        background: $bg-deep;\n+        color: $text-main;\n     }\n-    #main {\n-        width: 100%;\n+    #tree-container {\n         height: 1fr;\n-        min-height: 0;\n-        padding: 0 1;\n+        width: 100%;\n+        background: $bg-deep;\n+        overflow: hidden;\n     }\n-    #ascii-phylo, #ascii-phylo-empty {\n+    AsciiPhylo {\n         width: 100%;\n-        height: 1fr;\n+        height: 100%;\n+        background: $bg-deep;\n+        padding: 1 2;\n     }\n     #ascii-phylo-empty {\n         align: center middle;\n-        color: $text-muted;\n+        color: #6b768f;\n+    }\n+    DashboardHUD {\n+        dock: bottom;\n+        height: 13;\n+        width: 100%;\n+        background: $bg-panel;\n+        border-top: heavy $border-bright;\n     }\n     #editor-command { height: 10; }\n+\n+    ModalScreen {\n+        background: rgba(0, 0, 0, 0.6);\n+        align: center middle;\n+    }\n+    #picker-dialog, #editor-dialog, #info-dialog, #search-dialog, #round-picker, #options-dialog, #run-form {\n+        border: thick $accent;\n+        background: $surface;\n+        padding: 1 2;\n+    }\n+    Input {\n+        background: $bg-panel;\n+        border: none;\n+        color: $text-main;\n+    }\n+    Input:focus {\n+        border: tall $accent-blue;\n+    }\n+    Button {\n+        border: none;\n+        background: $bg-panel;\n+        color: $text-main;\n+    }\n+    Button:hover {\n+        background: $accent-blue;\n+        color: #111;\n+    }\n+    Button.variant-success {\n+        background: #a6e3a1;\n+        color: #111;\n+    }\n     \"\"\"\n \n     BINDINGS = [\n@@ -1393,43 +1916,61 @@ def __init__(self, plan: Plan, base_dir: Optional[Path] = None, run_settings: Op\n         self.base_dir = Path(base_dir) if base_dir else Path.cwd()\n         self.alignment_tree = tree_utils.build_alignment_tree(plan, base_dir=self.base_dir)\n         self.canvas: AsciiPhylo | None = None\n-        self.detail_panel: DetailBuffer | None = None\n         self.run_settings = run_settings or RunSettings()\n+        self.hud: DashboardHUD | None = None\n+        self._last_detail_text: str = \"\"\n \n     def compose(self) -> ComposeResult:\n         yield Header()\n-        with Container(id=\"main\"):\n+        with Container(id=\"tree-container\"):\n             if self.alignment_tree:\n                 canvas = AsciiPhylo(self.alignment_tree.root)\n-                canvas.set_detail_callback(self._show_alignment_node)\n+                canvas.set_detail_callback(self._on_node_selected)\n                 self.canvas = canvas\n                 yield canvas\n             else:\n                 yield Static(\"Alignment tree not found; nothing to render.\", id=\"ascii-phylo-empty\")\n+        hud = DashboardHUD()\n+        self.hud = hud\n+        yield hud\n         yield Footer()\n \n     def on_mount(self) -> None:\n         self.detail_panel = DetailBuffer(self)\n         if self.canvas:\n             self.canvas.focus()\n-            self._show_alignment_node(self.canvas.current_node())\n+            self._on_node_selected(self.canvas.current_node())\n         else:\n             preview = plan_overview(self.plan, run_settings=self.run_settings, compact=self._is_compact())\n             self.detail_panel.update(preview)\n+        \n+        # Delay the welcome overlay slightly so the UI renders first.\n+        self.set_timer(0.3, self._show_welcome_guide)\n+\n+    def _show_welcome_guide(self) -> None:\n+        welcome_text = (\n+            \"Welcome to the Cactus-RaMAx Planner!\\n\\n\"\n+            \"This interactive UI allows you to inspect and configure the phylogenetic alignment plan.\\n\\n\"\n+            \"â€¢ [bold]Navigation[/]: Use Arrow keys or h/j/k/l to browse the tree.\\n\"\n+            \"â€¢ [bold]Toggle RaMAx[/]: Press [bold]SPACE[/] on a node to enable/disable acceleration.\\n\"\n+            \"â€¢ [bold]Edit[/]: Press [bold]Enter[/] or [bold]E[/] to customize commands and options.\\n\"\n+            \"â€¢ [bold]Search[/]: Press [bold]/[/] to find species or nodes.\\n\"\n+            \"â€¢ [bold]Run[/]: Press [bold]R[/] to review settings and start execution.\\n\"\n+        )\n+        self.push_screen(InfoModal(\"Quick Start Guide\", welcome_text))\n \n     def _is_compact(self) -> bool:\n         return self.size.width <= 100\n \n     def action_show_info(self) -> None:\n-        if not self.detail_panel:\n-            return\n-        content = self.detail_panel.text or \"(empty)\"\n+        content = self._last_detail_text or \"(empty)\"\n         self.push_screen(InfoModal(\"Current node details\", content))\n \n     def action_edit_round(self) -> None:\n         if not self.plan.rounds:\n-            if self.detail_panel:\n-                self.detail_panel.update(\"No rounds found in this plan.\")\n+            self._last_detail_text = \"No rounds found in this plan.\"\n+            if self.hud:\n+                self.hud.update_message(self._last_detail_text)\n             return\n         node_round = None\n         if self.canvas:\n@@ -1453,8 +1994,9 @@ def _start_round_edit(self, round_index: int) -> None:\n         round_entry = self.plan.rounds[round_index]\n         targets = self._gather_command_targets(round_entry)\n         if not targets:\n-            if self.detail_panel:\n-                self.detail_panel.update(\"No editable commands for this round.\")\n+            self._last_detail_text = \"No editable commands for this round.\"\n+            if self.hud:\n+                self.hud.update_message(self._last_detail_text)\n             return\n         if len(targets) == 1:\n             self._open_command_editor(round_index, targets[0])\n@@ -1480,8 +2022,10 @@ def export_commands(self, settings: RunSettings | None = None, *, notify_detail:\n         )\n         lines = [cmd.shell_preview() for cmd in commands]\n         output_path.write_text(\"\\n\".join(lines) + \"\\n\", encoding=\"utf-8\")\n-        if notify_detail and self.detail_panel:\n-            self.detail_panel.update(f\"[green]Commands saved to {output_path}[/green]\")\n+        if notify_detail:\n+            self._last_detail_text = f\"[green]Commands saved to {output_path}[/green]\"\n+            if self.hud:\n+                self.hud.update_message(self._last_detail_text)\n         return output_path\n \n     def action_quit(self) -> None:\n@@ -1517,13 +2061,17 @@ def _ramax_options_summary(self, round_entry: Round) -> str:\n         return f\"Global: {global_summary}\\nRound: {round_summary}\"\n \n     def _show_round(self, index: int, status: str | None = None) -> None:\n-        if not self.detail_panel or index >= len(self.plan.rounds):\n+        if index >= len(self.plan.rounds):\n             return\n         round_entry = self.plan.rounds[index]\n         details = self._round_details(round_entry)\n         if status:\n             details.extend([\"\", f\"[green]{status}[/green]\"])\n-        self.detail_panel.update(\"\\n\".join(details))\n+        border_style = \"green\" if round_entry.replace_with_ramax else \"cyan\"\n+        panel = Panel(\"\\n\".join(details), title=round_entry.name, border_style=border_style, padding=(1, 1))\n+        self._last_detail_text = \"\\n\".join(details)\n+        if self.hud:\n+            self.hud.update_message(panel)\n \n     def _gather_command_targets(self, round_entry: Round) -> list[CommandTarget]:\n         targets: list[CommandTarget] = [\n@@ -1584,8 +2132,6 @@ def _show_alignment_node(\n         node: tree_utils.AlignmentNode,\n         status: str | None = None,\n     ) -> None:\n-        if not self.detail_panel:\n-            return\n         details: list[str] = []\n         if node.round:\n             details.extend(self._round_details(node.round))\n@@ -1605,13 +2151,23 @@ def _show_alignment_node(\n             details.extend([\"\", \"No cactus rounds in this subtree (leaf node).\"])\n         if status:\n             details.extend([\"\", f\"[green]{status}[/green]\"])\n-        self.detail_panel.update(\"\\n\".join(details))\n+        self._last_detail_text = \"\\n\".join(details)\n+        if self.hud:\n+            self.hud.update_message(Panel(self._last_detail_text, title=node.round.name if node.round else (node.name or \"Node\"), border_style=\"green\" if node.round and node.round.replace_with_ramax else \"cyan\", padding=(1, 1)))\n \n     def _handle_command_selection(self, round_index: int, target: CommandTarget | None) -> None:\n         if target is None:\n             return\n         self._open_command_editor(round_index, target)\n \n+    def _on_node_selected(\n+        self, node: tree_utils.AlignmentNode, status: str | None = None\n+    ) -> None:\n+        \"\"\"Tree navigation callback that drives HUD updates.\"\"\"\n+        self._show_alignment_node(node, status=status)\n+        if self.hud:\n+            self.hud.update_node(node)\n+\n     def _open_command_editor(self, round_index: int, target: CommandTarget) -> None:\n         if target.kind == \"ramax-options\":\n             if round_index >= len(self.plan.rounds):"
      },
      {
        "sha": "1cc90b389b0aa8d2506ffafe3ab7d61b58823ad9",
        "filename": "pyproject.toml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/malabz/Cax/blob/0b4473799c13cc2679e5305f14268d2c2c523a92/pyproject.toml",
        "raw_url": "https://github.com/malabz/Cax/raw/0b4473799c13cc2679e5305f14268d2c2c523a92/pyproject.toml",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/pyproject.toml?ref=0b4473799c13cc2679e5305f14268d2c2c523a92",
        "patch": "@@ -4,7 +4,7 @@ build-backend = \"hatchling.build\"\n \n [project]\n name = \"cactus-ramax\"\n-version = \"0.3.0-dev\"\n+version = \"0.3.0\"\n description = \"Interactive tooling for mixing cactus and RaMAx workflows\"\n authors = [{name = \"Cactus-RaMAx Team\"}]\n readme = \"README.md\""
      },
      {
        "sha": "ece7fd013047428622b7a77d7afe8c02e4c4e5ef",
        "filename": "tests/test_planner_subtree_override.py",
        "status": "added",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/malabz/Cax/blob/0b4473799c13cc2679e5305f14268d2c2c523a92/tests%2Ftest_planner_subtree_override.py",
        "raw_url": "https://github.com/malabz/Cax/raw/0b4473799c13cc2679e5305f14268d2c2c523a92/tests%2Ftest_planner_subtree_override.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/tests%2Ftest_planner_subtree_override.py?ref=0b4473799c13cc2679e5305f14268d2c2c523a92",
        "patch": "@@ -0,0 +1,49 @@\n+from pathlib import Path\n+\n+from cax import parser, planner\n+\n+\n+def _build_plan(tmp_path: Path):\n+    text = Path(\"examples/cactus-prepare_example.txt\").read_text(encoding=\"utf-8\")\n+    plan = parser.parse_prepare_script(text)\n+\n+    # Build a compact Newick tree that includes every round root so ancestry can be resolved.\n+    tree_path = tmp_path / \"toy_tree.nwk\"\n+    tree_path.write_text(\"(((a,b)Anc2,c)mr,(d,e)Anc1)Anc0;\", encoding=\"utf-8\")\n+    plan.out_seq_file = str(tree_path)\n+    return plan\n+\n+\n+def test_descendant_cactus_runs_when_ancestor_ramax(tmp_path):\n+    plan = _build_plan(tmp_path)\n+\n+    # Mark the whole tree as RaMAx, then switch the mr subtree back to cactus to simulate user override.\n+    for round_entry in plan.rounds:\n+        round_entry.replace_with_ramax = True\n+    mr_round = next(r for r in plan.rounds if r.root == \"mr\")\n+    mr_round.replace_with_ramax = False\n+\n+    commands = planner.build_execution_plan(plan, base_dir=tmp_path)\n+\n+    mr_cmds = [cmd for cmd in commands if cmd.round_name == mr_round.name]\n+    assert mr_cmds, \"mr subtree should not be skipped just because an ancestor uses RaMAx\"\n+    assert {\"blast\", \"align\"}.issubset({cmd.category for cmd in mr_cmds})\n+\n+    anc0_round = next(r for r in plan.rounds if r.root == \"Anc0\")\n+    anc0_cmds = [cmd for cmd in commands if cmd.round_name == anc0_round.name]\n+    assert any(cmd.is_ramax for cmd in anc0_cmds), \"root round should still run with RaMAx\"\n+\n+\n+def test_descendant_ramax_skipped_when_ancestor_ramax(tmp_path):\n+    plan = _build_plan(tmp_path)\n+\n+    # When Anc0 uses RaMAx and child Anc1 also requests RaMAx, the child should be skipped to avoid duplication.\n+    anc0 = next(r for r in plan.rounds if r.root == \"Anc0\")\n+    anc1 = next(r for r in plan.rounds if r.root == \"Anc1\")\n+    anc0.replace_with_ramax = True\n+    anc1.replace_with_ramax = True\n+\n+    commands = planner.build_execution_plan(plan, base_dir=tmp_path)\n+\n+    anc1_cmds = [cmd for cmd in commands if cmd.round_name == anc1.name]\n+    assert not anc1_cmds, \"child RaMAx should be skipped when its ancestor already runs RaMAx\""
      },
      {
        "sha": "175011588c279747810a3bae8d9450f74abadc8e",
        "filename": "tests/test_ui_bulk_revert.py",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/malabz/Cax/blob/0b4473799c13cc2679e5305f14268d2c2c523a92/tests%2Ftest_ui_bulk_revert.py",
        "raw_url": "https://github.com/malabz/Cax/raw/0b4473799c13cc2679e5305f14268d2c2c523a92/tests%2Ftest_ui_bulk_revert.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/tests%2Ftest_ui_bulk_revert.py?ref=0b4473799c13cc2679e5305f14268d2c2c523a92",
        "patch": "@@ -0,0 +1,32 @@\n+from cax import tree_utils\n+from cax.ui import AsciiPhylo\n+from cax.models import Round\n+\n+\n+def _build_tree():\n+    # Build a minimal tree: root -> child\n+    root_round = Round(name=\"root\", root=\"Anc0\", target_hal=\"a.hal\", replace_with_ramax=True)\n+    child_round = Round(name=\"child\", root=\"Anc1\", target_hal=\"b.hal\", replace_with_ramax=True)\n+    root = tree_utils.AlignmentNode(name=\"Anc0\", children=[])\n+    child = tree_utils.AlignmentNode(name=\"Anc1\", children=[])\n+    root.children.append(child)\n+    child.parent = root\n+    root.round = root_round\n+    child.round = child_round\n+    return root, child\n+\n+\n+def test_bulk_revert_when_toggling_child():\n+    root, child = _build_tree()\n+    widget = AsciiPhylo(root)\n+    # Simulate a bulk RaMAx toggle on the subtree\n+    widget._bulk_root = root\n+    widget._bulk_state = True\n+\n+    reverted = widget._maybe_revert_bulk(child)\n+\n+    assert reverted is True\n+    assert root.round.replace_with_ramax is False\n+    assert child.round.replace_with_ramax is False\n+    assert widget._bulk_root is None\n+    assert widget._bulk_state is None"
      }
    ]
  }
}