{
  "cached_at": "2025-12-20T14:33:35.768278",
  "commit_sha": "9aed28083f894a9567cb5713be0a08db20afdcb2",
  "repo": "malabz/Cax",
  "data": {
    "sha": "9aed28083f894a9567cb5713be0a08db20afdcb2",
    "node_id": "C_kwDOPt61otoAKDlhZWQyODA4M2Y4OTRhOTU2N2NiNTcxM2JlMGEwOGRiMjBhZmRjYjI",
    "commit": {
      "author": {
        "name": "LoadStar822",
        "email": "992247533@qq.com",
        "date": "2025-09-18T15:14:26Z"
      },
      "committer": {
        "name": "LoadStar822",
        "email": "992247533@qq.com",
        "date": "2025-09-18T15:14:26Z"
      },
      "message": "feat: Add core functionality for CAX workflow integration",
      "tree": {
        "sha": "86ad90cc5d873719e331803c68b76a75d7eb58e3",
        "url": "https://api.github.com/repos/malabz/Cax/git/trees/86ad90cc5d873719e331803c68b76a75d7eb58e3"
      },
      "url": "https://api.github.com/repos/malabz/Cax/git/commits/9aed28083f894a9567cb5713be0a08db20afdcb2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null,
        "verified_at": null
      }
    },
    "url": "https://api.github.com/repos/malabz/Cax/commits/9aed28083f894a9567cb5713be0a08db20afdcb2",
    "html_url": "https://github.com/malabz/Cax/commit/9aed28083f894a9567cb5713be0a08db20afdcb2",
    "comments_url": "https://api.github.com/repos/malabz/Cax/commits/9aed28083f894a9567cb5713be0a08db20afdcb2/comments",
    "author": {
      "login": "LoadStar822",
      "id": 56856603,
      "node_id": "MDQ6VXNlcjU2ODU2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/56856603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LoadStar822",
      "html_url": "https://github.com/LoadStar822",
      "followers_url": "https://api.github.com/users/LoadStar822/followers",
      "following_url": "https://api.github.com/users/LoadStar822/following{/other_user}",
      "gists_url": "https://api.github.com/users/LoadStar822/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LoadStar822/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LoadStar822/subscriptions",
      "organizations_url": "https://api.github.com/users/LoadStar822/orgs",
      "repos_url": "https://api.github.com/users/LoadStar822/repos",
      "events_url": "https://api.github.com/users/LoadStar822/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LoadStar822/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "committer": {
      "login": "LoadStar822",
      "id": 56856603,
      "node_id": "MDQ6VXNlcjU2ODU2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/56856603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LoadStar822",
      "html_url": "https://github.com/LoadStar822",
      "followers_url": "https://api.github.com/users/LoadStar822/followers",
      "following_url": "https://api.github.com/users/LoadStar822/following{/other_user}",
      "gists_url": "https://api.github.com/users/LoadStar822/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LoadStar822/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LoadStar822/subscriptions",
      "organizations_url": "https://api.github.com/users/LoadStar822/orgs",
      "repos_url": "https://api.github.com/users/LoadStar822/repos",
      "events_url": "https://api.github.com/users/LoadStar822/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LoadStar822/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "parents": [],
    "stats": {
      "total": 1458,
      "additions": 1458,
      "deletions": 0
    },
    "files": [
      {
        "sha": "74d354cee6b3289f0f98fac582c093e94d2993c9",
        "filename": ".gitignore",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/.gitignore",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/.gitignore",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/.gitignore?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,2 @@\n+cax/__pycache__/\n+steps-output/"
      },
      {
        "sha": "bfb768ae9fce9f14d161f03e36fd3840155fc316",
        "filename": "cax/__init__.py",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2F__init__.py",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2F__init__.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2F__init__.py?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,17 @@\n+\"\"\"Cactus-RaMAx toolkit package.\"\"\"\n+from . import config, parser, planner, render, ui\n+from .models import Plan, PrepareHeader, Round, Step\n+from .runner import PlanRunner\n+\n+__all__ = [\n+    \"config\",\n+    \"parser\",\n+    \"planner\",\n+    \"render\",\n+    \"ui\",\n+    \"Plan\",\n+    \"PrepareHeader\",\n+    \"Round\",\n+    \"Step\",\n+    \"PlanRunner\",\n+]"
      },
      {
        "sha": "446f414c60ddfef4a18595dbaa587ffef3d404d0",
        "filename": "cax/cli.py",
        "status": "added",
        "additions": 175,
        "deletions": 0,
        "changes": 175,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Fcli.py",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Fcli.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fcli.py?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,175 @@\n+\"\"\"Typer-powered command line interface for the CAX toolkit.\"\"\"\n+from __future__ import annotations\n+\n+from pathlib import Path\n+import shlex\n+import subprocess\n+from typing import Iterable, Optional\n+\n+\n+import typer\n+from rich import print\n+\n+from . import config, parser, planner, render, ui as ui_module\n+from .models import Plan\n+from .runner import PlanRunner\n+\n+FallbackValues = {'cactus', 'abort'}\n+\n+app = typer.Typer(help=\"Cactus-RaMAx helper tools\")\n+\n+\n+def _fallback_value(value: str) -> str:\n+    normalized = value.lower()\n+    if normalized not in FallbackValues:\n+        raise typer.BadParameter(f\"fallback must be one of {sorted(FallbackValues)}\")\n+    return normalized\n+\n+\n+def _load_prepare_text(prepare_args: Optional[str], from_file: Optional[Path]) -> str:\n+    if prepare_args:\n+        cmd = [\"cactus-prepare\", *shlex.split(prepare_args)]\n+        typer.echo(f\"[cax] running: {' '.join(cmd)}\")\n+        result = subprocess.run(cmd, check=False, capture_output=True, text=True)\n+        if result.returncode != 0:\n+            typer.echo(result.stdout)\n+            typer.echo(result.stderr, err=True)\n+            raise typer.Exit(code=result.returncode)\n+        output = result.stdout or \"\"\n+        Path(\"steps-output\").mkdir(exist_ok=True, parents=True)\n+        Path(\"steps-output/cax_prepare_debug.txt\").write_text(output, encoding=\"utf-8\")\n+        return output\n+    if from_file:\n+        return Path(from_file).read_text(encoding=\"utf-8\")\n+    typer.echo(\"Either --prepare-args or --from-file must be provided.\", err=True)\n+    raise typer.Exit(code=1)\n+\n+\n+def _update_round_replacements(plan: Plan, replace_rounds: Iterable[str]) -> None:\n+    selected = {name.strip() for name in replace_rounds if name.strip()}\n+    if not selected:\n+        return\n+    for round_entry in plan.rounds:\n+        base_name = round_entry.name\n+        plain_name = base_name.split(\" (\")[0]\n+        if base_name in selected or plain_name in selected:\n+            round_entry.replace_with_ramax = True\n+\n+\n+@app.command()\n+def ui(\n+    prepare_args: Optional[str] = typer.Option(None, help=\"Arguments passed through to cactus-prepare\"),\n+    from_file: Optional[Path] = typer.Option(None, help=\"Parse prepare output from an existing file\"),\n+    run_after: bool = typer.Option(False, help=\"Run the plan after exiting the UI\"),\n+) -> None:\n+    \"\"\"Launch the interactive Textual UI for plan editing.\"\"\"\n+\n+    text = _load_prepare_text(prepare_args, from_file)\n+    plan = parser.parse_prepare_script(text)\n+    result = ui_module.launch(plan)\n+    plan = result.plan\n+    if result.action == \"run\" or run_after:\n+        runner = PlanRunner(plan)\n+        runner.run()\n+    else:\n+        print(render.plan_overview(plan))\n+\n+\n+@app.command()\n+def plan(\n+    output: Path = typer.Option(..., help=\"Destination YAML file for the plan\"),\n+    prepare_args: Optional[str] = typer.Option(None, help=\"Arguments to pass to cactus-prepare\"),\n+    from_file: Optional[Path] = typer.Option(None, help=\"Read cactus-prepare output from file\"),\n+    replace_rounds: Optional[str] = typer.Option(None, help=\"Comma-separated round names to replace with RaMAx\"),\n+    fallback: str = typer.Option(\"cactus\", help=\"Fallback policy when RaMAx fails\", show_default=True),\n+    dry_run: bool = typer.Option(False, help=\"Mark the plan as dry-run\"),\n+    run_script: Optional[Path] = typer.Option(None, help=\"Optional run.sh export path\"),\n+) -> None:\n+    \"\"\"Generate a YAML plan without executing it.\"\"\"\n+\n+    text = _load_prepare_text(prepare_args, from_file)\n+    plan_obj = parser.parse_prepare_script(text)\n+    plan_obj.fallback_policy = _fallback_value(fallback)  # type: ignore[assignment]\n+    plan_obj.dry_run = dry_run\n+    if replace_rounds:\n+        _update_round_replacements(plan_obj, replace_rounds.split(\",\"))\n+    config.save_plan(plan_obj, output)\n+    typer.echo(f\"Plan saved to {output}\")\n+    if run_script:\n+        commands = planner.build_execution_plan(plan_obj)\n+        run_text = render.render_run_script(plan_obj, commands)\n+        run_script.parent.mkdir(parents=True, exist_ok=True)\n+        run_script.write_text(run_text, encoding=\"utf-8\")\n+        typer.echo(f\"Run script written to {run_script}\")\n+\n+\n+@app.command()\n+def run(\n+    config_path: Path = typer.Option(..., help=\"Path to a previously saved plan YAML\"),\n+    dry_run: Optional[bool] = typer.Option(None, help=\"Override the plan's dry-run flag\"),\n+    run_script: Optional[Path] = typer.Option(None, help=\"Export a run.sh alongside execution\"),\n+    quiet: bool = typer.Option(False, help=\"Silence live command output\"),\n+) -> None:\n+    \"\"\"Execute a saved plan.\"\"\"\n+\n+    plan_obj = config.load_plan(config_path)\n+    if dry_run is not None:\n+        plan_obj.dry_run = dry_run\n+    commands = planner.build_execution_plan(plan_obj)\n+    if run_script:\n+        run_text = render.render_run_script(plan_obj, commands)\n+        run_script.parent.mkdir(parents=True, exist_ok=True)\n+        run_script.write_text(run_text, encoding=\"utf-8\")\n+        typer.echo(f\"Run script written to {run_script}\")\n+    runner = PlanRunner(plan_obj, mirror_stdout=not quiet)\n+    runner.run()\n+\n+\n+@app.command()\n+def go(\n+    seq_file: Path = typer.Argument(..., help=\"Input sequence file passed to cactus-prepare\"),\n+    out_dir: Path = typer.Option(..., help=\"--outDir value for cactus-prepare\"),\n+    out_seq_file: Path = typer.Option(..., help=\"--outSeqFile value\"),\n+    out_hal: Path = typer.Option(..., help=\"--outHal value\"),\n+    job_store: str = typer.Option(..., help=\"--jobStore value\"),\n+    replace_rounds: Optional[str] = typer.Option(None, help=\"Comma-separated round names to replace\"),\n+    fallback: str = typer.Option(\"cactus\", help=\"Fallback policy [cactus|abort]\"),\n+    dry_run: bool = typer.Option(False, help=\"Enable dry-run mode\"),\n+    ramax_opt: Optional[list[str]] = typer.Option(None, help=\"Additional --ramax-opt flags\"),\n+    run_script: Optional[Path] = typer.Option(None, help=\"Export run.sh before executing\"),\n+    quiet: bool = typer.Option(False, help=\"Silence live command output\"),\n+) -> None:\n+    \"\"\"Shortcut: prepare, configure replacements, and execute immediately.\"\"\"\n+\n+    prepare_tokens = [\n+        str(seq_file),\n+        \"--outDir\",\n+        str(out_dir),\n+        \"--outSeqFile\",\n+        str(out_seq_file),\n+        \"--outHal\",\n+        str(out_hal),\n+        \"--jobStore\",\n+        job_store,\n+    ]\n+    prepare_args = shlex.join(prepare_tokens)\n+    script_text = _load_prepare_text(prepare_args, None)\n+    plan_obj = parser.parse_prepare_script(script_text)\n+    plan_obj.fallback_policy = _fallback_value(fallback)  # type: ignore[assignment]\n+    plan_obj.dry_run = dry_run\n+    if ramax_opt:\n+        plan_obj.global_ramax_opts = list(ramax_opt)\n+    if replace_rounds:\n+        _update_round_replacements(plan_obj, replace_rounds.split(\",\"))\n+    commands = planner.build_execution_plan(plan_obj)\n+    if run_script:\n+        run_text = render.render_run_script(plan_obj, commands)\n+        run_script.parent.mkdir(parents=True, exist_ok=True)\n+        run_script.write_text(run_text, encoding=\"utf-8\")\n+        typer.echo(f\"Run script written to {run_script}\")\n+    runner = PlanRunner(plan_obj, mirror_stdout=not quiet)\n+    runner.run()\n+\n+\n+if __name__ == \"__main__\":\n+    app()"
      },
      {
        "sha": "0a307270bd56323db8e80197bfb1e0523bf0b021",
        "filename": "cax/config.py",
        "status": "added",
        "additions": 50,
        "deletions": 0,
        "changes": 50,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Fconfig.py",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Fconfig.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fconfig.py?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,50 @@\n+\"\"\"YAML configuration helpers for persisting CAX plans.\"\"\"\n+from __future__ import annotations\n+\n+from pathlib import Path\n+from typing import Any\n+\n+import yaml\n+\n+from .models import Plan\n+\n+\n+def plan_to_dict(plan: Plan) -> dict[str, Any]:\n+    \"\"\"Convert a :class:`Plan` into a YAML-friendly dictionary.\"\"\"\n+\n+    return plan.model_dump(mode=\"json\", exclude_none=True)\n+\n+\n+def save_plan(plan: Plan, path: Path) -> None:\n+    \"\"\"Persist *plan* to *path* as YAML.\"\"\"\n+\n+    path = Path(path)\n+    path.parent.mkdir(parents=True, exist_ok=True)\n+    with path.open(\"w\", encoding=\"utf-8\") as handle:\n+        yaml.safe_dump(plan_to_dict(plan), handle, sort_keys=False)\n+\n+\n+def load_plan(path: Path) -> Plan:\n+    \"\"\"Load a :class:`Plan` from YAML stored at *path*.\"\"\"\n+\n+    path = Path(path)\n+    with path.open(\"r\", encoding=\"utf-8\") as handle:\n+        data = yaml.safe_load(handle)\n+    if data is None:\n+        raise ValueError(f\"Empty YAML in {path}\")\n+    return Plan.model_validate(data)\n+\n+\n+def plan_from_yaml(yaml_text: str) -> Plan:\n+    \"\"\"Load a plan from a YAML string payload.\"\"\"\n+\n+    data = yaml.safe_load(yaml_text)\n+    if data is None:\n+        raise ValueError(\"Empty YAML payload\")\n+    return Plan.model_validate(data)\n+\n+\n+def plan_to_yaml(plan: Plan) -> str:\n+    \"\"\"Serialize *plan* to a YAML string.\"\"\"\n+\n+    return yaml.safe_dump(plan_to_dict(plan), sort_keys=False)"
      },
      {
        "sha": "3bda211639c2532b0712af2b4a5d4a32ff927b62",
        "filename": "cax/detectors.py",
        "status": "added",
        "additions": 86,
        "deletions": 0,
        "changes": 86,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Fdetectors.py",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Fdetectors.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fdetectors.py?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,86 @@\n+\"\"\"Helpers for detecting environment capabilities relevant to CAX.\"\"\"\n+from __future__ import annotations\n+\n+import platform\n+import shutil\n+import subprocess\n+from dataclasses import dataclass\n+from typing import Optional\n+\n+import psutil\n+\n+\n+@dataclass\n+class ExecutableInfo:\n+    name: str\n+    path: Optional[str]\n+    version: Optional[str]\n+\n+\n+def which(executable: str) -> Optional[str]:\n+    \"\"\"Return the absolute path of *executable* if found on PATH.\"\"\"\n+\n+    return shutil.which(executable)\n+\n+\n+def executable_info(executable: str, version_args: list[str] | None = None) -> ExecutableInfo:\n+    path = which(executable)\n+    version = None\n+    if path and version_args is not None:\n+        try:\n+            result = subprocess.run([path, *version_args], check=False, capture_output=True, text=True)\n+            version = result.stdout.strip() or result.stderr.strip() or None\n+        except OSError:\n+            version = None\n+    return ExecutableInfo(name=executable, path=path, version=version)\n+\n+\n+def detect_gpu_summary() -> Optional[str]:\n+    \"\"\"Return a short GPU summary using ``nvidia-smi`` if available.\"\"\"\n+\n+    nvidia_smi = which(\"nvidia-smi\")\n+    if not nvidia_smi:\n+        return None\n+    try:\n+        result = subprocess.run(\n+            [\n+                nvidia_smi,\n+                \"--query-gpu=name,memory.total,memory.used,driver_version\",\n+                \"--format=csv,noheader\",\n+            ],\n+            check=False,\n+            capture_output=True,\n+            text=True,\n+        )\n+    except OSError:\n+        return None\n+    if result.returncode != 0:\n+        return None\n+    return result.stdout.strip() or None\n+\n+\n+def system_resources() -> dict[str, str]:\n+    \"\"\"Collect lightweight resource metrics to display in the UI.\"\"\"\n+\n+    virtual = psutil.virtual_memory()\n+    disk = psutil.disk_usage(\".\")\n+    return {\n+        \"platform\": platform.platform(),\n+        \"cpu_count\": str(psutil.cpu_count(logical=True) or 0),\n+        \"memory_gb\": f\"{virtual.total / 1e9:.1f}\",\n+        \"disk_free_gb\": f\"{disk.free / 1e9:.1f}\",\n+    }\n+\n+\n+def environment_summary() -> dict[str, Optional[str]]:\n+    \"\"\"Return a dictionary summarising key binaries and hardware.\"\"\"\n+\n+    ramax = executable_info(\"RaMAx\", [\"--version\"])\n+    cactus_prepare = executable_info(\"cactus-prepare\", [\"--version\"])\n+    return {\n+        \"ramax_path\": ramax.path,\n+        \"ramax_version\": ramax.version,\n+        \"cactus_prepare_path\": cactus_prepare.path,\n+        \"cactus_prepare_version\": cactus_prepare.version,\n+        \"gpu\": detect_gpu_summary(),\n+    }"
      },
      {
        "sha": "84e827a29afbbbc8a1683226d8c6e290b7f21603",
        "filename": "cax/models.py",
        "status": "added",
        "additions": 103,
        "deletions": 0,
        "changes": 103,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Fmodels.py",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Fmodels.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fmodels.py?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,103 @@\n+\"\"\"Core data models for the Cactus-RaMAx workflow.\"\"\"\n+from __future__ import annotations\n+\n+from datetime import datetime\n+from typing import Literal, Optional\n+\n+from pydantic import BaseModel, Field, field_validator, model_validator\n+\n+\n+StepKind = Literal[\n+    \"preprocess\",\n+    \"blast\",\n+    \"align\",\n+    \"hal2fasta\",\n+    \"halmerge\",\n+    \"ramax\",\n+    \"other\",\n+]\n+\n+\n+class PrepareHeader(BaseModel):\n+    \"\"\"Metadata captured from the cactus-prepare output header.\"\"\"\n+\n+    generated_by: str\n+    date: datetime\n+    cactus_commit: Optional[str] = None\n+\n+    @field_validator(\"generated_by\")\n+    @classmethod\n+    def _strip_generated_by(cls, value: str) -> str:\n+        return value.strip()\n+\n+\n+class Step(BaseModel):\n+    \"\"\"Represents a single command step from the cactus/RaMAx workflow.\"\"\"\n+\n+    raw: str\n+    kind: StepKind\n+    jobstore: Optional[str] = None\n+    out_files: list[str] = Field(default_factory=list)\n+    root: Optional[str] = None\n+    log_file: Optional[str] = None\n+    label: Optional[str] = None\n+\n+    @field_validator(\"raw\")\n+    @classmethod\n+    def _ensure_raw(cls, value: str) -> str:\n+        return value.strip()\n+\n+    def short_label(self) -> str:\n+        \"\"\"Return a concise label suitable for log names or UI display.\"\"\"\n+\n+        if self.label:\n+            return self.label\n+        if self.kind in {\"blast\", \"align\", \"ramax\"} and self.root:\n+            return f\"{self.kind}-{self.root}\"\n+        return self.raw.split()[0] if self.raw else \"step\"\n+\n+\n+class Round(BaseModel):\n+    \"\"\"Encapsulates the data for a logical cactus alignment round.\"\"\"\n+\n+    name: str\n+    root: str\n+    target_hal: str\n+    blast_step: Optional[Step] = None\n+    align_step: Optional[Step] = None\n+    hal2fasta_steps: list[Step] = Field(default_factory=list)\n+    replace_with_ramax: bool = False\n+    workdir: Optional[str] = None\n+    ramax_opts: list[str] = Field(default_factory=list)\n+\n+    @model_validator(mode=\"after\")\n+    def _validate_round(self) -> \"Round\":\n+        if not self.target_hal:\n+            raise ValueError(\"Round.target_hal cannot be empty\")\n+        if (self.blast_step is None or self.align_step is None) and not self.replace_with_ramax:\n+            raise ValueError(\"blast_step and align_step required when not replacing with RaMAx\")\n+        return self\n+\n+\n+FallbackPolicy = Literal[\"cactus\", \"abort\"]\n+\n+\n+class Plan(BaseModel):\n+    \"\"\"Full execution plan assembled from the parsed cactus-prepare script.\"\"\"\n+\n+    header: PrepareHeader\n+    preprocess: list[Step] = Field(default_factory=list)\n+    rounds: list[Round] = Field(default_factory=list)\n+    hal_merges: list[Step] = Field(default_factory=list)\n+    out_seq_file: str\n+    out_dir: Optional[str] = None\n+    dry_run: bool = False\n+    fallback_policy: FallbackPolicy = \"cactus\"\n+    global_ramax_opts: list[str] = Field(default_factory=list)\n+\n+    @field_validator(\"out_seq_file\")\n+    @classmethod\n+    def _validate_out_seq_file(cls, value: str) -> str:\n+        if not value:\n+            raise ValueError(\"out_seq_file cannot be empty\")\n+        return value"
      },
      {
        "sha": "482b8c9d1b61c9d67e062bd5bfb470e669047930",
        "filename": "cax/parser.py",
        "status": "added",
        "additions": 342,
        "deletions": 0,
        "changes": 342,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Fparser.py",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Fparser.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fparser.py?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,342 @@\n+\"\"\"Parsing utilities that turn cactus-prepare output into structured plans.\"\"\"\n+from __future__ import annotations\n+\n+from datetime import datetime\n+import re\n+import shlex\n+from typing import Iterable, List, Optional\n+\n+from .models import Plan, PrepareHeader, Round, Step\n+\n+\n+HEADER_GENERATED_RE = re.compile(r\"^##\\s*generated\\s+by\\s*:\\s*(?P<value>.+)$\", re.IGNORECASE)\n+HEADER_DATE_RE = re.compile(r\"^##\\s*date\\s*:\\s*(?P<value>.+)$\", re.IGNORECASE)\n+HEADER_COMMIT_RE = re.compile(r\"^##\\s*cactus\\s+commit\\s*:\\s*(?P<value>.+)$\", re.IGNORECASE)\n+ROUND_HEADER_RE = re.compile(r\"^###\\s*Round\\s+(?P<index>\\d+)\\s*$\", re.IGNORECASE)\n+SECTION_PREPROC_RE = re.compile(r\"^##\\s*Preprocessor\", re.IGNORECASE)\n+SECTION_ALIGNMENT_RE = re.compile(r\"^##\\s*Alignment\", re.IGNORECASE)\n+SECTION_HALMERGE_RE = re.compile(r\"^##\\s*HAL\\s+merg\", re.IGNORECASE)\n+ANSI_ESCAPE_RE = re.compile(r\"\\x1b\\[[0-?]*[ -/]*[@-~]\")\n+\n+\n+def _strip_ansi(value: str) -> str:\n+    \"\"\"Remove ANSI escape sequences so parsing stays robust.\"\"\"\n+\n+    return ANSI_ESCAPE_RE.sub(\"\", value)\n+\n+\n+class ParseError(RuntimeError):\n+    \"\"\"Raised when the prepare script cannot be interpreted.\"\"\"\n+\n+\n+def parse_prepare_script(text: str) -> Plan:\n+    \"\"\"Parse *text* generated by ``cactus-prepare`` into a :class:`Plan`.\"\"\"\n+\n+    lines = [_strip_ansi(line) for line in text.splitlines()]\n+    header = _parse_header(lines)\n+    preprocess_lines, alignment_lines, halmerge_lines = _split_sections(lines)\n+\n+    preprocess_steps = _parse_command_lines(preprocess_lines, expected_kind=\"preprocess\")\n+    hal_merge_steps = _parse_command_lines(halmerge_lines, default_kind=\"halmerge\")\n+    rounds = _parse_rounds(alignment_lines)\n+\n+    prepare_args = _extract_prepare_args(header.generated_by)\n+\n+    return Plan(\n+        header=header,\n+        preprocess=preprocess_steps,\n+        rounds=rounds,\n+        hal_merges=hal_merge_steps,\n+        out_seq_file=prepare_args[\"out_seq_file\"],\n+        out_dir=prepare_args.get(\"out_dir\"),\n+    )\n+\n+\n+def _parse_header(lines: list[str]) -> PrepareHeader:\n+    generated_by: Optional[str] = None\n+    date_value: Optional[str] = None\n+    commit_value: Optional[str] = None\n+\n+    for line in lines:\n+        if generated_by is None:\n+            match = HEADER_GENERATED_RE.match(line.strip())\n+            if match:\n+                generated_by = match.group(\"value\").strip()\n+                continue\n+        if date_value is None:\n+            match = HEADER_DATE_RE.match(line.strip())\n+            if match:\n+                date_value = match.group(\"value\").strip()\n+                continue\n+        if commit_value is None:\n+            match = HEADER_COMMIT_RE.match(line.strip())\n+            if match:\n+                commit_value = match.group(\"value\").strip()\n+                continue\n+        if generated_by and date_value and commit_value is not None:\n+            break\n+\n+    if generated_by is None:\n+        raise ParseError(\"Missing '## generated by' header\")\n+    if date_value is None:\n+        raise ParseError(\"Missing '## date' header\")\n+\n+    try:\n+        parsed_date = datetime.fromisoformat(date_value)\n+    except ValueError as exc:  # pragma: no cover - bad inputs raise clear error\n+        raise ParseError(f\"Cannot parse header date '{date_value}': {exc}\") from exc\n+\n+    commit_clean = commit_value if commit_value and commit_value.lower() != \"none\" else None\n+\n+    return PrepareHeader(\n+        generated_by=generated_by,\n+        date=parsed_date,\n+        cactus_commit=commit_clean,\n+    )\n+\n+\n+def _split_sections(lines: list[str]) -> tuple[list[str], list[str], list[str]]:\n+    current: Optional[str] = None\n+    preprocess: list[str] = []\n+    alignment: list[str] = []\n+    halmerge: list[str] = []\n+\n+    for line in lines:\n+        stripped = line.strip()\n+        if SECTION_PREPROC_RE.match(stripped):\n+            current = \"preprocess\"\n+            continue\n+        if SECTION_ALIGNMENT_RE.match(stripped):\n+            current = \"alignment\"\n+            continue\n+        if SECTION_HALMERGE_RE.match(stripped):\n+            current = \"halmerge\"\n+            continue\n+        if stripped.startswith(\"##\") and not stripped.startswith(\"###\"):\n+            continue\n+        if current == \"preprocess\":\n+            preprocess.append(line)\n+        elif current == \"alignment\":\n+            alignment.append(line)\n+        elif current == \"halmerge\":\n+            halmerge.append(line)\n+\n+    return preprocess, alignment, halmerge\n+\n+\n+def _parse_command_lines(\n+    lines: Iterable[str],\n+    expected_kind: Optional[str] = None,\n+    default_kind: Optional[str] = None,\n+) -> list[Step]:\n+    steps: list[Step] = []\n+    for line in lines:\n+        step = _parse_line_to_step(line, expected_kind=expected_kind, default_kind=default_kind)\n+        if step:\n+            steps.append(step)\n+    return steps\n+\n+\n+def _parse_rounds(alignment_lines: list[str]) -> list[Round]:\n+    rounds: list[Round] = []\n+    heading = None\n+    pending_steps: list[tuple[str | None, Step]] = []\n+\n+    for line in alignment_lines:\n+        stripped = line.strip()\n+        if not stripped:\n+            continue\n+        match = ROUND_HEADER_RE.match(stripped)\n+        if match:\n+            heading = f\"Round {match.group('index')}\"\n+            continue\n+        step = _parse_line_to_step(line)\n+        if step:\n+            pending_steps.append((heading, step))\n+\n+    name_counts: dict[str, int] = {}\n+    idx = 0\n+    while idx < len(pending_steps):\n+        heading_label, step = pending_steps[idx]\n+        if step.kind != \"blast\":\n+            idx += 1\n+            continue\n+        blast_step = step\n+        idx += 1\n+        if idx >= len(pending_steps):\n+            raise ParseError(\"Missing cactus-align after cactus-blast\")\n+        align_heading, align_step = pending_steps[idx]\n+        if align_step.kind != \"align\":\n+            raise ParseError(\n+                f\"Expected cactus-align after cactus-blast, got: {align_step.raw}\"\n+            )\n+        idx += 1\n+        hal_steps: list[Step] = []\n+        while idx < len(pending_steps) and pending_steps[idx][1].kind == \"hal2fasta\":\n+            hal_steps.append(pending_steps[idx][1])\n+            idx += 1\n+\n+        base_name = heading_label or align_heading or blast_step.root or f\"Round {len(rounds)}\"\n+        if base_name.startswith(\"Round\"):\n+            name_counts.setdefault(base_name, 0)\n+            suffix_index = name_counts[base_name]\n+            name_counts[base_name] += 1\n+            if suffix_index == 0:\n+                round_name = base_name\n+            else:\n+                root_label = align_step.root or blast_step.root or f\"part{suffix_index}\"\n+                round_name = f\"{base_name} ({root_label})\"\n+        else:\n+            round_name = base_name\n+\n+        target_hal = _pick_align_hal(align_step)\n+        rounds.append(\n+            Round(\n+                name=round_name,\n+                root=align_step.root or blast_step.root or round_name,\n+                target_hal=target_hal,\n+                blast_step=blast_step,\n+                align_step=align_step,\n+                hal2fasta_steps=hal_steps,\n+            )\n+        )\n+    return rounds\n+\n+\n+\n+\n+\n+def _pick_align_hal(align_step: Step) -> str:\n+    for outfile in align_step.out_files:\n+        if outfile.endswith(\".hal\"):\n+            return outfile\n+    tokens = shlex.split(align_step.raw)\n+    for token in reversed(tokens):\n+        if token.endswith(\".hal\"):\n+            return token\n+    raise ParseError(f\"Cannot determine target HAL from align command: {align_step.raw}\")\n+\n+\n+def _parse_line_to_step(\n+    line: str,\n+    expected_kind: Optional[str] = None,\n+    default_kind: Optional[str] = None,\n+) -> Optional[Step]:\n+    stripped = line.strip()\n+    if not stripped:\n+        return None\n+    if stripped.startswith(\"##\"):\n+        return None\n+    tokens = _safe_split(stripped)\n+    if not tokens:\n+        return None\n+    kind = _classify_kind(tokens[0], default_kind)\n+    if expected_kind and kind != expected_kind:\n+        kind = expected_kind\n+    jobstore = _extract_jobstore(tokens)\n+    root = _extract_root(tokens)\n+    log_file = _extract_log_file(tokens)\n+    out_files = _extract_outputs(tokens, kind)\n+    return Step(\n+        raw=stripped,\n+        kind=kind,\n+        jobstore=jobstore,\n+        out_files=out_files,\n+        root=root,\n+        log_file=log_file,\n+    )\n+\n+\n+def _safe_split(command: str) -> List[str]:\n+    try:\n+        return shlex.split(command)\n+    except ValueError as exc:\n+        raise ParseError(f\"Cannot parse command: {command}\\n{exc}\") from exc\n+\n+\n+def _classify_kind(first_token: str, default_kind: Optional[str]) -> str:\n+    mapping = {\n+        \"cactus-preprocess\": \"preprocess\",\n+        \"cactus-blast\": \"blast\",\n+        \"cactus-align\": \"align\",\n+        \"hal2fasta\": \"hal2fasta\",\n+        \"halAppendSubtree\": \"halmerge\",\n+        \"RaMAx\": \"ramax\",\n+    }\n+    kind = mapping.get(first_token)\n+    if kind:\n+        return kind\n+    if default_kind:\n+        return default_kind\n+    return \"other\"\n+\n+\n+def _extract_jobstore(tokens: list[str]) -> Optional[str]:\n+    for idx, tok in enumerate(tokens):\n+        if tok.startswith(\"jobstore/\"):\n+            return tok\n+        if tok in {\"--jobStore\", \"--jobstore\"} and idx + 1 < len(tokens):\n+            return tokens[idx + 1]\n+    return None\n+\n+\n+def _extract_root(tokens: list[str]) -> Optional[str]:\n+    for idx, tok in enumerate(tokens):\n+        if tok == \"--root\" and idx + 1 < len(tokens):\n+            return tokens[idx + 1]\n+    return None\n+\n+\n+def _extract_log_file(tokens: list[str]) -> Optional[str]:\n+    for idx, tok in enumerate(tokens):\n+        if tok in {\"--logFile\", \"--logfile\"} and idx + 1 < len(tokens):\n+            return tokens[idx + 1]\n+    return None\n+\n+\n+def _extract_outputs(tokens: list[str], kind: str) -> list[str]:\n+    outputs: list[str] = []\n+    def _maybe_add(token: str) -> None:\n+        if any(token.endswith(suffix) for suffix in (\".paf\", \".hal\", \".fa\", \".fa.gz\", \".fasta\", \".txt\")):\n+            outputs.append(token)\n+\n+    if kind == \"blast\":\n+        for token in tokens:\n+            if token.endswith(\".paf\"):\n+                outputs.append(token)\n+    elif kind in {\"align\", \"ramax\"}:\n+        for token in tokens:\n+            if token.endswith(\".hal\"):\n+                outputs.append(token)\n+    elif kind == \"hal2fasta\":\n+        for idx, token in enumerate(tokens):\n+            if token in {\">\", \">>\"} and idx + 1 < len(tokens):\n+                outputs.append(tokens[idx + 1])\n+            elif token.endswith((\".fa\", \".fa.gz\", \".fasta\")):\n+                outputs.append(token)\n+    elif kind == \"halmerge\":\n+        for token in tokens:\n+            if token.endswith(\".hal\"):\n+                outputs.append(token)\n+    else:\n+        for token in tokens:\n+            _maybe_add(token)\n+    return outputs\n+\n+\n+def _extract_prepare_args(command: str) -> dict[str, str]:\n+    tokens = _safe_split(command)\n+    results: dict[str, str] = {}\n+    flag_to_key = {\"--outSeqFile\": \"out_seq_file\", \"--outDir\": \"out_dir\", \"--outHal\": \"out_hal\"}\n+    idx = 0\n+    while idx < len(tokens):\n+        token = tokens[idx]\n+        if token in flag_to_key and idx + 1 < len(tokens):\n+            results[flag_to_key[token]] = tokens[idx + 1]\n+            idx += 2\n+            continue\n+        idx += 1\n+    if \"out_seq_file\" not in results:\n+        raise ParseError(\"Unable to extract --outSeqFile from cactus-prepare command\")\n+    return results\n+"
      },
      {
        "sha": "c1a0d3b3ce5b08c26a30f3bf2235539c4561a205",
        "filename": "cax/planner.py",
        "status": "added",
        "additions": 218,
        "deletions": 0,
        "changes": 218,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Fplanner.py",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Fplanner.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fplanner.py?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,218 @@\n+\"\"\"Translate plans into executable command sequences.\"\"\"\n+from __future__ import annotations\n+\n+from dataclasses import dataclass, field\n+from pathlib import Path\n+import shlex\n+from typing import Iterable, List, Optional\n+\n+from .models import Plan, Round, Step\n+\n+\n+@dataclass\n+class PlannedCommand:\n+    \"\"\"Concrete command to be executed as part of a plan.\"\"\"\n+\n+    command: List[str]\n+    category: str\n+    display_name: str\n+    log_path: Optional[Path] = None\n+    round_name: Optional[str] = None\n+    step: Optional[Step] = None\n+    is_ramax: bool = False\n+    fallback_steps: list[Step] = field(default_factory=list)\n+    workdir: Optional[Path] = None\n+\n+    def shell_preview(self) -> str:\n+        \"\"\"Return a shell-friendly preview of the command.\"\"\"\n+\n+        return shlex.join(self.command)\n+\n+\n+def build_execution_plan(plan: Plan, base_dir: Optional[Path] = None) -> list[PlannedCommand]:\n+    \"\"\"Materialise the full list of commands that should be executed.\"\"\"\n+\n+    base_dir = base_dir or Path.cwd()\n+    commands: list[PlannedCommand] = []\n+\n+    for step in plan.preprocess:\n+        commands.append(_from_step(step, category=\"preprocess\", base_dir=base_dir))\n+\n+    for round_entry in plan.rounds:\n+        commands.extend(_round_commands(plan, round_entry, base_dir))\n+\n+    for step in plan.hal_merges:\n+        commands.append(_from_step(step, category=\"halmerge\", base_dir=base_dir))\n+\n+    return commands\n+\n+\n+def _round_commands(plan: Plan, round_entry: Round, base_dir: Path) -> list[PlannedCommand]:\n+    cmds: list[PlannedCommand] = []\n+    round_name = round_entry.name\n+\n+    if round_entry.replace_with_ramax:\n+        cmds.append(\n+            _ramax_command(plan, round_entry, base_dir, fallback_policy=plan.fallback_policy)\n+        )\n+    else:\n+        if round_entry.blast_step:\n+            cmds.append(\n+                _from_step(\n+                    round_entry.blast_step,\n+                    category=\"blast\",\n+                    base_dir=base_dir,\n+                    round_name=round_name,\n+                )\n+            )\n+        if round_entry.align_step:\n+            cmds.append(\n+                _from_step(\n+                    round_entry.align_step,\n+                    category=\"align\",\n+                    base_dir=base_dir,\n+                    round_name=round_name,\n+                )\n+            )\n+\n+    for hal_step in round_entry.hal2fasta_steps:\n+        cmds.append(\n+            _from_step(\n+                hal_step,\n+                category=\"hal2fasta\",\n+                base_dir=base_dir,\n+                round_name=round_name,\n+            )\n+        )\n+\n+    return cmds\n+\n+\n+def _from_step(\n+    step: Step,\n+    category: str,\n+    base_dir: Path,\n+    round_name: Optional[str] = None,\n+) -> PlannedCommand:\n+    command = _split_command(step.raw)\n+    if step.kind == \"hal2fasta\":\n+        command = _normalize_hal2fasta(command)\n+    log_path = Path(step.log_file) if step.log_file else None\n+    display_name = step.short_label()\n+    return PlannedCommand(\n+        command=command,\n+        category=category,\n+        display_name=display_name,\n+        log_path=_resolve_path(log_path, base_dir) if log_path else None,\n+        round_name=round_name,\n+        step=step,\n+    )\n+\n+\n+def _ramax_command(plan: Plan, round_entry: Round, base_dir: Path, fallback_policy: str) -> PlannedCommand:\n+    workdir = round_entry.workdir\n+    if not workdir and plan.out_dir:\n+        workdir = str(Path(plan.out_dir) / \"temps\" / f\"blast-{round_entry.root}\")\n+    command: list[str] = [\n+        \"RaMAx\",\n+        \"-i\",\n+        plan.out_seq_file,\n+        \"-o\",\n+        round_entry.target_hal,\n+        \"--root\",\n+        round_entry.root,\n+    ]\n+    if workdir:\n+        command.extend([\"-w\", workdir])\n+    command.extend(plan.global_ramax_opts)\n+    command.extend(round_entry.ramax_opts)\n+\n+    log_path = _guess_ramax_log_path(plan, round_entry, base_dir)\n+\n+    fallback_steps: list[Step] = []\n+    if fallback_policy == \"cactus\":\n+        if round_entry.blast_step:\n+            fallback_steps.append(round_entry.blast_step)\n+        if round_entry.align_step:\n+            fallback_steps.append(round_entry.align_step)\n+\n+    workdir_path = Path(workdir).expanduser() if workdir else None\n+    if workdir_path and not workdir_path.is_absolute():\n+        workdir_path = (base_dir / workdir_path).resolve()\n+    return PlannedCommand(\n+        command=command,\n+        category=\"ramax\",\n+        display_name=f\"RaMAx-{round_entry.root}\",\n+        log_path=log_path,\n+        round_name=round_entry.name,\n+        step=None,\n+        is_ramax=True,\n+        fallback_steps=fallback_steps,\n+        workdir=workdir_path,\n+    )\n+\n+\n+def _guess_ramax_log_path(plan: Plan, round_entry: Round, base_dir: Path) -> Optional[Path]:\n+    if round_entry.align_step and round_entry.align_step.log_file:\n+        align_log = Path(round_entry.align_step.log_file)\n+        ramax_name = align_log.name.replace(\"align\", \"ramax\")\n+        return _resolve_path(align_log.with_name(ramax_name), base_dir)\n+    if plan.out_dir:\n+        return _resolve_path(Path(plan.out_dir) / \"logs\" / f\"ramax-{round_entry.root}.log\", base_dir)\n+    return None\n+\n+\n+def _resolve_path(path: Path, base_dir: Path) -> Path:\n+    expanded = path.expanduser()\n+    if expanded.is_absolute():\n+        return expanded\n+    return (base_dir / expanded).resolve()\n+\n+\n+def _split_command(raw: str) -> List[str]:\n+    try:\n+        return shlex.split(raw)\n+    except ValueError:\n+        return raw.split()\n+\n+\n+def _normalize_hal2fasta(command: List[str]) -> List[str]:\n+    \"\"\"Normalize a hal2fasta invocation to avoid shell redirection.\n+\n+    cactus-prepare emits commands like:\n+        hal2fasta in.hal Anc0 --hdf5InMemory > out.fa\n+\n+    Since we execute with ``shell=False``, the '>' token is treated as an\n+    argument and hal2fasta fails. This helper converts the redirection to the\n+    explicit ``--outFaPath`` option that hal2fasta supports.\n+    \"\"\"\n+\n+    if \">\" not in command and \">>\" not in command:\n+        return command\n+\n+    # Identify redirection token and the output path following it\n+    redirect_token = \">\" if \">\" in command else \">>\"\n+    try:\n+        redirect_index = command.index(redirect_token)\n+    except ValueError:\n+        return command\n+\n+    out_path = command[redirect_index + 1] if redirect_index + 1 < len(command) else None\n+    # Keep the main part of the command before redirection\n+    main = command[:redirect_index]\n+\n+    # Remove any existing --outFaPath occurrences to avoid duplicates\n+    cleaned: List[str] = []\n+    skip_next = False\n+    for token in main:\n+        if skip_next:\n+            skip_next = False\n+            continue\n+        if token == \"--outFaPath\":\n+            skip_next = True\n+            continue\n+        cleaned.append(token)\n+\n+    if out_path:\n+        cleaned.extend([\"--outFaPath\", out_path])\n+    return cleaned"
      },
      {
        "sha": "72636ceffd2ef6a8faf5034f898d26642f9c519c",
        "filename": "cax/render.py",
        "status": "added",
        "additions": 50,
        "deletions": 0,
        "changes": 50,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Frender.py",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Frender.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Frender.py?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,50 @@\n+\"\"\"Rendering helpers for previews and shell exports.\"\"\"\n+from __future__ import annotations\n+\n+from io import StringIO\n+import shlex\n+from typing import Iterable\n+\n+from rich.console import Console\n+from rich.table import Table\n+\n+from .models import Plan\n+from .planner import PlannedCommand\n+\n+\n+def plan_overview(plan: Plan) -> str:\n+    \"\"\"Return a rich table summarising the plan.\"\"\"\n+\n+    buf = StringIO()\n+    console = Console(file=buf, force_terminal=True, color_system=None)\n+\n+    table = Table(title=\"Cactus → RaMAx Plan\", show_header=True, header_style=\"bold magenta\")\n+    table.add_column(\"Round\")\n+    table.add_column(\"Root\")\n+    table.add_column(\"Target HAL\")\n+    table.add_column(\"RaMAx?\")\n+    table.add_column(\"Workdir\")\n+\n+    for round_entry in plan.rounds:\n+        table.add_row(\n+            round_entry.name,\n+            round_entry.root,\n+            round_entry.target_hal,\n+            \"yes\" if round_entry.replace_with_ramax else \"no\",\n+            round_entry.workdir or \"\",\n+        )\n+\n+    console.print(table)\n+    return buf.getvalue()\n+\n+\n+def render_run_script(plan: Plan, commands: Iterable[PlannedCommand]) -> str:\n+    \"\"\"Create a bash script representing the execution order.\"\"\"\n+\n+    lines = [\"#!/usr/bin/env bash\", \"set -euo pipefail\", \"\", \"# Generated from cactus-prepare plan\"]\n+    for command in commands:\n+        lines.append(f\"# {command.display_name}\")\n+        lines.append(shlex.join(command.command))\n+        lines.append(\"\")\n+    script = \"\\n\".join(lines).rstrip() + \"\\n\"\n+    return script"
      },
      {
        "sha": "cecf567543e853dba66a7b62471dcd58df67177e",
        "filename": "cax/runner.py",
        "status": "added",
        "additions": 149,
        "deletions": 0,
        "changes": 149,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Frunner.py",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Frunner.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Frunner.py?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,149 @@\n+\"\"\"Execution engine for running CAX plans.\"\"\"\n+from __future__ import annotations\n+\n+import os\n+from pathlib import Path\n+import shlex\n+import subprocess\n+import time\n+from typing import Iterable, Optional\n+\n+from . import planner\n+from .models import Plan, Step\n+\n+\n+class PlanRunner:\n+    \"\"\"Run a :class:`~cax.models.Plan` sequentially with logging and fallback handling.\"\"\"\n+\n+    def __init__(self, plan: Plan, base_dir: Optional[Path] = None, env: Optional[dict[str, str]] = None, mirror_stdout: bool = True):\n+        self.plan = plan\n+        self.base_dir = Path(base_dir) if base_dir else Path.cwd()\n+        self.env = os.environ.copy()\n+        if env:\n+            self.env.update(env)\n+        self.log_root = self._derive_log_root()\n+        self.master_log_path = self.log_root / \"cax-run.log\"\n+        self.mirror_stdout = mirror_stdout\n+\n+    def run(self, dry_run: Optional[bool] = None) -> None:\n+        \"\"\"Execute the plan. When ``dry_run`` is True, commands are only logged.\"\"\"\n+\n+        effective_dry = self.plan.dry_run if dry_run is None else dry_run\n+        planned_commands = planner.build_execution_plan(self.plan, self.base_dir)\n+        self.log_root.mkdir(parents=True, exist_ok=True)\n+        with self.master_log_path.open(\"a\", encoding=\"utf-8\") as master_log:\n+            for command in planned_commands:\n+                success = self._run_single(command, master_log, effective_dry)\n+                if success:\n+                    continue\n+                if command.is_ramax and command.fallback_steps and self.plan.fallback_policy == \"cactus\":\n+                    master_log.write(f\"[fallback] {command.display_name} failed – executing cactus steps\\n\")\n+                    master_log.flush()\n+                    success = self._run_fallback(command, master_log, effective_dry)\n+                if not success:\n+                    raise RuntimeError(f\"Command failed: {command.display_name}\")\n+\n+    def _run_single(self, command: planner.PlannedCommand, master_log, dry_run: bool) -> bool:\n+        start_time = time.time()\n+        preview = command.shell_preview()\n+        master_log.write(f\"[start] {command.display_name}: {preview}\\n\")\n+        master_log.flush()\n+        if self.mirror_stdout:\n+            print(f\"[start] {command.display_name}: {preview}\", flush=True)\n+\n+        if dry_run:\n+            if command.log_path:\n+                command.log_path.parent.mkdir(parents=True, exist_ok=True)\n+                with command.log_path.open(\"a\", encoding=\"utf-8\") as log_file:\n+                    log_file.write(f\"# DRY RUN\\n# {preview}\\n\")\n+            master_log.write(f\"[skip] dry-run complete in {time.time() - start_time:.1f}s\\n\")\n+            master_log.flush()\n+            if self.mirror_stdout:\n+                print(f\"[skip] dry-run complete in {time.time() - start_time:.1f}s\", flush=True)\n+            return True\n+\n+        if command.workdir:\n+            command.workdir.mkdir(parents=True, exist_ok=True)\n+\n+        step_log_path = command.log_path or (self.log_root / f\"{command.display_name}.log\")\n+        step_log_path.parent.mkdir(parents=True, exist_ok=True)\n+\n+        with step_log_path.open(\"a\", encoding=\"utf-8\") as step_log:\n+            step_log.write(f\"# Command: {preview}\\n\")\n+            step_log.flush()\n+            try:\n+                proc = subprocess.Popen(\n+                    command.command,\n+                    cwd=self.base_dir,\n+                    env=self.env,\n+                    stdout=subprocess.PIPE,\n+                    stderr=subprocess.STDOUT,\n+                    text=True,\n+                )\n+            except OSError as exc:\n+                message = f\"[error] Failed to launch {command.display_name}: {exc}\\n\"\n+                step_log.write(message)\n+                master_log.write(message)\n+                master_log.flush()\n+                if self.mirror_stdout:\n+                    print(message, end=\"\", flush=True)\n+                return False\n+            assert proc.stdout is not None\n+            for line in proc.stdout:\n+                step_log.write(line)\n+                master_log.write(line)\n+                if self.mirror_stdout:\n+                    print(line, end=\"\", flush=True)\n+            return_code = proc.wait()\n+            duration = time.time() - start_time\n+            step_log.write(f\"\\n# Exit code: {return_code} ({duration:.1f}s)\\n\")\n+            step_log.flush()\n+            master_log.write(f\"[end] {command.display_name} -> {return_code} ({duration:.1f}s)\\n\")\n+            master_log.flush()\n+            if self.mirror_stdout:\n+                print(f\"[end] {command.display_name} -> {return_code} ({duration:.1f}s)\", flush=True)\n+            return return_code == 0\n+\n+    def _run_fallback(self, command: planner.PlannedCommand, master_log, dry_run: bool) -> bool:\n+        for step in command.fallback_steps:\n+            fallback_command = planner.PlannedCommand(\n+                command=_split(step.raw),\n+                category=step.kind,\n+                display_name=step.short_label(),\n+                log_path=_step_log_path(step, self.base_dir, self.log_root),\n+                round_name=command.round_name,\n+                step=step,\n+                is_ramax=False,\n+            )\n+            success = self._run_single(fallback_command, master_log, dry_run)\n+            if not success:\n+                return False\n+        return True\n+\n+    def _derive_log_root(self) -> Path:\n+        if self.plan.out_dir:\n+            return _to_path(self.plan.out_dir, self.base_dir) / \"logs\"\n+        return (self.base_dir / \"logs\").resolve()\n+\n+\n+def _split(command: str) -> list[str]:\n+    try:\n+        return shlex.split(command)\n+    except ValueError:\n+        return command.split()\n+\n+\n+def _to_path(path_like: str, base_dir: Path) -> Path:\n+    path = Path(path_like).expanduser()\n+    if path.is_absolute():\n+        return path\n+    return (base_dir / path).resolve()\n+\n+\n+def _step_log_path(step: Step, base_dir: Path, log_root: Path) -> Path:\n+    if step.log_file:\n+        path = Path(step.log_file).expanduser()\n+        if not path.is_absolute():\n+            path = (base_dir / path).resolve()\n+        return path\n+    return (log_root / f\"{step.short_label()}\").with_suffix('.log').resolve()"
      },
      {
        "sha": "0f12312d275529e0957e0a421944b074abb9b660",
        "filename": "cax/ui.py",
        "status": "added",
        "additions": 162,
        "deletions": 0,
        "changes": 162,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Fui.py",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/cax%2Fui.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fui.py?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,162 @@\n+\"\"\"Textual-based interactive UI for configuring CAX plans.\"\"\"\n+from __future__ import annotations\n+\n+from dataclasses import dataclass\n+from pathlib import Path\n+from typing import Optional\n+\n+from textual.app import App, ComposeResult\n+from textual.binding import Binding\n+from textual.containers import Container\n+from textual.widgets import Footer, Header, ListItem, ListView, Static\n+\n+from . import config, planner, render\n+from .models import Plan, Round\n+\n+\n+@dataclass\n+class UIResult:\n+    plan: Plan\n+    action: str\n+    payload: Optional[Path] = None\n+\n+\n+class RoundListItem(ListItem):\n+    \"\"\"List item reflecting a round with RaMAx toggle.\"\"\"\n+\n+    def __init__(self, round_entry: Round, index: int):\n+        self.round_entry = round_entry\n+        self.index = index\n+        super().__init__(Static(self._text(), expand=True))\n+\n+    def _text(self) -> str:\n+        status = \"[x]\" if self.round_entry.replace_with_ramax else \"[ ]\"\n+        return f\"{status} {self.round_entry.name} ({self.round_entry.root})\\n→ {self.round_entry.target_hal}\"\n+\n+    def update_content(self) -> None:\n+        static = self.query_one(Static)\n+        static.update(self._text())\n+\n+\n+class PlanUIApp(App[UIResult]):\n+    CSS = \"\"\"\n+    Screen {\n+        layout: vertical;\n+    }\n+    #main {\n+        layout: horizontal;\n+    }\n+    #rounds {\n+        width: 45%;\n+        height: 1fr;\n+    }\n+    #details {\n+        width: 55%;\n+        padding: 1 2;\n+        overflow-y: auto;\n+    }\n+    \"\"\"\n+\n+    BINDINGS = [\n+        Binding(\"space\", \"toggle_round\", \"Toggle RaMAx\"),\n+        Binding(\"e\", \"edit_round\", \"Edit workdir (todo)\"),\n+        Binding(\"p\", \"preview_plan\", \"Preview\"),\n+        Binding(\"s\", \"save_yaml\", \"Save YAML\"),\n+        Binding(\"r\", \"run_plan\", \"Run\"),\n+        Binding(\"q\", \"quit\", \"Quit\"),\n+    ]\n+\n+    def __init__(self, plan: Plan, base_dir: Optional[Path] = None):\n+        super().__init__()\n+        self.plan = plan\n+        self.base_dir = Path(base_dir) if base_dir else Path.cwd()\n+        self.round_items: list[RoundListItem] = []\n+        self.round_list: ListView | None = None\n+        self.detail_panel: Static | None = None\n+\n+    def compose(self) -> ComposeResult:\n+        yield Header()\n+        with Container(id=\"main\"):\n+            self.round_items = [RoundListItem(round_entry, idx) for idx, round_entry in enumerate(self.plan.rounds)]\n+            list_view = ListView(*self.round_items, id=\"rounds\")\n+            self.round_list = list_view\n+            yield list_view\n+            detail = Static(render.plan_overview(self.plan), id=\"details\")\n+            self.detail_panel = detail\n+            yield detail\n+        yield Footer()\n+\n+    def on_mount(self) -> None:\n+        if self.round_list and self.round_items:\n+            self.round_list.index = 0\n+            self._show_round(0)\n+\n+    def action_toggle_round(self) -> None:\n+        if not self.round_list:\n+            return\n+        index = self.round_list.index or 0\n+        if index >= len(self.plan.rounds):\n+            return\n+        round_entry = self.plan.rounds[index]\n+        round_entry.replace_with_ramax = not round_entry.replace_with_ramax\n+        self.round_items[index].update_content()\n+        self._show_round(index)\n+\n+    def action_preview_plan(self) -> None:\n+        if self.detail_panel:\n+            preview = render.plan_overview(self.plan)\n+            self.detail_panel.update(preview)\n+\n+    def action_run_plan(self) -> None:\n+        self.exit(UIResult(plan=self.plan, action=\"run\"))\n+\n+    def action_save_yaml(self) -> None:\n+        output_dir = Path(self.plan.out_dir or self.base_dir)\n+        output_dir.mkdir(parents=True, exist_ok=True)\n+        output_path = output_dir / \"ramax_plan.yaml\"\n+        config.save_plan(self.plan, output_path)\n+        if self.detail_panel:\n+            self.detail_panel.update(f\"Saved plan to {output_path}\")\n+\n+    def action_quit(self) -> None:\n+        self.exit(UIResult(plan=self.plan, action=\"quit\"))\n+\n+    def action_edit_round(self) -> None:  # placeholder for future editing\n+        if self.detail_panel:\n+            self.detail_panel.update(\"Editing workdir not yet implemented in this preview UI.\")\n+\n+    def on_list_view_selected(self, event: ListView.Selected) -> None:\n+        self._show_round(event.index)\n+\n+    def _show_round(self, index: int) -> None:\n+        if not self.detail_panel or index >= len(self.plan.rounds):\n+            return\n+        round_entry = self.plan.rounds[index]\n+        details = [f\"[bold]{round_entry.name}[/bold] root={round_entry.root}\"]\n+        if round_entry.replace_with_ramax:\n+            commands = planner.build_execution_plan(self.plan, self.base_dir)\n+            ramax_cmd = next((cmd for cmd in commands if cmd.round_name == round_entry.name and cmd.is_ramax), None)\n+            if ramax_cmd:\n+                details.append(\"\\n[green]RaMAx command[/green]\")\n+                details.append(f\"{ramax_cmd.shell_preview()}\")\n+        else:\n+            if round_entry.blast_step:\n+                details.append(\"\\n[cyan]cactus-blast[/cyan]\")\n+                details.append(round_entry.blast_step.raw)\n+            if round_entry.align_step:\n+                details.append(\"\\n[cyan]cactus-align[/cyan]\")\n+                details.append(round_entry.align_step.raw)\n+        if round_entry.hal2fasta_steps:\n+            details.append(\"\\n[magenta]hal2fasta[/magenta]\")\n+            details.extend(step.raw for step in round_entry.hal2fasta_steps)\n+        self.detail_panel.update(\"\\n\".join(details))\n+\n+\n+def launch(plan: Plan, base_dir: Optional[Path] = None) -> UIResult:\n+    \"\"\"Run the Textual UI and return the resulting plan/action.\"\"\"\n+\n+    app = PlanUIApp(plan, base_dir=base_dir)\n+    result = app.run()\n+    if isinstance(result, UIResult):\n+        return result\n+    return UIResult(plan=plan, action=\"quit\")"
      },
      {
        "sha": "66172a7f2152307139f6c7dc010033b720cfe007",
        "filename": "examples/cactus-prepare_example.txt",
        "status": "added",
        "additions": 55,
        "deletions": 0,
        "changes": 55,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/examples%2Fcactus-prepare_example.txt",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/examples%2Fcactus-prepare_example.txt",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/examples%2Fcactus-prepare_example.txt?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,55 @@\n+cactus-prepare examples/evolverMammals.txt --outDir steps-output --outSeqFile steps-output/evovlerMammals.txt --outHal steps-output/evolverMammals.hal --jobStore jobstore\n+\n+Mon Sep 15 14:30:33 2025\n++-----------------------------------------------------------------------------------------+\n+| NVIDIA-SMI 580.82.02              Driver Version: 581.15         CUDA Version: 13.0     |\n++-----------------------------------------+------------------------+----------------------+\n+| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC |\n+| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |\n+|                                         |                        |               MIG M. |\n+|=========================================+========================+======================|\n+|   0  NVIDIA GeForce RTX 4060 ...    On  |   00000000:01:00.0  On |                  N/A |\n+| N/A   54C    P5              8W /   80W |     589MiB /   8188MiB |      3%      Default |\n+|                                         |                        |                  N/A |\n++-----------------------------------------+------------------------+----------------------+\n+\n++-----------------------------------------------------------------------------------------+\n+| Processes:                                                                              |\n+|  GPU   GI   CI              PID   Type   Process name                        GPU Memory |\n+|        ID   ID                                                               Usage      |\n+|=========================================================================================|\n+|  No running processes found                                                             |\n++-----------------------------------------------------------------------------------------+\n+## generated by : /home/tianqinzhong/miniconda3/envs/rama/bin/cactus-prepare examples/evolverMammals.txt --outDir steps-output --outSeqFile steps-output/evovlerMammals.txt --outHal steps-output/evolverMammals.hal --jobStore jobstore\n+## date : 2025-09-15 14:30:33.717159\n+## cactus commit : 3147387e9ca6ad9710b3cdebf029c5c2574e8367\n+\n+\n+## Preprocessor\n+cactus-preprocess jobstore/0 examples/evolverMammals.txt steps-output/evovlerMammals.txt --inputNames simHuman_chr6 simCow_chr6 simDog_chr6 simMouse_chr6 simRat_chr6   --logFile steps-output/logs/preprocess-simHuman_chr6.log\n+\n+## Alignment\n+\n+### Round 0\n+cactus-blast jobstore/1 steps-output/evovlerMammals.txt steps-output/Anc2.paf --root Anc2   --logFile steps-output/logs/blast-Anc2.log\n+cactus-align jobstore/2 steps-output/evovlerMammals.txt steps-output/Anc2.paf steps-output/Anc2.hal --root Anc2   --logFile steps-output/logs/align-Anc2.log\n+hal2fasta steps-output/Anc2.hal Anc2 --hdf5InMemory > steps-output/Anc2.fa\n+\n+cactus-blast jobstore/3 steps-output/evovlerMammals.txt steps-output/mr.paf --root mr   --logFile steps-output/logs/blast-mr.log\n+cactus-align jobstore/4 steps-output/evovlerMammals.txt steps-output/mr.paf steps-output/mr.hal --root mr   --logFile steps-output/logs/align-mr.log\n+hal2fasta steps-output/mr.hal mr --hdf5InMemory > steps-output/mr.fa\n+\n+### Round 1\n+cactus-blast jobstore/5 steps-output/evovlerMammals.txt steps-output/Anc1.paf --root Anc1   --logFile steps-output/logs/blast-Anc1.log\n+cactus-align jobstore/6 steps-output/evovlerMammals.txt steps-output/Anc1.paf steps-output/Anc1.hal --root Anc1   --logFile steps-output/logs/align-Anc1.log\n+hal2fasta steps-output/Anc1.hal Anc1 --hdf5InMemory > steps-output/Anc1.fa\n+\n+### Round 2\n+cactus-blast jobstore/7 steps-output/evovlerMammals.txt steps-output/Anc0.paf --root Anc0   --logFile steps-output/logs/blast-Anc0.log\n+cactus-align jobstore/8 steps-output/evovlerMammals.txt steps-output/Anc0.paf steps-output/evolverMammals.hal --root Anc0   --logFile steps-output/logs/align-Anc0.log\n+hal2fasta steps-output/evolverMammals.hal Anc0 --hdf5InMemory > steps-output/Anc0.fa\n+\n+## HAL merging\n+halAppendSubtree steps-output/evolverMammals.hal steps-output/Anc1.hal Anc1 Anc1 --merge --hdf5InMemory\n+halAppendSubtree steps-output/evolverMammals.hal steps-output/Anc2.hal Anc2 Anc2 --merge --hdf5InMemory\n+halAppendSubtree steps-output/evolverMammals.hal steps-output/mr.hal mr mr --merge --hdf5InMemory\n\\ No newline at end of file"
      },
      {
        "sha": "2666e1784a1c2597bb1475f5068f55668613eaef",
        "filename": "examples/evolverMammals.txt",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/examples%2FevolverMammals.txt",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/examples%2FevolverMammals.txt",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/examples%2FevolverMammals.txt?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,7 @@\n+((simHuman_chr6:0.144018,(simMouse_chr6:0.084509,simRat_chr6:0.091589)mr:0.271974):0.020593,(simCow_chr6:0.18908,simDog_chr6:0.16303):0.032898);\n+\n+simCow_chr6 https://raw.githubusercontent.com/ComparativeGenomicsToolkit/cactusTestData/master/evolver/mammals/loci1/simCow.chr6\n+simDog_chr6 https://raw.githubusercontent.com/ComparativeGenomicsToolkit/cactusTestData/master/evolver/mammals/loci1/simDog.chr6\n+simHuman_chr6 https://raw.githubusercontent.com/ComparativeGenomicsToolkit/cactusTestData/master/evolver/mammals/loci1/simHuman.chr6\n+simMouse_chr6 https://raw.githubusercontent.com/ComparativeGenomicsToolkit/cactusTestData/master/evolver/mammals/loci1/simMouse.chr6\n+simRat_chr6 https://raw.githubusercontent.com/ComparativeGenomicsToolkit/cactusTestData/master/evolver/mammals/loci1/simRat.chr6"
      },
      {
        "sha": "9c8623807fc6703b253ec081ab220862ac635184",
        "filename": "examples/evolverPrimates.txt",
        "status": "added",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/examples%2FevolverPrimates.txt",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/examples%2FevolverPrimates.txt",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/examples%2FevolverPrimates.txt?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,6 @@\n+(simOrang:0.00993,((simChimp:0.00272,simHuman:0.00269)cb:0.00415,simGorilla:0.00644)hcb:0.00046);\n+\n+simOrang\thttps://raw.githubusercontent.com/ComparativeGenomicsToolkit/cactusTestData/master/evolver/primates/loci1/simOrang.chr6\n+simChimp\thttps://raw.githubusercontent.com/ComparativeGenomicsToolkit/cactusTestData/master/evolver/primates/loci1/simChimp.chr6\n+simHuman\thttps://raw.githubusercontent.com/ComparativeGenomicsToolkit/cactusTestData/master/evolver/primates/loci1/simHuman.chr6\n+simGorilla\thttps://raw.githubusercontent.com/ComparativeGenomicsToolkit/cactusTestData/master/evolver/primates/loci1/simGorilla.chr6"
      },
      {
        "sha": "fa36ef0f2d9b96a22def268fa78bb2c3702f8932",
        "filename": "pyproject.toml",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/malabz/Cax/blob/9aed28083f894a9567cb5713be0a08db20afdcb2/pyproject.toml",
        "raw_url": "https://github.com/malabz/Cax/raw/9aed28083f894a9567cb5713be0a08db20afdcb2/pyproject.toml",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/pyproject.toml?ref=9aed28083f894a9567cb5713be0a08db20afdcb2",
        "patch": "@@ -0,0 +1,36 @@\n+[build-system]\n+requires = [\"hatchling\"]\n+build-backend = \"hatchling.build\"\n+\n+[project]\n+name = \"cactus-ramax\"\n+version = \"0.1.0\"\n+description = \"Interactive tooling for mixing cactus and RaMAx workflows\"\n+authors = [{name = \"Cactus-RaMAx Team\"}]\n+readme = \"README.md\"\n+requires-python = \">=3.10\"\n+dependencies = [\n+    \"typer>=0.9\",\n+    \"rich>=13\",\n+    \"textual>=0.54\",\n+    \"pydantic>=2.6\",\n+    \"pyyaml>=6\",\n+    \"psutil>=5\",\n+]\n+\n+[project.optional-dependencies]\n+ui = [\"textual>=0.54\", \"rich>=13\"]\n+\n+[project.scripts]\n+cax = \"cax.cli:app\"\n+\n+[tool.pytest.ini_options]\n+testpaths = [\"tests\"]\n+python_files = [\"test_*.py\"]\n+\n+[tool.hatch.build.targets.wheel]\n+packages = [\"cax\"]\n+\n+[tool.hatch.build.targets.sdist]\n+include = [\"cax\", \"examples\", \"tests\", \"README.md\", \"pyproject.toml\"]\n+"
      }
    ]
  }
}