{
  "cached_at": "2025-12-20T14:33:30.550068",
  "commit_sha": "c7826a78095e1d7bd33955b97df0509f95720b15",
  "repo": "malabz/Cax",
  "data": {
    "sha": "c7826a78095e1d7bd33955b97df0509f95720b15",
    "node_id": "C_kwDOPt61otoAKGM3ODI2YTc4MDk1ZTFkN2JkMzM5NTViOTdkZjA1MDlmOTU3MjBiMTU",
    "commit": {
      "author": {
        "name": "LoadStar822",
        "email": "992247533@qq.com",
        "date": "2025-11-21T01:34:31Z"
      },
      "committer": {
        "name": "LoadStar822",
        "email": "992247533@qq.com",
        "date": "2025-11-21T01:34:31Z"
      },
      "message": "Rewrite plan UI and enhance Newick support",
      "tree": {
        "sha": "40a1d5e568deeec45b37030b8eddde70d2af46c7",
        "url": "https://api.github.com/repos/malabz/Cax/git/trees/40a1d5e568deeec45b37030b8eddde70d2af46c7"
      },
      "url": "https://api.github.com/repos/malabz/Cax/git/commits/c7826a78095e1d7bd33955b97df0509f95720b15",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null,
        "verified_at": null
      }
    },
    "url": "https://api.github.com/repos/malabz/Cax/commits/c7826a78095e1d7bd33955b97df0509f95720b15",
    "html_url": "https://github.com/malabz/Cax/commit/c7826a78095e1d7bd33955b97df0509f95720b15",
    "comments_url": "https://api.github.com/repos/malabz/Cax/commits/c7826a78095e1d7bd33955b97df0509f95720b15/comments",
    "author": {
      "login": "LoadStar822",
      "id": 56856603,
      "node_id": "MDQ6VXNlcjU2ODU2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/56856603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LoadStar822",
      "html_url": "https://github.com/LoadStar822",
      "followers_url": "https://api.github.com/users/LoadStar822/followers",
      "following_url": "https://api.github.com/users/LoadStar822/following{/other_user}",
      "gists_url": "https://api.github.com/users/LoadStar822/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LoadStar822/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LoadStar822/subscriptions",
      "organizations_url": "https://api.github.com/users/LoadStar822/orgs",
      "repos_url": "https://api.github.com/users/LoadStar822/repos",
      "events_url": "https://api.github.com/users/LoadStar822/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LoadStar822/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "committer": {
      "login": "LoadStar822",
      "id": 56856603,
      "node_id": "MDQ6VXNlcjU2ODU2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/56856603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LoadStar822",
      "html_url": "https://github.com/LoadStar822",
      "followers_url": "https://api.github.com/users/LoadStar822/followers",
      "following_url": "https://api.github.com/users/LoadStar822/following{/other_user}",
      "gists_url": "https://api.github.com/users/LoadStar822/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LoadStar822/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LoadStar822/subscriptions",
      "organizations_url": "https://api.github.com/users/LoadStar822/orgs",
      "repos_url": "https://api.github.com/users/LoadStar822/repos",
      "events_url": "https://api.github.com/users/LoadStar822/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LoadStar822/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5c62f9b5dbdab43440503e22b8799d27ff39faf0",
        "url": "https://api.github.com/repos/malabz/Cax/commits/5c62f9b5dbdab43440503e22b8799d27ff39faf0",
        "html_url": "https://github.com/malabz/Cax/commit/5c62f9b5dbdab43440503e22b8799d27ff39faf0"
      }
    ],
    "stats": {
      "total": 1537,
      "additions": 939,
      "deletions": 598
    },
    "files": [
      {
        "sha": "cc6f079815bc1a01b63ca2cc555e93d3178e105b",
        "filename": "CHANGELOG.md",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/malabz/Cax/blob/c7826a78095e1d7bd33955b97df0509f95720b15/CHANGELOG.md",
        "raw_url": "https://github.com/malabz/Cax/raw/c7826a78095e1d7bd33955b97df0509f95720b15/CHANGELOG.md",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/CHANGELOG.md?ref=c7826a78095e1d7bd33955b97df0509f95720b15",
        "patch": "@@ -2,6 +2,22 @@\n \n All notable changes to this project will be documented in this file.\n \n+## [0.3.0-dev] - Unreleased\n+\n+### UI\n+- Rebuilt the alignment browser as an ASCII phylogenetic canvas with clado/phylo modes, proportional branch spacing, subtree focus/return, and RaMAx toggles that repaint the tree in place without the old Textual tree widget.\n+- Added search (`/`, `n` / `Shift+N`), zoom, ASCII glyph fallback, and a detail buffer/info modal so large trees stay navigable and summaries remain visible even on narrow terminals.\n+\n+### Tree parsing\n+- Alignment nodes now retain branch lengths, support values, and parent links, enabling proportional layouts and state colouring while tolerating unlabeled or missing edges.\n+- Newick parsing accepts numeric internal labels as support scores and ignores malformed branch lengths instead of failing the entire parse.\n+\n+### CLI & plumbing\n+- Moved the plan overview/environment rendering helpers into `cax.ui` (retiring `cax.render`) and pointed CLI previews at the shared UI renderer for consistent output and script exports.\n+\n+### Tests\n+- Removed the outdated planner-skips and tree-utils tests pending replacement after the parser/UI overhaul.\n+\n ## [0.2.2] - 2025-11-08\n \n ### UI"
      },
      {
        "sha": "d5109100e995d78beb0ab965dfea62011b71d7bb",
        "filename": "VERSION",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/malabz/Cax/blob/c7826a78095e1d7bd33955b97df0509f95720b15/VERSION",
        "raw_url": "https://github.com/malabz/Cax/raw/c7826a78095e1d7bd33955b97df0509f95720b15/VERSION",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/VERSION?ref=c7826a78095e1d7bd33955b97df0509f95720b15",
        "patch": "@@ -1 +1 @@\n-0.2.2\n+0.3.0-dev"
      },
      {
        "sha": "5dea287c2857c6537ebf9dab819501062b4ab4b4",
        "filename": "cax/cli.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/malabz/Cax/blob/c7826a78095e1d7bd33955b97df0509f95720b15/cax%2Fcli.py",
        "raw_url": "https://github.com/malabz/Cax/raw/c7826a78095e1d7bd33955b97df0509f95720b15/cax%2Fcli.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fcli.py?ref=c7826a78095e1d7bd33955b97df0509f95720b15",
        "patch": "@@ -10,7 +10,7 @@\n from rich import print\n import shutil\n \n-from . import command_prompt, history, parser, render, ui as ui_module\n+from . import command_prompt, history, parser, ui as ui_module\n from .models import RunSettings\n from .runner import PlanRunner\n \n@@ -81,7 +81,7 @@ def ui(\n         runner = PlanRunner(plan, run_settings=run_settings)\n         runner.run()\n     else:\n-        print(render.plan_overview(plan, run_settings=run_settings))\n+        print(ui_module.plan_overview(plan, run_settings=run_settings))\n \n \n if __name__ == \"__main__\":"
      },
      {
        "sha": "151affb2b73924f18cc36581dda1ebd85333cf45",
        "filename": "cax/render.py",
        "status": "removed",
        "additions": 0,
        "deletions": 109,
        "changes": 109,
        "blob_url": "https://github.com/malabz/Cax/blob/5c62f9b5dbdab43440503e22b8799d27ff39faf0/cax%2Frender.py",
        "raw_url": "https://github.com/malabz/Cax/raw/5c62f9b5dbdab43440503e22b8799d27ff39faf0/cax%2Frender.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Frender.py?ref=5c62f9b5dbdab43440503e22b8799d27ff39faf0",
        "patch": "@@ -1,109 +0,0 @@\n-\"\"\"Rendering helpers for previews and shell exports.\"\"\"\n-from __future__ import annotations\n-\n-import shlex\n-from io import StringIO\n-from typing import Iterable, Optional\n-\n-from rich.console import Console, Group\n-from rich.panel import Panel\n-from rich.table import Table\n-from rich.text import Text\n-\n-from .models import Plan, RunSettings\n-from .planner import PlannedCommand\n-\n-\n-def plan_overview(plan: Plan, run_settings: Optional[RunSettings] = None, compact: bool = False) -> Panel:\n-    \"\"\"Return a Rich Panel summarising the plan (auto-resizes in UI).\"\"\"\n-\n-    table = Table(\n-        title=\"Cactus → RaMAx Plan\",\n-        show_header=True,\n-        header_style=\"bold magenta\",\n-        expand=True,\n-    )\n-    if compact:\n-        table.add_column(\"Round\", overflow=\"ellipsis\", no_wrap=True, ratio=2)\n-        table.add_column(\"Root\", overflow=\"ellipsis\", no_wrap=True, ratio=2)\n-        table.add_column(\"Target HAL\", overflow=\"ellipsis\", no_wrap=True, ratio=3)\n-        table.add_column(\"RaMAx?\", overflow=\"ellipsis\", no_wrap=True, ratio=1)\n-    else:\n-        table.add_column(\"Round\", overflow=\"fold\")\n-        table.add_column(\"Root\", overflow=\"fold\")\n-        table.add_column(\"Target HAL\", overflow=\"fold\")\n-        table.add_column(\"RaMAx?\", overflow=\"fold\")\n-        table.add_column(\"Workdir\", overflow=\"fold\")\n-\n-    for round_entry in plan.rounds:\n-        row = [\n-            round_entry.name,\n-            round_entry.root,\n-            round_entry.target_hal,\n-            \"yes\" if round_entry.replace_with_ramax else \"no\",\n-        ]\n-        if not compact:\n-            row.append(round_entry.workdir or \"\")\n-        table.add_row(*row)\n-\n-    settings = run_settings or RunSettings()\n-    thread_label = (\n-        \"auto (command defaults)\"\n-        if settings.thread_count is None\n-        else f\"{settings.thread_count} threads (--maxCores/--threads)\"\n-    )\n-    footer_text = f\"Verbose logging: {'on' if settings.verbose else 'off'} | Thread target: {thread_label}\"\n-    footer = Text(footer_text, style=\"dim\")\n-    content = Group(table, footer)\n-    return Panel(content, border_style=\"magenta\", expand=True)\n-\n-\n-def environment_summary_card(\n-    environment: dict[str, Optional[str]],\n-    resources: dict[str, str],\n-) -> Panel:\n-    \"\"\"Return a Rich Panel that adapts to container width (no pre-rendering).\"\"\"\n-\n-    def value_or_missing(value: Optional[str]) -> str:\n-        return value if value else \"Not detected\"\n-\n-    def oneline(value: Optional[str]) -> str:\n-        if not value:\n-            return \"Not detected\"\n-        lines = value.splitlines()\n-        if not lines:\n-            return value\n-        return lines[0] if len(lines) == 1 else f\"{lines[0]} (+{len(lines)-1} more)\"\n-\n-    table = Table.grid(padding=(0, 1), expand=True)\n-    table.add_column(ratio=1)\n-\n-    def entry(name: str, value: Optional[str]) -> Text:\n-        text = Text()\n-        text.append(f\"{name}: \", style=\"bold cyan\")\n-        text.append(oneline(value))\n-        return text\n-\n-    table.add_row(entry(\"RaMAx path\", environment.get(\"ramax_path\")))\n-    table.add_row(entry(\"RaMAx version\", environment.get(\"ramax_version\")))\n-    table.add_row(entry(\"cactus path\", environment.get(\"cactus_path\")))\n-    table.add_row(entry(\"cactus version\", environment.get(\"cactus_version\")))\n-    table.add_row(entry(\"GPU\", environment.get(\"gpu\")))\n-    table.add_row(entry(\"CPU cores\", resources.get(\"cpu_count\")))\n-    table.add_row(entry(\"Memory (GB)\", resources.get(\"memory_gb\")))\n-    table.add_row(entry(\"Disk free (GB)\", resources.get(\"disk_free_gb\")))\n-\n-    panel = Panel(table, title=\"Environment summary\", border_style=\"cyan\", expand=True)\n-    return panel\n-\n-\n-def render_run_script(plan: Plan, commands: Iterable[PlannedCommand]) -> str:\n-    \"\"\"Create a bash script representing the execution order.\"\"\"\n-\n-    lines = [\"#!/usr/bin/env bash\", \"set -euo pipefail\", \"\", \"# Generated from cactus-prepare plan\"]\n-    for command in commands:\n-        lines.append(f\"# {command.display_name}\")\n-        lines.append(shlex.join(command.command))\n-        lines.append(\"\")\n-    script = \"\\n\".join(lines).rstrip() + \"\\n\"\n-    return script"
      },
      {
        "sha": "6e1c2fa53d90fa4742a0f8c2115daa87e89eb173",
        "filename": "cax/tree_utils.py",
        "status": "modified",
        "additions": 29,
        "deletions": 16,
        "changes": 45,
        "blob_url": "https://github.com/malabz/Cax/blob/c7826a78095e1d7bd33955b97df0509f95720b15/cax%2Ftree_utils.py",
        "raw_url": "https://github.com/malabz/Cax/raw/c7826a78095e1d7bd33955b97df0509f95720b15/cax%2Ftree_utils.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Ftree_utils.py?ref=c7826a78095e1d7bd33955b97df0509f95720b15",
        "patch": "@@ -12,14 +12,16 @@ class NewickParseError(RuntimeError):\n     \"\"\"Raised when a Newick tree cannot be parsed correctly.\"\"\"\n \n \n-@dataclass\n+@dataclass(eq=False)\n class AlignmentNode:\n     \"\"\"Node within the cactus alignment tree.\"\"\"\n \n     name: str\n     children: list[\"AlignmentNode\"] = field(default_factory=list)\n     round: Optional[Round] = None\n     parent: Optional[\"AlignmentNode\"] = field(default=None, repr=False)\n+    length: Optional[float] = None\n+    support: Optional[float] = None\n \n     def walk(self) -> Iterator[\"AlignmentNode\"]:\n         \"\"\"Yield this node and all descendants.\"\"\"\n@@ -146,18 +148,20 @@ def _parse_subtree(self) -> AlignmentNode:\n                     self.index += 1\n                     break\n                 raise NewickParseError(f\"Expected ',' or ')' at position {self.index}\")\n-            name = self._parse_label()\n-            self._parse_branch_length()\n-            node = AlignmentNode(name=name or \"\", children=children)\n+            label = self._parse_label()\n+            length = self._parse_branch_length_value()\n+            name, support = self._split_name_support(label, internal=True)\n+            node = AlignmentNode(name=name or \"\", children=children, length=length, support=support)\n             for child in children:\n                 child.parent = node\n             return node\n \n         label = self._parse_label()\n         if not label:\n             raise NewickParseError(f\"Missing leaf label at position {self.index}\")\n-        self._parse_branch_length()\n-        return AlignmentNode(name=label)\n+        length = self._parse_branch_length_value()\n+        name, _ = self._split_name_support(label, internal=False)\n+        return AlignmentNode(name=name, length=length)\n \n     def _parse_label(self) -> str:\n         self._skip_ws()\n@@ -173,22 +177,31 @@ def _parse_label(self) -> str:\n         self._skip_ws()\n         return label\n \n-    def _parse_branch_length(self) -> None:\n+    def _parse_branch_length_value(self) -> Optional[float]:\n         self._skip_ws()\n         if self._peek() != \":\":\n-            return\n+            return None\n         self.index += 1\n         start = self.index\n-        while self.index < self.length:\n-            char = self.text[self.index]\n-            if char in \",();\":\n-                break\n-            if char.isspace():\n-                break\n+        while self.index < self.length and self.text[self.index] not in \",(); \\t\\r\\n\":\n             self.index += 1\n-        if start == self.index:\n-            raise NewickParseError(f\"Missing branch length at position {self.index}\")\n+        token = self.text[start:self.index].strip()\n         self._skip_ws()\n+        if not token:\n+            return None\n+        try:\n+            return float(token)\n+        except ValueError:\n+            return None\n+\n+    def _split_name_support(self, label: str, internal: bool) -> tuple[str, Optional[float]]:\n+        text = (label or \"\").strip()\n+        if internal and text and all(ch.isdigit() or ch == \".\" for ch in text):\n+            try:\n+                return \"\", float(text)\n+            except ValueError:\n+                return \"\", None\n+        return text, None\n \n     def _skip_ws(self) -> None:\n         while self.index < self.length and self.text[self.index].isspace():"
      },
      {
        "sha": "8f26432d1556c87ab2fc0acd78701a1fc8a236d0",
        "filename": "cax/ui.py",
        "status": "modified",
        "additions": 890,
        "deletions": 300,
        "changes": 1190,
        "blob_url": "https://github.com/malabz/Cax/blob/c7826a78095e1d7bd33955b97df0509f95720b15/cax%2Fui.py",
        "raw_url": "https://github.com/malabz/Cax/raw/c7826a78095e1d7bd33955b97df0509f95720b15/cax%2Fui.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fui.py?ref=c7826a78095e1d7bd33955b97df0509f95720b15",
        "patch": "@@ -1,21 +1,27 @@\n \"\"\"Textual-based interactive UI for configuring CAX plans.\"\"\"\n from __future__ import annotations\n \n+import math\n+import shlex\n from dataclasses import dataclass\n from pathlib import Path\n-from typing import Optional\n+from typing import Callable, Iterable, Optional\n \n+from textual import events\n from textual.app import App, ComposeResult\n from textual.binding import Binding\n from textual.containers import Container\n-from textual.geometry import Size\n from textual.screen import ModalScreen, Screen\n-from textual.widgets import Button, Checkbox, Footer, Header, Input, ListItem, ListView, Static, Tree, TextArea\n+from textual.widgets import Button, Checkbox, Footer, Header, Input, ListItem, ListView, Static, TextArea\n \n+from rich.console import Console, Group, RenderableType\n+from rich.panel import Panel\n+from rich.table import Table\n from rich.text import Text\n \n-from . import detectors, planner, render, tree_utils\n+from . import planner, tree_utils\n from .models import Plan, Round, RunSettings, Step\n+from .planner import PlannedCommand\n \n \n @dataclass\n@@ -38,6 +44,95 @@ class CommandTarget:\n     index: int | None = None\n \n \n+def plan_overview(plan: Plan, run_settings: Optional[RunSettings] = None, compact: bool = False) -> Panel:\n+    \"\"\"Return a Rich Panel that summarizes the plan.\"\"\"\n+\n+    table = Table(\n+        title=\"Cactus → RaMAx Plan\",\n+        show_header=True,\n+        header_style=\"bold magenta\",\n+        expand=True,\n+    )\n+    if compact:\n+        table.add_column(\"Round\", overflow=\"ellipsis\", no_wrap=True, ratio=2)\n+        table.add_column(\"Root\", overflow=\"ellipsis\", no_wrap=True, ratio=2)\n+        table.add_column(\"Target HAL\", overflow=\"ellipsis\", no_wrap=True, ratio=3)\n+        table.add_column(\"RaMAx?\", overflow=\"ellipsis\", no_wrap=True, ratio=1)\n+    else:\n+        table.add_column(\"Round\", overflow=\"fold\")\n+        table.add_column(\"Root\", overflow=\"fold\")\n+        table.add_column(\"Target HAL\", overflow=\"fold\")\n+        table.add_column(\"RaMAx?\", overflow=\"fold\")\n+        table.add_column(\"Workdir\", overflow=\"fold\")\n+\n+    for round_entry in plan.rounds:\n+        row = [\n+            round_entry.name,\n+            round_entry.root,\n+            round_entry.target_hal,\n+            \"yes\" if round_entry.replace_with_ramax else \"no\",\n+        ]\n+        if not compact:\n+            row.append(round_entry.workdir or \"\")\n+        table.add_row(*row)\n+\n+    settings = run_settings or RunSettings()\n+    thread_label = (\n+        \"auto (command defaults)\"\n+        if settings.thread_count is None\n+        else f\"{settings.thread_count} threads (--maxCores/--threads)\"\n+    )\n+    footer_text = f\"Verbose logging: {'on' if settings.verbose else 'off'} | Thread target: {thread_label}\"\n+    footer = Text(footer_text, style=\"dim\")\n+    content = Group(table, footer)\n+    return Panel(content, border_style=\"magenta\", expand=True)\n+\n+\n+def environment_summary_card(environment: dict[str, Optional[str]], resources: dict[str, str]) -> Panel:\n+    \"\"\"Build an environment summary card that adapts to the UI width.\"\"\"\n+\n+    def oneline(value: Optional[str]) -> str:\n+        if not value:\n+            return \"Not detected\"\n+        lines = value.splitlines()\n+        if not lines:\n+            return value\n+        return lines[0] if len(lines) == 1 else f\"{lines[0]} (+{len(lines)-1} more)\"\n+\n+    table = Table.grid(padding=(0, 1), expand=True)\n+    table.add_column(ratio=1)\n+\n+    def entry(name: str, value: Optional[str]) -> Text:\n+        text = Text()\n+        text.append(f\"{name}: \", style=\"bold cyan\")\n+        text.append(oneline(value))\n+        return text\n+\n+    table.add_row(entry(\"RaMAx path\", environment.get(\"ramax_path\")))\n+    table.add_row(entry(\"RaMAx version\", environment.get(\"ramax_version\")))\n+    table.add_row(entry(\"cactus path\", environment.get(\"cactus_path\")))\n+    table.add_row(entry(\"cactus version\", environment.get(\"cactus_version\")))\n+    table.add_row(entry(\"GPU\", environment.get(\"gpu\")))\n+    table.add_row(entry(\"CPU cores\", resources.get(\"cpu_count\")))\n+    table.add_row(entry(\"Memory (GB)\", resources.get(\"memory_gb\")))\n+    table.add_row(entry(\"Disk free (GB)\", resources.get(\"disk_free_gb\")))\n+\n+    panel = Panel(table, title=\"Environment summary\", border_style=\"cyan\", expand=True)\n+    return panel\n+\n+\n+def render_run_script(plan: Plan, commands: Iterable[PlannedCommand]) -> str:\n+    \"\"\"Generate a bash script for the execution plan.\"\"\"\n+\n+    lines = [\"#!/usr/bin/env bash\", \"set -euo pipefail\", \"\", \"# Generated from cactus-prepare plan\"]\n+    for command in commands:\n+        lines.append(f\"# {command.display_name}\")\n+        lines.append(shlex.join(command.command))\n+        lines.append(\"\")\n+    script = \"\\n\".join(lines).rstrip() + \"\\n\"\n+    return script\n+\n+\n \n \n class CommandSelectionModal(ModalScreen[CommandTarget | None]):\n@@ -185,6 +280,712 @@ def action_cancel(self) -> None:\n         self.dismiss(None)\n \n \n+class InfoModal(ModalScreen[None]):\n+    \"\"\"Read-only modal for displaying multi-line text.\"\"\"\n+\n+    BINDINGS = [Binding(\"escape\", \"dismiss\", \"Close\"), Binding(\"enter\", \"dismiss\", show=False)]\n+\n+    CSS = \"\"\"\n+    InfoModal {\n+        align: center middle;\n+    }\n+    #info-dialog {\n+        padding: 1 2;\n+        width: 80%;\n+        max-width: 90;\n+        height: 80%;\n+        border: round $accent;\n+        background: $panel;\n+        layout: vertical;\n+    }\n+    #info-title {\n+        padding-bottom: 1;\n+    }\n+    #info-body {\n+        height: 1fr;\n+        overflow-y: auto;\n+    }\n+    #info-hint {\n+        padding-top: 1;\n+        color: $text-muted;\n+    }\n+    \"\"\"\n+\n+    def __init__(self, title: str, body: str):\n+        super().__init__()\n+        self.title = title\n+        self.body = body or \"(empty)\"\n+\n+    def compose(self) -> ComposeResult:\n+        with Container(id=\"info-dialog\"):\n+            yield Static(self.title, id=\"info-title\")\n+            yield Static(self.body, id=\"info-body\")\n+            yield Static(\"Enter / Esc to close\", id=\"info-hint\")\n+\n+    def action_dismiss(self) -> None:\n+        self.dismiss(None)\n+\n+\n+class SearchModal(ModalScreen[str | None]):\n+    \"\"\"Single-line search input modal.\"\"\"\n+\n+    BINDINGS = [Binding(\"escape\", \"cancel\", \"Cancel\")]\n+\n+    CSS = \"\"\"\n+    SearchModal {\n+        align: center middle;\n+    }\n+    #search-dialog {\n+        padding: 1 2;\n+        min-width: 40;\n+        border: round $accent;\n+        background: $panel;\n+    }\n+    #search-title {\n+        padding-bottom: 1;\n+    }\n+    #search-hint {\n+        padding-top: 1;\n+        color: $text-muted;\n+    }\n+    \"\"\"\n+\n+    def __init__(self, initial: str = \"\"):\n+        super().__init__()\n+        self.initial = initial\n+        self._input: Input | None = None\n+\n+    def compose(self) -> ComposeResult:\n+        with Container(id=\"search-dialog\"):\n+            yield Static(\"Enter a node keyword\", id=\"search-title\")\n+            self._input = Input(value=self.initial, placeholder=\"e.g. human / panTro\")\n+            yield self._input\n+            yield Static(\"Enter to confirm, Esc to cancel\", id=\"search-hint\")\n+\n+    def on_mount(self) -> None:\n+        if self._input:\n+            self.set_focus(self._input)\n+\n+    def on_input_submitted(self, event: Input.Submitted) -> None:\n+        self.dismiss(event.value.strip())\n+\n+    def action_cancel(self) -> None:\n+        self.dismiss(None)\n+\n+\n+@dataclass\n+class _DetailCallback:\n+    \"\"\"Wrapper to forward detail updates from AsciiPhylo to the host app.\"\"\"\n+\n+    handler: Optional[Callable[[tree_utils.AlignmentNode, Optional[str]], None]] = None\n+\n+    def __call__(self, node: tree_utils.AlignmentNode, status: Optional[str] = None) -> None:\n+        if self.handler:\n+            self.handler(node, status=status)\n+\n+\n+class AsciiPhylo(Static):\n+    \"\"\"Full-screen ASCII phylogenetic tree widget.\"\"\"\n+\n+    DEFAULT_CSS = \"\"\"\n+    AsciiPhylo {\n+        width: 1fr;\n+        height: 1fr;\n+        border: round $panel-darken-2;\n+        padding: 0 1;\n+        overflow: hidden;\n+        background: $panel;\n+    }\n+    \"\"\"\n+\n+    can_focus = True\n+\n+    BINDINGS = [\n+        Binding(\"up\", \"move_up\", show=False),\n+        Binding(\"down\", \"move_down\", show=False),\n+        Binding(\"left\", \"move_parent\", show=False),\n+        Binding(\"right\", \"move_child\", show=False),\n+        Binding(\"h\", \"move_parent\", show=False),\n+        Binding(\"j\", \"move_down\", show=False),\n+        Binding(\"k\", \"move_up\", show=False),\n+        Binding(\"l\", \"move_child\", show=False),\n+        Binding(\"space\", \"toggle_subtree\", \"Toggle RaMAx\"),\n+        Binding(\"f\", \"focus_here\", \"Focus\"),\n+        Binding(\"b\", \"focus_back\", \"Back\"),\n+        Binding(\"g\", \"toggle_mode\", \"Clado/Phylo\"),\n+        Binding(\"+\", \"zoom_in\", \"Zoom in\"),\n+        Binding(\"-\", \"zoom_out\", \"Zoom out\"),\n+        Binding(\"/\", \"open_search\", \"Search\"),\n+        Binding(\"n\", \"search_next\", show=False),\n+        Binding(\"shift+n\", \"search_prev\", show=False),\n+        Binding(\"a\", \"toggle_ascii\", \"ASCII mode\"),\n+    ]\n+\n+    def __init__(self, root: tree_utils.AlignmentNode, *, id: str = \"ascii-phylo\"):\n+        super().__init__(\"\", id=id)\n+        self._root = root\n+        self._cursor = root\n+        self._stack: list[tree_utils.AlignmentNode] = []\n+        self._mode = \"clado\"\n+        self._ascii_only = False\n+        self._scale_x = 1.0\n+        self._y_gap = 2\n+        self._view_x = 0\n+        self._view_y = 0\n+        self._ordered_children: dict[tree_utils.AlignmentNode, list[tree_utils.AlignmentNode]] = {}\n+        self._y_map: dict[tree_utils.AlignmentNode, float] = {}\n+        self._x_map: dict[tree_utils.AlignmentNode, int] = {}\n+        self._linear: list[tree_utils.AlignmentNode] = []\n+        self._state_cache: dict[tree_utils.AlignmentNode, str] = {}\n+        self._search_term: Optional[str] = None\n+        self._hits: list[tree_utils.AlignmentNode] = []\n+        self._hit_index = 0\n+        self._detail_callback = _DetailCallback()\n+        self._content_width = 0\n+        self._content_height = 0\n+        self._visual = Text()\n+\n+    def set_detail_callback(\n+        self,\n+        callback: Optional[Callable[[tree_utils.AlignmentNode, Optional[str]], None]],\n+    ) -> None:\n+        self._detail_callback.handler = callback\n+\n+    def current_node(self) -> tree_utils.AlignmentNode:\n+        return self._cursor\n+\n+    def on_mount(self) -> None:\n+        self.focus()\n+        self._layout()\n+\n+    def on_resize(self, event: events.Resize) -> None:  # type: ignore[override]\n+        self._rebuild_visual()\n+        self.refresh()\n+\n+    def action_move_up(self) -> None:\n+        self._move_cursor(-1)\n+\n+    def action_move_down(self) -> None:\n+        self._move_cursor(+1)\n+\n+    def action_move_parent(self) -> None:\n+        parent = getattr(self._cursor, \"parent\", None)\n+        if parent:\n+            self._set_cursor(parent, ensure_visible=True)\n+\n+    def action_move_child(self) -> None:\n+        children = self._ordered_children.get(self._cursor, self._cursor.children)\n+        if not children:\n+            return\n+        for child in children:\n+            if not self._is_species_leaf(child):\n+                self._set_cursor(child, ensure_visible=True)\n+                return\n+        self._notify(self._cursor, \"Only species leaves under this node.\")\n+\n+    def action_toggle_subtree(self) -> None:\n+        rounds = list(self._cursor.iter_rounds())\n+        if not rounds:\n+            self._notify(self._cursor, \"No rounds in this subtree can be toggled.\")\n+            return\n+        target_state = not all(r.replace_with_ramax for r in rounds)\n+        for round_entry in rounds:\n+            round_entry.replace_with_ramax = target_state\n+        message = (\n+            f\"Toggled {len(rounds)} round(s) to RaMAx\"\n+            if target_state\n+            else f\"Restored {len(rounds)} round(s) to cactus\"\n+        )\n+        self._rebuild_visual()\n+        self.refresh()\n+        self._notify(self._cursor, message)\n+\n+    def action_focus_here(self) -> None:\n+        if self._cursor is self._root:\n+            return\n+        self._stack.append(self._root)\n+        self._root = self._cursor\n+        self._layout()\n+        self._notify(self._cursor, \"Focused on this subtree.\")\n+\n+    def action_focus_back(self) -> None:\n+        if not self._stack:\n+            return\n+        self._root = self._stack.pop()\n+        self._layout()\n+        self._notify(self._cursor, \"Returned to previous view.\")\n+\n+    def action_toggle_mode(self) -> None:\n+        self._mode = \"phylo\" if self._mode == \"clado\" else \"clado\"\n+        self._layout()\n+        self._notify(self._cursor, f\"Switched to {self._mode} mode.\")\n+\n+    def action_zoom_in(self) -> None:\n+        self._scale_x = min(8.0, self._scale_x * 1.2)\n+        self._layout()\n+\n+    def action_zoom_out(self) -> None:\n+        self._scale_x = max(0.3, self._scale_x / 1.2)\n+        self._layout()\n+\n+    def action_toggle_ascii(self) -> None:\n+        self._ascii_only = not self._ascii_only\n+        self._rebuild_visual()\n+        self.refresh()\n+        self._notify(self._cursor, \"ASCII mode enabled\" if self._ascii_only else \"Box drawing restored.\")\n+\n+    def action_open_search(self) -> None:\n+        prompt = SearchModal(self._search_term or \"\")\n+        self.app.push_screen(prompt, self._apply_search_term)\n+\n+    def action_search_next(self) -> None:\n+        self._jump_hit(+1)\n+\n+    def action_search_prev(self) -> None:\n+        self._jump_hit(-1)\n+\n+    def _apply_search_term(self, term: str | None) -> None:\n+        if term is None:\n+            return\n+        cleaned = term.strip().lower()\n+        if not cleaned:\n+            self._search_term = None\n+            self._hits.clear()\n+            self._rebuild_visual()\n+            self.refresh()\n+            return\n+        self._search_term = cleaned\n+        self._hits = [\n+            node for node in self._linear if cleaned in (node.name or \"\").lower()\n+        ]\n+        self._hit_index = 0\n+        if self._hits:\n+            self._set_cursor(self._hits[0], ensure_visible=True)\n+            self._notify(self._cursor, f\"Found {len(self._hits)} match(es).\")\n+        else:\n+            self._notify(self._cursor, \"No matching nodes found.\")\n+\n+    def _jump_hit(self, delta: int) -> None:\n+        if not self._hits:\n+            return\n+        self._hit_index = (self._hit_index + delta) % len(self._hits)\n+        self._set_cursor(self._hits[self._hit_index], ensure_visible=True)\n+\n+    def _is_species_leaf(self, node: tree_utils.AlignmentNode) -> bool:\n+        return not node.children and node.round is None\n+\n+    def _collect_subtree_nodes(self, node: tree_utils.AlignmentNode) -> set[tree_utils.AlignmentNode]:\n+        nodes: set[tree_utils.AlignmentNode] = set()\n+        stack = [node]\n+        while stack:\n+            current = stack.pop()\n+            if current in nodes:\n+                continue\n+            nodes.add(current)\n+            for child in self._ordered_children.get(current, current.children):\n+                stack.append(child)\n+        return nodes\n+\n+    def _collect_round_nodes(self, node: tree_utils.AlignmentNode) -> set[tree_utils.AlignmentNode]:\n+        if node is None:\n+            return set()\n+        return {candidate for candidate in self._collect_subtree_nodes(node) if candidate.round}\n+\n+    def _move_cursor(self, delta: int) -> None:\n+        if not self._linear:\n+            return\n+        try:\n+            index = self._linear.index(self._cursor)\n+        except ValueError:\n+            index = 0\n+        direction = 1 if delta >= 0 else -1\n+        next_index = max(0, min(len(self._linear) - 1, index + delta))\n+        while 0 <= next_index < len(self._linear):\n+            candidate = self._linear[next_index]\n+            if not self._is_species_leaf(candidate):\n+                self._set_cursor(candidate, ensure_visible=True)\n+                return\n+            next_index += direction\n+\n+    def _set_cursor(self, node: tree_utils.AlignmentNode, ensure_visible: bool = False) -> None:\n+        self._cursor = node\n+        if ensure_visible:\n+            self._ensure_visible(node)\n+        self._rebuild_visual()\n+        self.refresh()\n+        self._notify(node)\n+\n+    def _notify(self, node: tree_utils.AlignmentNode, status: Optional[str] = None) -> None:\n+        self._detail_callback(node, status=status)\n+\n+    def _layout(self) -> None:\n+        if not self._root:\n+            self.update(\"No tree structure found\")\n+            return\n+        size_map: dict[tree_utils.AlignmentNode, int] = {}\n+\n+        def compute_size(node: tree_utils.AlignmentNode) -> int:\n+            total = 1\n+            for child in node.children:\n+                total += compute_size(child)\n+            size_map[node] = total\n+            return total\n+\n+        compute_size(self._root)\n+\n+        self._ordered_children.clear()\n+\n+        def order_children(node: tree_utils.AlignmentNode) -> None:\n+            ordered = sorted(\n+                node.children,\n+                key=lambda c: size_map.get(c, 1),\n+                reverse=True,\n+            )\n+            self._ordered_children[node] = ordered\n+            for child in ordered:\n+                order_children(child)\n+\n+        order_children(self._root)\n+\n+        self._y_map.clear()\n+        self._x_map.clear()\n+        self._linear.clear()\n+\n+        leaf_index = 0\n+\n+        def assign_y(node: tree_utils.AlignmentNode) -> float:\n+            nonlocal leaf_index\n+            children = self._ordered_children.get(node, [])\n+            if not children:\n+                self._y_map[node] = float(leaf_index * self._y_gap)\n+                leaf_index += 1\n+                return self._y_map[node]\n+            child_ys = [assign_y(child) for child in children]\n+            top = min(child_ys)\n+            bottom = max(child_ys)\n+            self._y_map[node] = (top + bottom) / 2\n+            return self._y_map[node]\n+\n+        assign_y(self._root)\n+\n+        step = max(3, int(6 * self._scale_x))\n+        self._x_map[self._root] = 0\n+\n+        def assign_x(node: tree_utils.AlignmentNode) -> None:\n+            base = self._x_map[node]\n+            children = self._ordered_children.get(node, [])\n+            for child in children:\n+                if self._mode == \"phylo\":\n+                    increment = child.length if child.length is not None else 1.0\n+                    increment = max(0.1, increment)\n+                else:\n+                    increment = 2.0\n+                delta = max(2, int(increment * step))\n+                self._x_map[child] = base + delta\n+                assign_x(child)\n+\n+        assign_x(self._root)\n+\n+        self._linear = sorted(\n+            self._y_map.keys(),\n+            key=lambda node: (self._y_map[node], self._x_map.get(node, 0)),\n+        )\n+        if self._cursor not in self._linear:\n+            self._cursor = self._root\n+        self._content_width = max(self._x_map.values(), default=0) + 40\n+        max_y = math.ceil(max(self._y_map.values(), default=0))\n+        self._content_height = max_y + 10\n+        self._ensure_visible(self._cursor)\n+        self._rebuild_visual()\n+        self.refresh()\n+\n+    def _ensure_visible(self, node: tree_utils.AlignmentNode) -> None:\n+        width = max(40, self.size.width - 2)\n+        height = max(10, self.size.height - 2)\n+        x = self._x_map.get(node, 0)\n+        y = int(round(self._y_map.get(node, 0)))\n+        margin = 2\n+        if x < self._view_x + margin:\n+            self._view_x = max(0, x - margin)\n+        elif x >= self._view_x + width - margin:\n+            self._view_x = x - (width - margin - 1)\n+        if y < self._view_y + margin:\n+            self._view_y = max(0, y - margin)\n+        elif y >= self._view_y + height - margin:\n+            self._view_y = y - (height - margin - 1)\n+        max_x = max(0, self._content_width - width)\n+        max_y = max(0, self._content_height - height)\n+        self._view_x = max(0, min(self._view_x, max_x))\n+        self._view_y = max(0, min(self._view_y, max_y))\n+\n+    def _glyphs(self) -> dict[str, str]:\n+        if self._ascii_only:\n+            return {\n+                \"h\": \"-\",\n+                \"v\": \"|\",\n+                \"tee\": \"+\",\n+                \"elbow\": \"+\",\n+                \"top\": \"+\",\n+                \"dot\": \"*\",\n+                \"lite\": \"o\",\n+                \"parent\": \"O\",\n+            }\n+        return {\n+            \"h\": \"─\",\n+            \"v\": \"│\",\n+            \"tee\": \"├\",\n+            \"elbow\": \"└\",\n+            \"top\": \"┌\",\n+            \"dot\": \"●\",\n+            \"lite\": \"◇\",\n+            \"parent\": \"◎\",\n+        }\n+\n+    def _compute_states(self) -> None:\n+        self._state_cache.clear()\n+\n+        def helper(current: tree_utils.AlignmentNode) -> str:\n+            children = self._ordered_children.get(current, current.children)\n+            child_states = [helper(child) for child in children]\n+            child_has_round = any(state != \"leaf\" for state in child_states)\n+            descendant_enabled = any(state in (\"checked\", \"mixed\") for state in child_states)\n+\n+            if current.round:\n+                if current.round.replace_with_ramax:\n+                    result = \"checked\"\n+                elif descendant_enabled:\n+                    result = \"mixed\"\n+                else:\n+                    result = \"unchecked\"\n+            else:\n+                if not child_has_round:\n+                    result = \"leaf\"\n+                elif descendant_enabled:\n+                    result = \"mixed\"\n+                else:\n+                    result = \"unchecked\"\n+            self._state_cache[current] = result\n+            return result\n+\n+        helper(self._root)\n+\n+    def _node_state(self, node: tree_utils.AlignmentNode) -> str:\n+        return self._state_cache.get(node, \"leaf\")\n+\n+    def _state_color(self, node: tree_utils.AlignmentNode) -> str:\n+        state = self._node_state(node)\n+        if state == \"checked\":\n+            return \"#2ecc71\"\n+        if state == \"mixed\":\n+            return \"#f39c12\"\n+        if state == \"unchecked\":\n+            return \"#94a3b8\"\n+        return \"#aeb8cc\"\n+\n+    def _connector_highlight(self, parent_kind: str | None, child_kind: str | None) -> str | None:\n+        if parent_kind == \"ramax\" and child_kind == \"ramax\":\n+            return \"ramax\"\n+        if parent_kind == \"selected\" or child_kind == \"selected\":\n+            return \"selected\"\n+        return None\n+\n+    def _rebuild_visual(self) -> None:\n+        if not self._y_map:\n+            self._visual = Text(\"\")\n+            return\n+        self._compute_states()\n+        width = max(40, self.size.width - 2)\n+        height = max(10, self.size.height - 2)\n+        glyphs = self._glyphs()\n+        grid = [[\" \" for _ in range(width)] for _ in range(height)]\n+        styles = [[\"\" for _ in range(width)] for _ in range(height)]\n+        label_margin = 2\n+\n+        selected_highlight: set[tree_utils.AlignmentNode] = set()\n+        if self._cursor:\n+            selected_highlight = self._collect_round_nodes(self._cursor)\n+        ramax_highlight: set[tree_utils.AlignmentNode] = {\n+            node\n+            for node in self._y_map.keys()\n+            if node.round and node.round.replace_with_ramax\n+        }\n+\n+        def highlight_kind(node: tree_utils.AlignmentNode) -> str | None:\n+            if node in selected_highlight:\n+                return \"selected\"\n+            if node in ramax_highlight:\n+                return \"ramax\"\n+            return None\n+\n+        def highlight_color(kind: str | None, default: str) -> str:\n+            if kind == \"ramax\":\n+                return \"#fcbf49\"\n+            if kind == \"selected\":\n+                return \"#4cc9f0\"\n+            return default\n+\n+        def draw_char(x: int, y: int, ch: str, style: str = \"\") -> None:\n+            vx = x - self._view_x\n+            vy = y - self._view_y\n+            if 0 <= vx < width and 0 <= vy < height:\n+                grid[vy][vx] = ch\n+                styles[vy][vx] = style\n+\n+        def draw_branch(parent: tree_utils.AlignmentNode) -> None:\n+            px = self._x_map[parent]\n+            py = int(round(self._y_map[parent]))\n+            children = self._ordered_children.get(parent, [])\n+            if children:\n+                child_ys = [int(round(self._y_map[child])) for child in children]\n+                y0, y1 = min(child_ys), max(child_ys)\n+                parent_kind = highlight_kind(parent)\n+                vertical_style = highlight_color(parent_kind, \"#3c445c\")\n+                for y in range(y0, y1 + 1):\n+                    draw_char(px, y, glyphs[\"v\"], vertical_style)\n+                last_index = len(children) - 1\n+                for index, child in enumerate(children):\n+                    cx = self._x_map[child]\n+                    cy = int(round(self._y_map[child]))\n+                    if len(children) == 1:\n+                        joint = glyphs[\"elbow\"]\n+                    elif index == 0:\n+                        joint = glyphs.get(\"top\", glyphs[\"tee\"])\n+                    elif index == last_index:\n+                        joint = glyphs[\"elbow\"]\n+                    else:\n+                        joint = glyphs[\"tee\"]\n+                    child_kind = highlight_kind(child)\n+                    joint_kind = self._connector_highlight(parent_kind, child_kind)\n+                    connector_style = highlight_color(joint_kind, vertical_style)\n+                    draw_char(px, cy, joint, connector_style)\n+                    for x in range(min(px + 1, cx), cx + 1):\n+                        draw_char(x, cy, glyphs[\"h\"], connector_style)\n+                    if self._mode == \"clado\" and child.length is not None:\n+                        text = f\"{child.length:.3f}\"\n+                        available = max(0, cx - px - 1)\n+                        if available >= len(text):\n+                            start = px + 1 + max(0, (available - len(text)) // 2)\n+                            start = min(start, cx - len(text))\n+                            for offset, ch in enumerate(text):\n+                                draw_char(start + offset, cy, ch, \"#6b768f\")\n+                    draw_branch(child)\n+            style = \"#ffffff\" if parent is self._cursor else self._state_color(parent)\n+            style = highlight_color(highlight_kind(parent), style)\n+            support = parent.support if parent.support is not None else 100.0\n+            if parent.children:\n+                node_char = glyphs.get(\"parent\", \"◎\")\n+            else:\n+                node_char = glyphs[\"dot\"] if support >= 70 else glyphs[\"lite\"]\n+            draw_char(px, py, node_char, style)\n+            label = parent.name or \"(unnamed)\"\n+            label = f\"> {label}\" if parent is self._cursor else f\"  {label}\"\n+            x0 = px + label_margin\n+            for offset, ch in enumerate(label):\n+                draw_char(x0 + offset, py, ch, style)\n+\n+        draw_branch(self._root)\n+        lines: list[Text] = []\n+        for row_chars, row_styles in zip(grid, styles):\n+            line = Text()\n+            for ch, style in zip(row_chars, row_styles):\n+                if style:\n+                    line.append(ch, style=style)\n+                else:\n+                    line.append(ch)\n+            line.rstrip()\n+            lines.append(line)\n+        rendered = Text(\"\\n\").join(lines)\n+        self._visual = rendered\n+\n+    def render(self) -> Text:  # type: ignore[override]\n+        return self._visual\n+\n+\n+class RoundPickerModal(ModalScreen[int | None]):\n+    \"\"\"Modal dialog for picking a round when no node is focused.\"\"\"\n+\n+    BINDINGS = [Binding(\"escape\", \"cancel\", \"Cancel\")]\n+\n+    CSS = \"\"\"\n+    RoundPickerModal {\n+        align: center middle;\n+    }\n+    #round-picker {\n+        padding: 1 2;\n+        width: 70%;\n+        max-width: 80;\n+        border: round $accent;\n+        background: $panel;\n+    }\n+    #round-picker-list {\n+        height: auto;\n+        max-height: 24;\n+    }\n+    #round-picker-hint {\n+        padding-top: 1;\n+        color: $text-muted;\n+    }\n+    \"\"\"\n+\n+    def __init__(self, rounds: list[Round]):\n+        super().__init__()\n+        self.rounds = rounds\n+        self._list: ListView | None = None\n+\n+    def compose(self) -> ComposeResult:\n+        with Container(id=\"round-picker\"):\n+            items = []\n+            for round_entry in self.rounds:\n+                label = Text(round_entry.name, style=\"bold\")\n+                label.append(f\" ({round_entry.root})\")\n+                label.append(\"\\n\")\n+                label.append(round_entry.target_hal)\n+                items.append(ListItem(Static(label, expand=True)))\n+            self._list = ListView(*items, id=\"round-picker-list\")\n+            yield self._list\n+            yield Static(\"Enter to confirm, Esc to cancel\", id=\"round-picker-hint\")\n+\n+    def on_mount(self) -> None:\n+        if self._list:\n+            self._list.index = 0\n+            self.set_focus(self._list)\n+\n+    def on_list_view_selected(self, event: ListView.Selected) -> None:\n+        self.dismiss(event.index)\n+\n+    def action_cancel(self) -> None:\n+        self.dismiss(None)\n+\n+\n+class DetailBuffer:\n+    \"\"\"Stores the latest detail text and mirrors a short summary to the subtitle.\"\"\"\n+\n+    def __init__(self, app: \"PlanUIApp\"):\n+        self.app = app\n+        self.text: str = \"\"\n+        self.renderable: RenderableType | str = \"\"\n+\n+    def update(self, message: RenderableType | str) -> None:\n+        self.renderable = message\n+        if isinstance(message, str):\n+            plain = message\n+        else:\n+            # Render rich content into plain text for later inspection.\n+            temp_console = Console(width=120, record=True, color_system=None)\n+            with temp_console.capture() as capture:\n+                temp_console.print(message)\n+            plain = capture.get()\n+        self.text = plain\n+        summary = plain.splitlines()[0] if plain else \"\"\n+        if summary:\n+            try:\n+                summary_plain = Text.from_markup(summary).plain\n+            except Exception:\n+                summary_plain = summary\n+        else:\n+            summary_plain = \"\"\n+        self.app.sub_title = summary_plain[:80]\n+\n class RunSettingsScreen(Screen[RunSettings | None]):\n     \"\"\"Dedicated screen for confirming run-time configuration.\"\"\"\n \n@@ -277,7 +1078,7 @@ def compose(self) -> ComposeResult:\n             with Container(id=\"run-body\"):\n                 summary = Static(id=\"run-summary\")\n                 self._summary = summary\n-                summary.update(render.plan_overview(self.plan, run_settings=self.current, compact=self.compact))\n+                summary.update(plan_overview(self.plan, run_settings=self.current, compact=self.compact))\n                 yield summary\n                 with Container(id=\"run-form\"):\n                     yield Static(\"• Tab/Shift+Tab to move between controls\\n• Ctrl+Enter to run immediately\\n• V toggles verbose logging\", id=\"run-instructions\")\n@@ -300,6 +1101,7 @@ def compose(self) -> ComposeResult:\n                     self._status = status\n                     yield status\n                     with Container(id=\"run-buttons\"):\n+                        yield Button(\"Save command list\", id=\"run-save\")\n                         yield Button(\"Run plan (Ctrl+Enter)\", id=\"run-confirm\", variant=\"success\")\n                         yield Button(\"Back to plan (Esc)\", id=\"run-cancel\")\n         yield Footer()\n@@ -356,11 +1158,26 @@ def on_checkbox_changed(self, event: Checkbox.Changed) -> None:\n             self._refresh_summary()\n \n     def on_button_pressed(self, event: Button.Pressed) -> None:\n-        if event.button.id == \"run-confirm\":\n+        if event.button.id == \"run-save\":\n+            self._handle_save_commands()\n+        elif event.button.id == \"run-confirm\":\n             self.action_save()\n         elif event.button.id == \"run-cancel\":\n             self.action_cancel()\n \n+    def _handle_save_commands(self) -> None:\n+        app = self.app\n+        if not isinstance(app, PlanUIApp):\n+            self._update_status(\"Cannot save commands: unknown host app\")\n+            return\n+        settings = self._current_settings_preview()\n+        path = app.export_commands(settings, notify_detail=False)\n+        if path:\n+            path_str = str(path)\n+            self._update_status(f\"Commands saved to {path_str}\")\n+        else:\n+            self._update_status(\"Failed to save commands\")\n+\n     def _current_settings_preview(self) -> RunSettings:\n         verbose = self._verbose.value if self._verbose else self.current.verbose\n         ok, threads, _ = self._validate_threads()\n@@ -372,7 +1189,7 @@ def _refresh_summary(self) -> None:\n             return\n         settings = self._current_settings_preview()\n         self._summary.update(\n-            render.plan_overview(self.plan, run_settings=settings, compact=self.compact)\n+            plan_overview(self.plan, run_settings=settings, compact=self.compact)\n         )\n \n \n@@ -540,286 +1357,136 @@ def on_button_pressed(self, event: Button.Pressed) -> None:\n             return\n         self._refresh_inputs()\n \n-class RoundListItem(ListItem):\n-    \"\"\"List item reflecting a round with RaMAx toggle.\"\"\"\n-\n-    def __init__(self, round_entry: Round, index: int):\n-        self.round_entry = round_entry\n-        self.index = index\n-        super().__init__(Static(self._text(), expand=True))\n-\n-    def _text(self) -> str:\n-        status = \"[x]\" if self.round_entry.replace_with_ramax else \"[ ]\"\n-        return f\"{status} {self.round_entry.name} ({self.round_entry.root})\\n→ {self.round_entry.target_hal}\"\n-\n-    def update_content(self) -> None:\n-        static = self.query_one(Static)\n-        static.update(self._text())\n-\n-\n-class AlignmentTreeWidget(Tree[tree_utils.AlignmentNode]):\n-    \"\"\"Tree widget with modified key bindings to cooperate with the global space toggle.\"\"\"\n-\n-    BINDINGS = [\n-        binding\n-        for binding in Tree.BINDINGS\n-        if binding.key != \"space\"\n-    ] + [\n-        Binding(\"space\", \"toggle_subtree\", \"Toggle subtree\", show=False),\n-        Binding(\"ctrl+space\", \"toggle_node\", \"Expand/Collapse\", show=False),\n-    ]\n-\n-    def action_toggle_subtree(self) -> None:\n-        toggle_action = getattr(self.app, \"action_toggle_round\", None)\n-        if callable(toggle_action):\n-            toggle_action()\n-\n-\n class PlanUIApp(App[UIResult]):\n     CSS = \"\"\"\n     Screen {\n         layout: vertical;\n         min-height: 0;\n     }\n     #main {\n-        layout: horizontal;\n         width: 100%;\n         height: 1fr;\n         min-height: 0;\n+        padding: 0 1;\n     }\n-    #main > * {\n-        min-width: 0;\n-        min-height: 0;\n-    }\n-    #rounds {\n-        width: 45%;\n-        min-width: 32;\n-        height: 1fr;\n-    }\n-    #details {\n-        width: 55%;\n-        padding: 1 2;\n-        overflow-y: auto;\n-        layout: vertical;\n-        height: 1fr;\n-        min-width: 0;\n-        min-height: 0;\n-    }\n-    #environment-summary {\n+    #ascii-phylo, #ascii-phylo-empty {\n         width: 100%;\n+        height: 1fr;\n     }\n-    #plan-overview {\n-        width: 100%;\n-        margin-top: 1;\n+    #ascii-phylo-empty {\n+        align: center middle;\n+        color: $text-muted;\n     }\n-    /* TextArea size within the edit modal */\n     #editor-command { height: 10; }\n     \"\"\"\n \n     BINDINGS = [\n-        Binding(\"space\", \"toggle_round\", \"Toggle subtree\"),\n         Binding(\"e\", \"edit_round\", \"Edit command\"),\n-        Binding(\"p\", \"preview_plan\", \"Preview\"),\n-        Binding(\"s\", \"save_commands\", \"Save commands\"),\n         Binding(\"r\", \"run_plan\", \"Run\"),\n         Binding(\"q\", \"quit\", \"Quit\"),\n+        Binding(\"i\", \"show_info\", \"Info\"),\n     ]\n \n     def __init__(self, plan: Plan, base_dir: Optional[Path] = None, run_settings: Optional[RunSettings] = None):\n         super().__init__()\n         self.plan = plan\n         self.base_dir = Path(base_dir) if base_dir else Path.cwd()\n         self.alignment_tree = tree_utils.build_alignment_tree(plan, base_dir=self.base_dir)\n-        self.tree_widget: AlignmentTreeWidget | None = None\n-        self.round_items: list[RoundListItem] = []\n-        self.round_list: ListView | None = None\n-        self.detail_panel: Static | None = None\n-        self._environment_card: Static | None = None\n+        self.canvas: AsciiPhylo | None = None\n+        self.detail_panel: DetailBuffer | None = None\n         self.run_settings = run_settings or RunSettings()\n \n     def compose(self) -> ComposeResult:\n         yield Header()\n         with Container(id=\"main\"):\n             if self.alignment_tree:\n-                root_node = self.alignment_tree.root\n-                tree_widget = AlignmentTreeWidget(\n-                    self._format_node_label(root_node),\n-                    data=root_node,\n-                    id=\"rounds\",\n-                )\n-                self.tree_widget = tree_widget\n-                self._populate_tree(tree_widget.root, root_node)\n-                self._refresh_tree_labels(tree_widget.root)\n-                yield tree_widget\n+                canvas = AsciiPhylo(self.alignment_tree.root)\n+                canvas.set_detail_callback(self._show_alignment_node)\n+                self.canvas = canvas\n+                yield canvas\n             else:\n-                self.round_items = [\n-                    RoundListItem(round_entry, idx)\n-                    for idx, round_entry in enumerate(self.plan.rounds)\n-                ]\n-                list_view = ListView(*self.round_items, id=\"rounds\")\n-                self.round_list = list_view\n-                yield list_view\n-            environment_card = Static(\n-                render.environment_summary_card(\n-                    detectors.environment_summary(),\n-                    detectors.system_resources(),\n-                ),\n-                id=\"environment-summary\",\n-            )\n-            self._environment_card = environment_card\n-            with Container(id=\"details\"):\n-                yield environment_card\n-                detail = Static(\n-                    render.plan_overview(self.plan, run_settings=self.run_settings, compact=self._is_compact()),\n-                    id=\"plan-overview\",\n-                )\n-                self.detail_panel = detail\n-                yield detail\n+                yield Static(\"Alignment tree not found; nothing to render.\", id=\"ascii-phylo-empty\")\n         yield Footer()\n \n     def on_mount(self) -> None:\n-        if self.tree_widget and self.alignment_tree:\n-            if self.size.width > 120:\n-                self.tree_widget.root.expand_all()\n-            self.tree_widget.move_cursor(self.tree_widget.root, animate=False)\n-            self.set_focus(self.tree_widget)\n-            self._show_alignment_node(self.alignment_tree.root)\n-        elif self.round_list and self.round_items:\n-            self.round_list.index = 0\n-            self._show_round(0)\n-        self._apply_env_visibility()\n-\n-    def watch_size(self, size: Size) -> None:  # type: ignore[override]\n-        self._apply_env_visibility()\n+        self.detail_panel = DetailBuffer(self)\n+        if self.canvas:\n+            self.canvas.focus()\n+            self._show_alignment_node(self.canvas.current_node())\n+        else:\n+            preview = plan_overview(self.plan, run_settings=self.run_settings, compact=self._is_compact())\n+            self.detail_panel.update(preview)\n \n     def _is_compact(self) -> bool:\n-        return self.size.width <= 110\n+        return self.size.width <= 100\n \n-    def action_toggle_round(self) -> None:\n-        if self.alignment_tree and self.tree_widget:\n-            node = self._selected_alignment_node()\n-            if node is None:\n-                return\n-            rounds = list(node.iter_rounds())\n-            if not rounds:\n-                if self.detail_panel:\n-                    self.detail_panel.update(\"This node has no cactus steps that can be replaced.\")\n-                return\n-            target_state = not all(round_entry.replace_with_ramax for round_entry in rounds)\n-            for round_entry in rounds:\n-                round_entry.replace_with_ramax = target_state\n-            self._refresh_tree_labels(self.tree_widget.root)\n-            status = (\n-                f\"Switched {len(rounds)} rounds in this subtree to RaMAx\"\n-                if target_state\n-                else f\"Restored {len(rounds)} rounds in this subtree to cactus\"\n-            )\n-            self._show_alignment_node(node, status=status)\n+    def action_show_info(self) -> None:\n+        if not self.detail_panel:\n+            return\n+        content = self.detail_panel.text or \"(empty)\"\n+        self.push_screen(InfoModal(\"Current node details\", content))\n+\n+    def action_edit_round(self) -> None:\n+        if not self.plan.rounds:\n+            if self.detail_panel:\n+                self.detail_panel.update(\"No rounds found in this plan.\")\n+            return\n+        node_round = None\n+        if self.canvas:\n+            node = self.canvas.current_node()\n+            node_round = node.round\n+        if node_round and node_round in self.plan.rounds:\n+            round_index = self.plan.rounds.index(node_round)\n+            self._start_round_edit(round_index)\n             return\n+        picker = RoundPickerModal(self.plan.rounds)\n+        self.push_screen(picker, self._handle_round_pick)\n \n-        if not self.round_list:\n+    def _handle_round_pick(self, index: int | None) -> None:\n+        if index is None:\n             return\n-        index = self.round_list.index or 0\n         if index >= len(self.plan.rounds):\n             return\n-        round_entry = self.plan.rounds[index]\n-        round_entry.replace_with_ramax = not round_entry.replace_with_ramax\n-        self.round_items[index].update_content()\n-        status = \"Switched to RaMAx\" if round_entry.replace_with_ramax else \"Restored to cactus\"\n-        self._show_round(index, status=status)\n-\n-    def action_preview_plan(self) -> None:\n-        if self.detail_panel:\n-            preview = render.plan_overview(self.plan, run_settings=self.run_settings, compact=self._is_compact())\n-            self.detail_panel.update(preview)\n+        self._start_round_edit(index)\n+\n+    def _start_round_edit(self, round_index: int) -> None:\n+        round_entry = self.plan.rounds[round_index]\n+        targets = self._gather_command_targets(round_entry)\n+        if not targets:\n+            if self.detail_panel:\n+                self.detail_panel.update(\"No editable commands for this round.\")\n+            return\n+        if len(targets) == 1:\n+            self._open_command_editor(round_index, targets[0])\n+        else:\n+            self.push_screen(\n+                CommandSelectionModal(targets),\n+                lambda target: self._handle_command_selection(round_index, target),\n+            )\n+        self._show_round(round_index)\n \n     def action_run_plan(self) -> None:\n         screen = RunSettingsScreen(self.plan, self.run_settings, compact=self._is_compact())\n         self.push_screen(screen, self._finalize_run_settings)\n \n-    def action_save_commands(self) -> None:\n+    def export_commands(self, settings: RunSettings | None = None, *, notify_detail: bool = True) -> Path | None:\n         output_dir = Path(self.plan.out_dir or self.base_dir)\n         output_dir.mkdir(parents=True, exist_ok=True)\n         output_path = output_dir / \"ramax_commands.txt\"\n         commands = planner.build_execution_plan(\n             self.plan,\n             self.base_dir,\n-            thread_count=self.run_settings.thread_count,\n+            thread_count=(settings.thread_count if settings else self.run_settings.thread_count),\n         )\n         lines = [cmd.shell_preview() for cmd in commands]\n         output_path.write_text(\"\\n\".join(lines) + \"\\n\", encoding=\"utf-8\")\n-        if self.detail_panel:\n-            self.detail_panel.update(f\"Commands saved to {output_path}\")\n+        if notify_detail and self.detail_panel:\n+            self.detail_panel.update(f\"[green]Commands saved to {output_path}[/green]\")\n+        return output_path\n \n     def action_quit(self) -> None:\n         self.exit(UIResult(plan=self.plan, action=\"quit\", run_settings=self.run_settings))\n \n-    def _apply_env_visibility(self) -> None:\n-        if not self._environment_card:\n-            return\n-        self._environment_card.display = self.size.width > 110\n-\n-    def action_edit_round(self) -> None:\n-        if self.alignment_tree and self.tree_widget:\n-            node = self._selected_alignment_node()\n-            if node is None or node.round is None:\n-                if self.detail_panel:\n-                    self.detail_panel.update(\"Select a node with cactus rounds before pressing E.\")\n-                return\n-            try:\n-                round_index = self.plan.rounds.index(node.round)\n-            except ValueError:\n-                return\n-            targets = self._gather_command_targets(node.round)\n-            if not targets:\n-                if self.detail_panel:\n-                    self.detail_panel.update(\"No editable commands in this node.\")\n-                return\n-            if len(targets) == 1:\n-                self._open_command_editor(round_index, targets[0])\n-            else:\n-                self.push_screen(\n-                    CommandSelectionModal(targets),\n-                    lambda target: self._handle_command_selection(round_index, target),\n-                )\n-            return\n-\n-        if not self.round_list:\n-            return\n-        index = self.round_list.index or 0\n-        if index >= len(self.plan.rounds):\n-            return\n-        round_entry = self.plan.rounds[index]\n-        targets = self._gather_command_targets(round_entry)\n-        if not targets:\n-            if self.detail_panel:\n-                self.detail_panel.update(\"No editable commands for this round.\")\n-            return\n-        if len(targets) == 1:\n-            self._open_command_editor(index, targets[0])\n-        else:\n-            self.push_screen(\n-                CommandSelectionModal(targets),\n-                lambda target: self._handle_command_selection(index, target),\n-            )\n-\n-    def on_list_view_selected(self, event: ListView.Selected) -> None:\n-        self._show_round(event.index)\n-\n-    def on_alignmenttreewidget_node_highlighted(\n-        self, event: AlignmentTreeWidget.NodeHighlighted\n-    ) -> None:\n-        node = event.node.data\n-        if node is not None:\n-            self._show_alignment_node(node)\n-\n-    def on_alignmenttreewidget_node_selected(\n-        self, event: AlignmentTreeWidget.NodeSelected\n-    ) -> None:\n-        node = event.node.data\n-        if node is not None:\n-            self._show_alignment_node(node)\n-\n     def _round_details(self, round_entry: Round) -> list[str]:\n         details = [f\"[bold]{round_entry.name}[/bold] root={round_entry.root}\"]\n         if round_entry.replace_with_ramax:\n@@ -940,72 +1607,6 @@ def _show_alignment_node(\n             details.extend([\"\", f\"[green]{status}[/green]\"])\n         self.detail_panel.update(\"\\n\".join(details))\n \n-    def _selected_alignment_node(self) -> tree_utils.AlignmentNode | None:\n-        if not self.tree_widget:\n-            return None\n-        cursor = self.tree_widget.cursor_node\n-        return cursor.data if cursor is not None else None\n-\n-    def _find_node_for_round(self, round_entry: Round) -> tree_utils.AlignmentNode | None:\n-        if not self.alignment_tree:\n-            return None\n-        return self.alignment_tree.find(round_entry.root)\n-\n-    def _populate_tree(\n-        self,\n-        tree_node,\n-        alignment_node: tree_utils.AlignmentNode,\n-    ) -> None:\n-        for child in alignment_node.children:\n-            label = self._format_node_label(child)\n-            child_node = tree_node.add(label, data=child)\n-            if child.children:\n-                self._populate_tree(child_node, child)\n-\n-    def _refresh_tree_labels(self, tree_node) -> None:\n-        alignment_node = tree_node.data\n-        if alignment_node is not None:\n-            tree_node.set_label(self._format_node_label(alignment_node))\n-        for child in tree_node.children:\n-            self._refresh_tree_labels(child)\n-\n-    def _format_node_label(self, node: tree_utils.AlignmentNode) -> str:\n-        state = self._node_state(node)\n-        name = node.name or \"(unnamed)\"\n-        if state == \"leaf\":\n-            return f\"    {name}\"\n-        marker = {\"checked\": \"[x]\", \"unchecked\": \"[ ]\", \"mixed\": \"[-]\"}[state]\n-        return f\"{marker} {name}\"\n-\n-    def _node_state(self, node: tree_utils.AlignmentNode) -> str:\n-        has_round = node.round is not None\n-        if node.round is not None:\n-            enabled = node.round.replace_with_ramax\n-            any_enabled = enabled\n-            all_enabled = enabled\n-        else:\n-            any_enabled = False\n-            all_enabled = True\n-        for child in node.children:\n-            child_state = self._node_state(child)\n-            if child_state == \"leaf\":\n-                continue\n-            has_round = True\n-            if child_state == \"checked\":\n-                any_enabled = True\n-            elif child_state == \"mixed\":\n-                any_enabled = True\n-                all_enabled = False\n-            elif child_state == \"unchecked\":\n-                all_enabled = False\n-        if not has_round:\n-            return \"leaf\"\n-        if all_enabled and any_enabled:\n-            return \"checked\"\n-        if any_enabled:\n-            return \"mixed\"\n-        return \"unchecked\"\n-\n     def _handle_command_selection(self, round_index: int, target: CommandTarget | None) -> None:\n         if target is None:\n             return\n@@ -1041,12 +1642,6 @@ def _apply_command_edit(\n         elif target.step is not None:\n             target.step.raw = new_command\n         status = f\"Updated {target.label} command\"\n-        if self.alignment_tree and self.tree_widget:\n-            node = self._find_node_for_round(round_entry)\n-            if node:\n-                self._refresh_tree_labels(self.tree_widget.root)\n-                self._show_alignment_node(node, status=status)\n-                return\n         self._show_round(round_index, status=status)\n \n     def _apply_ramax_options(\n@@ -1061,11 +1656,6 @@ def _apply_ramax_options(\n         round_entry = self.plan.rounds[round_index]\n         round_entry.ramax_opts = round_opts\n         status = \"RaMAx options updated\"\n-        if self.alignment_tree and self.tree_widget:\n-            node = self._find_node_for_round(round_entry)\n-            if node:\n-                self._show_alignment_node(node, status=status)\n-                return\n         self._show_round(round_index, status=status)\n \n     def _finalize_run_settings(self, result: RunSettings | None) -> None:"
      },
      {
        "sha": "70e89f0c8c8fdb56e9347b998cab26d35c963ebd",
        "filename": "pyproject.toml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/malabz/Cax/blob/c7826a78095e1d7bd33955b97df0509f95720b15/pyproject.toml",
        "raw_url": "https://github.com/malabz/Cax/raw/c7826a78095e1d7bd33955b97df0509f95720b15/pyproject.toml",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/pyproject.toml?ref=c7826a78095e1d7bd33955b97df0509f95720b15",
        "patch": "@@ -4,7 +4,7 @@ build-backend = \"hatchling.build\"\n \n [project]\n name = \"cactus-ramax\"\n-version = \"0.2.2\"\n+version = \"0.3.0-dev\"\n description = \"Interactive tooling for mixing cactus and RaMAx workflows\"\n authors = [{name = \"Cactus-RaMAx Team\"}]\n readme = \"README.md\""
      },
      {
        "sha": "35ba14d461e1a8c0f751a11ed1d140b4428b23ec",
        "filename": "tests/test_planner_skips.py",
        "status": "removed",
        "additions": 0,
        "deletions": 86,
        "changes": 86,
        "blob_url": "https://github.com/malabz/Cax/blob/5c62f9b5dbdab43440503e22b8799d27ff39faf0/tests%2Ftest_planner_skips.py",
        "raw_url": "https://github.com/malabz/Cax/raw/5c62f9b5dbdab43440503e22b8799d27ff39faf0/tests%2Ftest_planner_skips.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/tests%2Ftest_planner_skips.py?ref=5c62f9b5dbdab43440503e22b8799d27ff39faf0",
        "patch": "@@ -1,86 +0,0 @@\n-\"\"\"Tests covering planner behaviour for subtree replacements.\"\"\"\n-from __future__ import annotations\n-\n-from datetime import datetime\n-\n-from cax import planner\n-from cax.models import Plan, PrepareHeader, Round, Step\n-\n-\n-def _make_step(raw: str, kind: str, root: str | None = None) -> Step:\n-    return Step(\n-        raw=raw,\n-        kind=kind,\n-        jobstore=None,\n-        out_files=[],\n-        root=root,\n-    )\n-\n-\n-def _make_round(\n-    name: str,\n-    root: str,\n-    target_hal: str,\n-    replace_with_ramax: bool,\n-) -> Round:\n-    blast = Step(\n-        raw=f\"cactus-blast jobstore/1 seq.txt {root}.paf --root {root}\",\n-        kind=\"blast\",\n-        root=root,\n-    )\n-    align = Step(\n-        raw=f\"cactus-align jobstore/2 seq.txt {root}.paf {root}.hal --root {root}\",\n-        kind=\"align\",\n-        root=root,\n-        out_files=[f\"{root}.hal\"],\n-    )\n-    return Round(\n-        name=name,\n-        root=root,\n-        target_hal=f\"{target_hal}\",\n-        blast_step=None if replace_with_ramax else blast,\n-        align_step=None if replace_with_ramax else align,\n-        replace_with_ramax=replace_with_ramax,\n-    )\n-\n-\n-def test_descendant_rounds_skipped_when_ancestor_replaced(tmp_path) -> None:\n-    out_seq_file = tmp_path / \"tree.txt\"\n-    out_seq_file.write_text(\"((A:0.1,B:0.2)N1:0.3,C:0.4)Root;\\n\", encoding=\"utf-8\")\n-\n-    header = PrepareHeader(\n-        generated_by=\"cactus-prepare example --outSeqFile tree.txt\",\n-        date=datetime(2024, 1, 1, 0, 0, 0),\n-    )\n-    round_child = _make_round(\"Round child\", \"N1\", \"N1.hal\", replace_with_ramax=False)\n-    round_root = _make_round(\"Round root\", \"Root\", \"Root.hal\", replace_with_ramax=True)\n-\n-    plan = Plan(\n-        header=header,\n-        preprocess=[],\n-        rounds=[round_child, round_root],\n-        hal_merges=[\n-            _make_step(\n-                \"halAppendSubtree Root.hal N1.hal N1 N1 --merge\",\n-                kind=\"halmerge\",\n-                root=\"N1\",\n-            ),\n-            _make_step(\n-                \"halAppendSubtree Root.hal Root.hal Root Root --merge\",\n-                kind=\"halmerge\",\n-                root=\"Root\",\n-            ),\n-        ],\n-        out_seq_file=str(out_seq_file),\n-    )\n-\n-    commands = planner.build_execution_plan(plan, base_dir=tmp_path)\n-\n-    # Expect the child round to be skipped entirely (no blast/align/ramax commands)\n-    categories = {cmd.category for cmd in commands}\n-    assert \"blast\" not in categories\n-    assert \"align\" not in categories\n-\n-    # Hal merge for the child should also be skipped, root merge retained.\n-    merge_targets = [cmd.command[3] for cmd in commands if cmd.category == \"halmerge\"]\n-    assert merge_targets == [\"Root\"]"
      },
      {
        "sha": "466e22037c4bf5d8d25d503984ac51f831b969e7",
        "filename": "tests/test_tree_utils.py",
        "status": "removed",
        "additions": 0,
        "deletions": 83,
        "changes": 83,
        "blob_url": "https://github.com/malabz/Cax/blob/5c62f9b5dbdab43440503e22b8799d27ff39faf0/tests%2Ftest_tree_utils.py",
        "raw_url": "https://github.com/malabz/Cax/raw/5c62f9b5dbdab43440503e22b8799d27ff39faf0/tests%2Ftest_tree_utils.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/tests%2Ftest_tree_utils.py?ref=5c62f9b5dbdab43440503e22b8799d27ff39faf0",
        "patch": "@@ -1,83 +0,0 @@\n-\"\"\"Tests for the alignment tree utilities.\"\"\"\n-from __future__ import annotations\n-\n-from datetime import datetime\n-\n-from cax import tree_utils\n-from cax.models import Plan, PrepareHeader, Round, Step\n-\n-\n-def _make_round(name: str) -> Round:\n-    blast = Step(\n-        raw=f\"cactus-blast jobstore/1 input.txt output_{name}.paf --root {name}\",\n-        kind=\"blast\",\n-        root=name,\n-        log_file=f\"logs/blast-{name}.log\",\n-    )\n-    align = Step(\n-        raw=f\"cactus-align jobstore/2 input.txt output_{name}.paf {name}.hal --root {name}\",\n-        kind=\"align\",\n-        root=name,\n-        out_files=[f\"{name}.hal\"],\n-        log_file=f\"logs/align-{name}.log\",\n-    )\n-    return Round(\n-        name=name,\n-        root=name,\n-        target_hal=f\"{name}.hal\",\n-        blast_step=blast,\n-        align_step=align,\n-    )\n-\n-\n-def _make_plan(out_seq_path: str) -> Plan:\n-    header = PrepareHeader(\n-        generated_by=\"cactus-prepare tests/tree.txt --outSeqFile tree.txt\",\n-        date=datetime(2024, 1, 1, 0, 0, 0),\n-    )\n-    rounds = [\n-        _make_round(\"N1\"),\n-        _make_round(\"N2\"),\n-        _make_round(\"Root\"),\n-    ]\n-    return Plan(\n-        header=header,\n-        preprocess=[],\n-        rounds=rounds,\n-        hal_merges=[],\n-        out_seq_file=out_seq_path,\n-    )\n-\n-\n-def test_build_alignment_tree(tmp_path) -> None:\n-    out_seq_file = tmp_path / \"tree.txt\"\n-    out_seq_file.write_text(\n-        \"((A:0.1,B:0.2)N1:0.3,(C:0.4,D:0.5)N2:0.6)Root;\\n\",\n-        encoding=\"utf-8\",\n-    )\n-    plan = _make_plan(str(out_seq_file))\n-\n-    tree = tree_utils.build_alignment_tree(plan)\n-    assert tree is not None\n-    assert tree.root.name == \"Root\"\n-    assert tree.root.round is plan.rounds[2]\n-\n-    child_names = sorted(child.name for child in tree.root.children)\n-    assert child_names == [\"N1\", \"N2\"]\n-\n-    node_n1 = tree.find(\"N1\")\n-    assert node_n1 is not None\n-    assert node_n1.round is plan.rounds[0]\n-    leaf_names = sorted(child.name for child in node_n1.children)\n-    assert leaf_names == [\"A\", \"B\"]\n-    assert all(child.round is None for child in node_n1.children)\n-\n-    node_n2 = tree.find(\"N2\")\n-    assert node_n2 is not None\n-    assert node_n2.round is plan.rounds[1]\n-\n-    all_rounds = list(tree.iter_rounds())\n-    assert len(all_rounds) == 3\n-    assert sorted(round_entry.root for round_entry in all_rounds) == sorted(\n-        round_entry.root for round_entry in plan.rounds\n-    )"
      }
    ]
  }
}