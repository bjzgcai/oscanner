{
  "cached_at": "2025-12-20T14:33:28.896469",
  "commit_sha": "044e2806686d7c7acc8b2cd5bef18bd73c05c198",
  "repo": "malabz/Cax",
  "data": {
    "sha": "044e2806686d7c7acc8b2cd5bef18bd73c05c198",
    "node_id": "C_kwDOPt61otoAKDA0NGUyODA2Njg2ZDdjN2FjYzhiMmNkNWJlZjE4YmQ3M2MwNWMxOTg",
    "commit": {
      "author": {
        "name": "LoadStar822",
        "email": "992247533@qq.com",
        "date": "2025-12-02T17:19:36Z"
      },
      "committer": {
        "name": "LoadStar822",
        "email": "992247533@qq.com",
        "date": "2025-12-02T17:19:36Z"
      },
      "message": "Start 0.4.0-dev: subtree mode + flow view",
      "tree": {
        "sha": "40b62e4c2c7ac4d8dcafab93c04549d2531e0896",
        "url": "https://api.github.com/repos/malabz/Cax/git/trees/40b62e4c2c7ac4d8dcafab93c04549d2531e0896"
      },
      "url": "https://api.github.com/repos/malabz/Cax/git/commits/044e2806686d7c7acc8b2cd5bef18bd73c05c198",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null,
        "verified_at": null
      }
    },
    "url": "https://api.github.com/repos/malabz/Cax/commits/044e2806686d7c7acc8b2cd5bef18bd73c05c198",
    "html_url": "https://github.com/malabz/Cax/commit/044e2806686d7c7acc8b2cd5bef18bd73c05c198",
    "comments_url": "https://api.github.com/repos/malabz/Cax/commits/044e2806686d7c7acc8b2cd5bef18bd73c05c198/comments",
    "author": {
      "login": "LoadStar822",
      "id": 56856603,
      "node_id": "MDQ6VXNlcjU2ODU2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/56856603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LoadStar822",
      "html_url": "https://github.com/LoadStar822",
      "followers_url": "https://api.github.com/users/LoadStar822/followers",
      "following_url": "https://api.github.com/users/LoadStar822/following{/other_user}",
      "gists_url": "https://api.github.com/users/LoadStar822/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LoadStar822/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LoadStar822/subscriptions",
      "organizations_url": "https://api.github.com/users/LoadStar822/orgs",
      "repos_url": "https://api.github.com/users/LoadStar822/repos",
      "events_url": "https://api.github.com/users/LoadStar822/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LoadStar822/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "committer": {
      "login": "LoadStar822",
      "id": 56856603,
      "node_id": "MDQ6VXNlcjU2ODU2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/56856603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LoadStar822",
      "html_url": "https://github.com/LoadStar822",
      "followers_url": "https://api.github.com/users/LoadStar822/followers",
      "following_url": "https://api.github.com/users/LoadStar822/following{/other_user}",
      "gists_url": "https://api.github.com/users/LoadStar822/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LoadStar822/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LoadStar822/subscriptions",
      "organizations_url": "https://api.github.com/users/LoadStar822/orgs",
      "repos_url": "https://api.github.com/users/LoadStar822/repos",
      "events_url": "https://api.github.com/users/LoadStar822/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LoadStar822/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bda6344bae4859b8889bfcdd4d02c8fba4179cef",
        "url": "https://api.github.com/repos/malabz/Cax/commits/bda6344bae4859b8889bfcdd4d02c8fba4179cef",
        "html_url": "https://github.com/malabz/Cax/commit/bda6344bae4859b8889bfcdd4d02c8fba4179cef"
      }
    ],
    "stats": {
      "total": 431,
      "additions": 369,
      "deletions": 62
    },
    "files": [
      {
        "sha": "95b2088bd9a3d849dd02d9737f9597b6647a32be",
        "filename": "CHANGELOG.md",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/malabz/Cax/blob/044e2806686d7c7acc8b2cd5bef18bd73c05c198/CHANGELOG.md",
        "raw_url": "https://github.com/malabz/Cax/raw/044e2806686d7c7acc8b2cd5bef18bd73c05c198/CHANGELOG.md",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/CHANGELOG.md?ref=044e2806686d7c7acc8b2cd5bef18bd73c05c198",
        "patch": "@@ -2,6 +2,15 @@\n \n All notable changes to this project will be documented in this file.\n \n+## [0.4.0-dev] - Unreleased\n+\n+### UI\n+- Run Settings now has a dual-view toggle (`F6`): switch between the classic plan overview and a new flow view that renders the execution dependency tree as ASCII, so you can see round ordering and ancestry while editing thread/verbose options.\n+- Added an explicit Subtree Mode (`--subtree-mode` flag) toggle: enabling it on a node forces RaMAx for that subtree and automatically disables RaMAx on descendants; switching back to node mode removes the flag. Child-level edits now auto-cancel an ancestor’s subtree mode to avoid conflicts (with safe handling when no Textual app is active).\n+\n+### Fixes\n+- Safeguard subtree-mode reversion when no Textual app context exists (tests/CLI), preventing NoActiveAppError during node-level toggles.\n+\n ## [0.3.0] - 2025-11-25\n \n ### UI"
      },
      {
        "sha": "2fa93740601bc7d1b586840c7ccacd5dc30d35f8",
        "filename": "README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/malabz/Cax/blob/044e2806686d7c7acc8b2cd5bef18bd73c05c198/README.md",
        "raw_url": "https://github.com/malabz/Cax/raw/044e2806686d7c7acc8b2cd5bef18bd73c05c198/README.md",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/README.md?ref=044e2806686d7c7acc8b2cd5bef18bd73c05c198",
        "patch": "@@ -1,6 +1,6 @@\n # Cactus-RaMAx\n \n-Cactus-RaMAx helps you remix alignment plans emitted by `cactus-prepare`. You can inspect every round, toggle RaMAx for any subtree, and then run or export the resulting command list. Version `0.3.0` introduces an ASCII phylogenetic canvas with subtree/single-node toggle scopes, search, proportional branch spacing, and a bottom HUD that summarizes the current node, coverage, and live system metrics.\n+Cactus-RaMAx helps you remix alignment plans emitted by `cactus-prepare`. You can inspect every round, toggle RaMAx for any subtree, and then run or export the resulting command list. The current development version (`0.4.0-dev`) keeps the ASCII phylogenetic canvas with subtree/single-node toggle scopes, search, proportional branch spacing, and a bottom HUD that summarizes the current node, coverage, and live system metrics. Subtree Mode now adds a `--subtree-mode` flag, disables descendant RaMAx automatically, and gracefully reverts if you later edit a child node.\n \n ## Environment setup\n \n@@ -51,7 +51,7 @@ cax\n - The left pane renders an ASCII phylogenetic canvas with proportional branch spacing; use arrow keys or **h/j/k/l** to move, press **Space** to toggle RaMAx using the current scope, and press **b** to switch the scope between subtree and single node. Press **/** to search node names, then **n** / **Shift+N** to cycle through matches.\n - The canvas paints cactus vs. RaMAx states inline, annotates branch lengths on dotted leaders, and shows a bottom HUD with identity, subtree/total RaMAx coverage, and live CPU/GPU/memory/disk metrics. Press **i** for a full detail modal of the current node.\n - `E`: edit commands for the selected round or RaMAx replacement in a multi-line editor (press **Ctrl+S** to save).\n-- `R`: open the Run Settings screen to review verbose logging and the shared thread count, run the plan, or save the generated command list. The screen keeps a live plan summary and is fully keyboard-driven (`Tab` / `Shift+Tab`, **Ctrl+Enter**, **V**).\n+- `R`: open the Run Settings screen to review verbose logging and the shared thread count, run the plan, or save the generated command list. The screen is fully keyboard-driven (`Tab` / `Shift+Tab`, **Ctrl+Enter**, **V**), and **F6** switches between the classic plan overview and a new flow view that renders the execution dependency tree in ASCII.\n - `Q`: quit the UI.\n - Verbose streaming is only controlled via the run-settings dialog so you can review the choice right before execution.\n "
      },
      {
        "sha": "25a5afd80bbc7e9225be020cd1130797627c7185",
        "filename": "VERSION",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/malabz/Cax/blob/044e2806686d7c7acc8b2cd5bef18bd73c05c198/VERSION",
        "raw_url": "https://github.com/malabz/Cax/raw/044e2806686d7c7acc8b2cd5bef18bd73c05c198/VERSION",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/VERSION?ref=044e2806686d7c7acc8b2cd5bef18bd73c05c198",
        "patch": "@@ -1 +1 @@\n-0.3.0\n+0.4.0-dev"
      },
      {
        "sha": "60f16102b09580c3d241f83d865b1ab386d22ad7",
        "filename": "cax/ui.py",
        "status": "modified",
        "additions": 351,
        "deletions": 51,
        "changes": 402,
        "blob_url": "https://github.com/malabz/Cax/blob/044e2806686d7c7acc8b2cd5bef18bd73c05c198/cax%2Fui.py",
        "raw_url": "https://github.com/malabz/Cax/raw/044e2806686d7c7acc8b2cd5bef18bd73c05c198/cax%2Fui.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fui.py?ref=044e2806686d7c7acc8b2cd5bef18bd73c05c198",
        "patch": "@@ -22,6 +22,7 @@\n from rich.panel import Panel\n from rich.table import Table\n from rich.text import Text\n+from rich.tree import Tree\n from rich.align import Align\n from rich.console import Group\n \n@@ -508,82 +509,120 @@ def _toggle_single(self) -> None:\n         # If a parent subtree was toggled in bulk, revert it first to avoid mixed states.\n         if self._maybe_revert_bulk(self._cursor):\n             return\n+            \n         round_entry = self._cursor.round\n+        \n+        # Remove subtree flag if present (switching from Subtree -> Node mode effectively)\n+        if \"--subtree-mode\" in round_entry.ramax_opts:\n+            round_entry.ramax_opts.remove(\"--subtree-mode\")\n+            \n         round_entry.replace_with_ramax = not round_entry.replace_with_ramax\n-        state = \"RaMAx\" if round_entry.replace_with_ramax else \"cactus\"\n+        state = \"RaMAx (Node)\" if round_entry.replace_with_ramax else \"cactus\"\n         self._rebuild_visual()\n         self.refresh()\n         self._notify(self._cursor, f\"Current round switched to {state}\")\n \n     def _toggle_subtree(self) -> None:\n-        rounds = list(self._cursor.iter_rounds())\n-        if not rounds:\n-            self._notify(self._cursor, \"No rounds in this subtree can be toggled.\")\n+        \"\"\"\n+        Toggle Subtree Mode (Mode B):\n+        - Enable RaMAx for this node.\n+        - Add '--subtree-mode' flag.\n+        - Disable RaMAx for all descendant nodes (as they are subsumed).\n+        \"\"\"\n+        if not self._cursor.round:\n+            self._notify(self._cursor, \"No round on this node to apply subtree mode.\")\n             return\n-        target_state = not all(r.replace_with_ramax for r in rounds)\n-        for round_entry in rounds:\n-            round_entry.replace_with_ramax = target_state\n-        # Track the latest subtree toggle so child toggles can revert it if needed.\n-        self._bulk_root = self._cursor if target_state else None\n-        self._bulk_state = target_state if target_state else None\n-        message = (\n-            f\"Toggled {len(rounds)} round(s) to RaMAx\"\n-            if target_state\n-            else f\"Restored {len(rounds)} round(s) to cactus\"\n-        )\n+            \n+        round_entry = self._cursor.round\n+        \n+        # Check if currently enabled as subtree\n+        is_subtree_active = round_entry.replace_with_ramax and \"--subtree-mode\" in round_entry.ramax_opts\n+        \n+        target_state = not is_subtree_active\n+        \n+        if target_state:\n+            # Enable Subtree Mode\n+            round_entry.replace_with_ramax = True\n+            if \"--subtree-mode\" not in round_entry.ramax_opts:\n+                round_entry.ramax_opts.append(\"--subtree-mode\")\n+            \n+            # Disable all descendants\n+            descendants = self._collect_round_nodes(self._cursor)\n+            count_disabled = 0\n+            for desc in descendants:\n+                if desc is self._cursor: continue\n+                if desc.round and desc.round.replace_with_ramax:\n+                    desc.round.replace_with_ramax = False\n+                    # Also clean their subtree flags if any\n+                    if \"--subtree-mode\" in desc.round.ramax_opts:\n+                        desc.round.ramax_opts.remove(\"--subtree-mode\")\n+                    count_disabled += 1\n+            \n+            msg = f\"Enabled Subtree RaMAx. Overridden {count_disabled} descendant(s).\"\n+        else:\n+            # Disable Subtree Mode\n+            round_entry.replace_with_ramax = False\n+            if \"--subtree-mode\" in round_entry.ramax_opts:\n+                round_entry.ramax_opts.remove(\"--subtree-mode\")\n+            msg = \"Disabled Subtree RaMAx.\"\n+\n         self._rebuild_visual()\n         self.refresh()\n-        self._notify(self._cursor, f\"{message} (scope: subtree)\")\n+        self._notify(self._cursor, msg)\n \n     def _maybe_revert_bulk(self, node: tree_utils.AlignmentNode) -> bool:\n-        \"\"\"If a subtree was toggled to RaMAx and the current node lies within it, revert the bulk change first.\"\"\"\n-\n-        if not (self._bulk_root and self._bulk_state):\n-            return False\n-        if self._bulk_state is not True:\n-            return False\n-        if node is self._bulk_root:\n-            return False\n-\n-        # Check whether the node is within the recorded subtree.\n-        bulk_nodes = self._collect_subtree_nodes(self._bulk_root)\n-        if node not in bulk_nodes:\n+        \"\"\"\n+        Check if any ancestor is in Subtree Mode. If so, disable that mode to allow node-level edits.\n+        Returns True if an ancestor was modified (reverted), signaling the caller to stop.\n+        \"\"\"\n+        current = getattr(node, \"parent\", None)\n+        ancestor_conflict: tree_utils.AlignmentNode | None = None\n+        \n+        while current:\n+            if current.round and current.round.replace_with_ramax:\n+                if \"--subtree-mode\" in current.round.ramax_opts:\n+                    ancestor_conflict = current\n+                    break\n+            current = getattr(current, \"parent\", None)\n+            \n+        if not ancestor_conflict:\n             return False\n \n-        for round_entry in self._bulk_root.iter_rounds():\n-            round_entry.replace_with_ramax = False\n-\n-        # Clear bulk tracking flags\n-        self._bulk_root = None\n-        self._bulk_state = None\n+        # Revert the ancestor's Subtree Mode\n+        if ancestor_conflict.round:\n+            ancestor_conflict.round.ramax_opts.remove(\"--subtree-mode\")\n+            # Option: also disable RaMAx entirely? \n+            # \"Cancel the replacement\" implies setting replace_with_ramax = False?\n+            # Let's stick to degrading to Node Mode first, as it's safer.\n+            # But user said: \"直接取消这个大子树的替换\" -> replace_with_ramax = False\n+            ancestor_conflict.round.replace_with_ramax = False\n \n         self._rebuild_visual()\n         self.refresh()\n         self._notify(\n             node,\n-            \"Exited subtree-wide RaMAx; the subtree is restored to cactus. Reselect the subtree before enabling nodes individually.\",\n+            f\"Conflict: Subtree mode on ancestor '{ancestor_conflict.name}' has been disabled.\",\n         )\n-        self._show_revert_modal()\n-        return True\n-\n-    def _show_revert_modal(self) -> None:\n-        \"\"\"Show a modal hint so the notice is not lost.\"\"\"\n-\n+        \n+        # Show modal\n         try:\n-            app = self.app  # Only available when the Textual app is running; tests may not mount it.\n+            app = self.app  # May raise when not running inside a Textual app (e.g., unit tests).\n         except Exception:\n             app = None\n+\n         if app and hasattr(app, \"push_screen\"):\n             app.push_screen(\n                 InfoModal(\n-                    \"Bulk mode exited\",\n+                    \"Subtree Mode Disabled\",\n                     (\n-                        \"The RaMAx toggle for that subtree has been reverted to cactus.\\n\\n\"\n-                        \"Reason: you selected a node inside that subtree while in single-node mode.\\n\\n\"\n-                        \"To reapply in bulk, switch back to subtree mode (press b) and then press space.\"\n+                        f\"The ancestor node '{ancestor_conflict.name}' was in Subtree Mode.\\n\\n\"\n+                        \"Since you are modifying a child node independently, the ancestor's \"\n+                        \"subtree-wide replacement has been cancelled to avoid conflicts.\"\n                     ),\n                 )\n             )\n+            \n+        return True\n \n     def action_toggle_ascii(self) -> None:\n         pass\n@@ -1466,6 +1505,7 @@ class RunSettingsScreen(Screen[RunSettings | None]):\n         Binding(\"ctrl+enter\", \"save\", \"Run\"),\n         Binding(\"ctrl+r\", \"save\", \"Run\"),\n         Binding(\"v\", \"toggle_verbose\", \"Toggle verbose\"),\n+        Binding(\"f6\", \"toggle_view\", \"View\"),\n     ]\n \n     CSS = \"\"\"\n@@ -1542,6 +1582,7 @@ def __init__(self, plan: Plan, current: RunSettings, compact: bool):\n         self._input: Input | None = None\n         self._verbose: Checkbox | None = None\n         self._status: Static | None = None\n+        self._view_mode: str = \"flow\"  # flow | table\n \n     def compose(self) -> ComposeResult:\n         yield Header()\n@@ -1550,10 +1591,10 @@ def compose(self) -> ComposeResult:\n             with Container(id=\"run-body\"):\n                 summary = Static(id=\"run-summary\")\n                 self._summary = summary\n-                summary.update(plan_overview(self.plan, run_settings=self.current, compact=self.compact))\n+                summary.update(self._render_summary(self.current))\n                 yield summary\n                 with Container(id=\"run-form\"):\n-                    yield Static(\"• Tab/Shift+Tab to move between controls\\n• Ctrl+Enter to run immediately\\n• V toggles verbose logging\", id=\"run-instructions\")\n+                    yield Static(\"• Tab/Shift+Tab to move between controls\\n• Ctrl+Enter to run immediately\\n• V toggles verbose logging\\n• F6 toggles table/flow view\", id=\"run-instructions\")\n                     verbose_box = Checkbox(\n                         \"Verbose logging (stream every command output)\",\n                         value=self.current.verbose,\n@@ -1617,6 +1658,11 @@ def action_toggle_verbose(self) -> None:\n             self._verbose.value = not self._verbose.value\n             self._refresh_summary()\n \n+    def action_toggle_view(self) -> None:\n+        # 切换左侧总览的呈现方式（表格/流程图）\n+        self._view_mode = \"table\" if self._view_mode == \"flow\" else \"flow\"\n+        self._refresh_summary()\n+\n     def on_input_submitted(self, event: Input.Submitted) -> None:\n         if event.input.id == \"run-threads\":\n             self.action_save()\n@@ -1660,9 +1706,263 @@ def _refresh_summary(self) -> None:\n         if not self._summary:\n             return\n         settings = self._current_settings_preview()\n-        self._summary.update(\n-            plan_overview(self.plan, run_settings=settings, compact=self.compact)\n-        )\n+        self._summary.update(self._render_summary(settings))\n+\n+    def _render_summary(self, settings: RunSettings) -> RenderableType:\n+        if self._view_mode == \"flow\":\n+            return self._render_flow_overview(settings)\n+        return plan_overview(self.plan, run_settings=settings, compact=self.compact)\n+\n+    def _render_flow_overview(self, settings: RunSettings) -> Panel:\n+        # Header\n+        header = Text()\n+        header.append(\"Threads: \", style=\"dim\")\n+        header.append(\"auto\" if settings.thread_count is None else str(settings.thread_count), style=\"bold white\")\n+        header.append(\"  Verbose: \", style=\"dim\")\n+        header.append(\"on\" if settings.verbose else \"off\", style=\"bold green\" if settings.verbose else \"bold #aaaaaa\")\n+        \n+        canvas_text = self._draw_dependency_tree()\n+        \n+        content = Group(header, Text(\"\"), canvas_text)\n+        return Panel(content, title=\"[Execution Dependency Tree]\", border_style=\"magenta\", padding=(0, 1))\n+\n+    def _draw_dependency_tree(self) -> Text:\n+        \"\"\"\n+        Builds a visual dependency tree of the Rounds based on input/output relationships.\n+        Returns a Rich Text object containing the ASCII art.\n+        \"\"\"\n+        if not self.plan.rounds:\n+            return Text(\"No rounds planned.\", style=\"dim red\")\n+\n+        node_map: dict[str, Round] = {r.root: r for r in self.plan.rounds}\n+        phylo_root = getattr(self.app, \"alignment_tree\", None)\n+        if not phylo_root:\n+             return Text(\"Phylogeny tree missing.\", style=\"dim red\")\n+        \n+        @dataclass\n+        class TreeNode:\n+            round_entry: Round | None\n+            name: str\n+            children: list[\"TreeNode\"]\n+            width: int = 0\n+            x: int = 0\n+            y: int = 0\n+            is_clustered: bool = False\n+            \n+        def build_node(phylo_node: tree_utils.AlignmentNode) -> TreeNode:\n+            r = node_map.get(phylo_node.name)\n+            c_nodes = [build_node(c) for c in phylo_node.children]\n+            return TreeNode(round_entry=r, name=phylo_node.name, children=c_nodes)\n+\n+        root_tree_node = build_node(phylo_root.root)\n+\n+        def is_relevant(tn: TreeNode) -> bool:\n+            if tn.round_entry: return True\n+            return any(is_relevant(c) for c in tn.children)\n+\n+        if not is_relevant(root_tree_node):\n+             return Text(\"No active rounds in tree.\", style=\"dim yellow\")\n+\n+        # Analyze Connectivity and Propagate Subtree Mode\n+        def analyze_connectivity(tn: TreeNode, override_as_input: bool = False):\n+            if override_as_input:\n+                # If a parent is in Subtree Mode, this node ceases to be a Round\n+                # and becomes a raw input source for the parent.\n+                tn.round_entry = None\n+            \n+            is_ramax = tn.round_entry and tn.round_entry.replace_with_ramax\n+            is_subtree_mode = is_ramax and \"--subtree-mode\" in tn.round_entry.ramax_opts\n+            \n+            if is_subtree_mode:\n+                tn.is_clustered = True\n+                # Propagate the override to all children\n+                for c in tn.children:\n+                    analyze_connectivity(c, override_as_input=True)\n+            else:\n+                tn.is_clustered = False\n+                # Continue normal recursion\n+                for c in tn.children:\n+                    analyze_connectivity(c, override_as_input=override_as_input)\n+\n+        analyze_connectivity(root_tree_node)\n+\n+        # Layout constants\n+        BOX_WIDTH = 14\n+        H_GAP = 2\n+        V_GAP = 2\n+\n+        def measure_width(tn: TreeNode) -> int:\n+            if not tn.children:\n+                tn.width = BOX_WIDTH\n+                return BOX_WIDTH\n+            c_width = sum(measure_width(c) for c in tn.children) + (len(tn.children) - 1) * H_GAP\n+            tn.width = max(BOX_WIDTH, c_width)\n+            return tn.width\n+\n+        measure_width(root_tree_node)\n+\n+        def layout(tn: TreeNode, start_x: int, depth: int):\n+            tn.y = depth * (3 + V_GAP)\n+            tn.x = start_x + tn.width // 2\n+            \n+            total_c_width = sum(c.width for c in tn.children) + (max(0, len(tn.children)-1) * H_GAP)\n+            c_start_x = tn.x - total_c_width // 2\n+            \n+            for c in tn.children:\n+                layout(c, c_start_x, depth + 1)\n+                c_start_x += c.width + H_GAP\n+\n+        layout(root_tree_node, 0, 0)\n+\n+        max_w = root_tree_node.width\n+        max_h = 0\n+        def get_max_h(tn):\n+            nonlocal max_h\n+            max_h = max(max_h, tn.y + 3)\n+            for c in tn.children: get_max_h(c)\n+        get_max_h(root_tree_node)\n+\n+        # Pixel buffer: (x, y) -> (char, style)\n+        pixels: dict[tuple[int, int], tuple[str, str]] = {}\n+\n+        def put(x, y, char, style=\"white\"):\n+            if 0 <= y < max_h + 10 and 0 <= x < max_w + 10:\n+                pixels[(x, y)] = (char, style)\n+\n+        def draw_node_recursive(tn: TreeNode):\n+            left = tn.x - BOX_WIDTH // 2\n+            top = tn.y\n+            \n+            is_ramax = tn.round_entry and tn.round_entry.replace_with_ramax\n+            \n+            if tn.round_entry:\n+                if is_ramax:\n+                    color = \"yellow\"\n+                    border_color = \"yellow\"\n+                    icon = \"R\"\n+                    use_double = tn.is_clustered\n+                else:\n+                    color = \"cyan\"\n+                    border_color = \"blue\"\n+                    icon = \"C\"\n+                    use_double = False\n+            else:\n+                color = \"green\"\n+                border_color = \"dim green\"\n+                icon = \"L\"\n+                use_double = False\n+            \n+            # Box Chars\n+            if use_double:\n+                tl, tr, bl, br = \"╔\", \"╗\", \"╚\", \"╝\"\n+                h, v = \"═\", \"║\"\n+            else:\n+                tl, tr, bl, br = \"┌\", \"┐\", \"└\", \"┘\"\n+                h, v = \"─\", \"│\"\n+            \n+            # Box Drawing\n+            put(left, top, tl, border_color)\n+            for i in range(1, BOX_WIDTH-1): put(left+i, top, h, border_color)\n+            put(left+BOX_WIDTH-1, top, tr, border_color)\n+            \n+            put(left, top+1, v, border_color)\n+            \n+            raw_label = tn.name\n+            content_space = BOX_WIDTH - 2\n+            full_str = f\"{icon} {raw_label}\"\n+            if len(full_str) > content_space:\n+                full_str = f\"{icon} {raw_label[:content_space-4]}..\"\n+            \n+            padding_left = (content_space - len(full_str)) // 2\n+            start_x = left + 1 + padding_left\n+            \n+            put(start_x, top+1, icon, color)\n+            for i, char in enumerate(full_str):\n+                if i == 0: continue\n+                put(start_x + i, top+1, char, \"bold white\")\n+                \n+            put(left+BOX_WIDTH-1, top+1, v, border_color)\n+            \n+            put(left, top+2, bl, border_color)\n+            for i in range(1, BOX_WIDTH-1): put(left+i, top+2, h, border_color)\n+            put(left+BOX_WIDTH-1, top+2, br, border_color)\n+\n+            # Connections\n+            if tn.children:\n+                put(tn.x, top+2, \"┴\", border_color)\n+                \n+                mid_y = top + 3\n+                put(tn.x, mid_y, \"│\", border_color)\n+                \n+                min_cx = min(c.x for c in tn.children)\n+                max_cx = max(c.x for c in tn.children)\n+                \n+                for x in range(min_cx, max_cx + 1):\n+                    char = \"─\"\n+                    line_style = \"dim white\"\n+                    \n+                    if x == tn.x: char = \"┼\"\n+                    elif x == min_cx: char = \"┌\"\n+                    elif x == max_cx: char = \"┐\"\n+                    \n+                    is_child_stem = any(c.x == x for c in tn.children)\n+                    if is_child_stem:\n+                        if char == \"─\": char = \"┬\"\n+                        if char == \"┌\": char = \"┌\"\n+                        if char == \"┐\": char = \"┐\"\n+                        if char == \"┼\": char = \"┼\"\n+                    \n+                    put(x, mid_y, char, line_style)\n+\n+                for c in tn.children:\n+                    child_is_ramax = c.round_entry and c.round_entry.replace_with_ramax\n+                    if is_ramax and child_is_ramax:\n+                        conn_style = \"yellow\"\n+                    else:\n+                        conn_style = \"dim white\"\n+                        \n+                    put(c.x, mid_y+1, \"↓\", conn_style)\n+\n+            for c in tn.children:\n+                draw_node_recursive(c)\n+\n+        draw_node_recursive(root_tree_node)\n+\n+        if not pixels: return Text(\"Empty Tree\", style=\"red\")\n+\n+        sorted_pixels = sorted(pixels.items(), key=lambda item: (item[0][1], item[0][0]))\n+        final_text = Text()\n+        row_map: dict[int, list[tuple[int, str, str]]] = {}\n+        \n+        for (x, y), (char, style) in sorted_pixels:\n+            if y not in row_map: row_map[y] = []\n+            row_map[y].append((x, char, style))\n+\n+        min_x = min(k[0] for k in pixels.keys())\n+        \n+        for y in sorted(row_map.keys()):\n+            row_pixels = row_map[y]\n+            cursor = min_x\n+            for x, char, style in row_pixels:\n+                if x > cursor:\n+                    final_text.append(\" \" * (x - cursor))\n+                final_text.append(char, style=style)\n+                cursor = x + 1\n+            final_text.append(\"\\n\")\n+\n+        return final_text\n+\n+    def _flow_preview_width(self) -> int:\n+        try:\n+            width = self.size.width\n+        except Exception:\n+            width = 80\n+        return max(40, min(90, width - 18))\n+\n+    def _shorten(self, text: str, width: int) -> str:\n+        if len(text) <= width:\n+            return text\n+        return text[: width - 1] + \"…\"\n \n \n class RamaxOptionsModal(ModalScreen[tuple[list[str], list[str]] | None]):"
      },
      {
        "sha": "4fad82759f812c18ce65d51a082c12204d8f81bf",
        "filename": "pyproject.toml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/malabz/Cax/blob/044e2806686d7c7acc8b2cd5bef18bd73c05c198/pyproject.toml",
        "raw_url": "https://github.com/malabz/Cax/raw/044e2806686d7c7acc8b2cd5bef18bd73c05c198/pyproject.toml",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/pyproject.toml?ref=044e2806686d7c7acc8b2cd5bef18bd73c05c198",
        "patch": "@@ -4,7 +4,7 @@ build-backend = \"hatchling.build\"\n \n [project]\n name = \"cactus-ramax\"\n-version = \"0.3.0\"\n+version = \"0.4.0-dev\"\n description = \"Interactive tooling for mixing cactus and RaMAx workflows\"\n authors = [{name = \"Cactus-RaMAx Team\"}]\n readme = \"README.md\""
      },
      {
        "sha": "0fd3be49c551d6f64e4a2266fd025730c5f134fe",
        "filename": "tests/test_ui_bulk_revert.py",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/malabz/Cax/blob/044e2806686d7c7acc8b2cd5bef18bd73c05c198/tests%2Ftest_ui_bulk_revert.py",
        "raw_url": "https://github.com/malabz/Cax/raw/044e2806686d7c7acc8b2cd5bef18bd73c05c198/tests%2Ftest_ui_bulk_revert.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/tests%2Ftest_ui_bulk_revert.py?ref=044e2806686d7c7acc8b2cd5bef18bd73c05c198",
        "patch": "@@ -5,7 +5,7 @@\n \n def _build_tree():\n     # Build a minimal tree: root -> child\n-    root_round = Round(name=\"root\", root=\"Anc0\", target_hal=\"a.hal\", replace_with_ramax=True)\n+    root_round = Round(name=\"root\", root=\"Anc0\", target_hal=\"a.hal\", replace_with_ramax=True, ramax_opts=[\"--subtree-mode\"])\n     child_round = Round(name=\"child\", root=\"Anc1\", target_hal=\"b.hal\", replace_with_ramax=True)\n     root = tree_utils.AlignmentNode(name=\"Anc0\", children=[])\n     child = tree_utils.AlignmentNode(name=\"Anc1\", children=[])\n@@ -19,14 +19,12 @@ def _build_tree():\n def test_bulk_revert_when_toggling_child():\n     root, child = _build_tree()\n     widget = AsciiPhylo(root)\n-    # Simulate a bulk RaMAx toggle on the subtree\n-    widget._bulk_root = root\n-    widget._bulk_state = True\n+    # Simulate ancestor subtree mode\n+    assert \"--subtree-mode\" in root.round.ramax_opts\n \n     reverted = widget._maybe_revert_bulk(child)\n \n     assert reverted is True\n     assert root.round.replace_with_ramax is False\n-    assert child.round.replace_with_ramax is False\n-    assert widget._bulk_root is None\n-    assert widget._bulk_state is None\n+    assert \"--subtree-mode\" not in root.round.ramax_opts\n+    assert child.round.replace_with_ramax is True"
      }
    ]
  }
}