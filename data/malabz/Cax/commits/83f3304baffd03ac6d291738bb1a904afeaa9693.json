{
  "cached_at": "2025-12-20T14:33:32.178171",
  "commit_sha": "83f3304baffd03ac6d291738bb1a904afeaa9693",
  "repo": "malabz/Cax",
  "data": {
    "sha": "83f3304baffd03ac6d291738bb1a904afeaa9693",
    "node_id": "C_kwDOPt61otoAKDgzZjMzMDRiYWZmZDAzYWM2ZDI5MTczOGJiMWE5MDRhZmVhYTk2OTM",
    "commit": {
      "author": {
        "name": "LoadStar822",
        "email": "992247533@qq.com",
        "date": "2025-10-28T06:12:31Z"
      },
      "committer": {
        "name": "LoadStar822",
        "email": "992247533@qq.com",
        "date": "2025-10-28T06:12:31Z"
      },
      "message": "feat: add pre-run cleanup prompt and plan-level verbose controls",
      "tree": {
        "sha": "ae7441df84d7db2a8c04442f1f794b67ff65bf88",
        "url": "https://api.github.com/repos/malabz/Cax/git/trees/ae7441df84d7db2a8c04442f1f794b67ff65bf88"
      },
      "url": "https://api.github.com/repos/malabz/Cax/git/commits/83f3304baffd03ac6d291738bb1a904afeaa9693",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null,
        "verified_at": null
      }
    },
    "url": "https://api.github.com/repos/malabz/Cax/commits/83f3304baffd03ac6d291738bb1a904afeaa9693",
    "html_url": "https://github.com/malabz/Cax/commit/83f3304baffd03ac6d291738bb1a904afeaa9693",
    "comments_url": "https://api.github.com/repos/malabz/Cax/commits/83f3304baffd03ac6d291738bb1a904afeaa9693/comments",
    "author": {
      "login": "LoadStar822",
      "id": 56856603,
      "node_id": "MDQ6VXNlcjU2ODU2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/56856603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LoadStar822",
      "html_url": "https://github.com/LoadStar822",
      "followers_url": "https://api.github.com/users/LoadStar822/followers",
      "following_url": "https://api.github.com/users/LoadStar822/following{/other_user}",
      "gists_url": "https://api.github.com/users/LoadStar822/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LoadStar822/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LoadStar822/subscriptions",
      "organizations_url": "https://api.github.com/users/LoadStar822/orgs",
      "repos_url": "https://api.github.com/users/LoadStar822/repos",
      "events_url": "https://api.github.com/users/LoadStar822/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LoadStar822/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "committer": {
      "login": "LoadStar822",
      "id": 56856603,
      "node_id": "MDQ6VXNlcjU2ODU2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/56856603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LoadStar822",
      "html_url": "https://github.com/LoadStar822",
      "followers_url": "https://api.github.com/users/LoadStar822/followers",
      "following_url": "https://api.github.com/users/LoadStar822/following{/other_user}",
      "gists_url": "https://api.github.com/users/LoadStar822/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LoadStar822/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LoadStar822/subscriptions",
      "organizations_url": "https://api.github.com/users/LoadStar822/orgs",
      "repos_url": "https://api.github.com/users/LoadStar822/repos",
      "events_url": "https://api.github.com/users/LoadStar822/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LoadStar822/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1f509f44a23649bcef0792f19f01a327ca9f663d",
        "url": "https://api.github.com/repos/malabz/Cax/commits/1f509f44a23649bcef0792f19f01a327ca9f663d",
        "html_url": "https://github.com/malabz/Cax/commit/1f509f44a23649bcef0792f19f01a327ca9f663d"
      }
    ],
    "stats": {
      "total": 361,
      "additions": 332,
      "deletions": 29
    },
    "files": [
      {
        "sha": "755ee17aaebb8118dc5efa11aed6eef908a608ed",
        "filename": "CHANGELOG.md",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/malabz/Cax/blob/83f3304baffd03ac6d291738bb1a904afeaa9693/CHANGELOG.md",
        "raw_url": "https://github.com/malabz/Cax/raw/83f3304baffd03ac6d291738bb1a904afeaa9693/CHANGELOG.md",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/CHANGELOG.md?ref=83f3304baffd03ac6d291738bb1a904afeaa9693",
        "patch": "@@ -2,6 +2,21 @@\n \n All notable changes to this project will be documented in this file.\n \n+# Changelog\n+\n+All notable changes to this project will be documented in this file.\n+\n+## [0.2.0] - Unreleased\n+\n+### Highlights\n+- Added interactive confirmation before running `cactus-prepare`, allowing users to remove stale `--outDir`/`--jobStore` directories in advance.\n+- Enhanced execution feedback with Rich-based progress indicators, end-of-run summaries, and optional verbose streaming of all command output.\n+- Surfaced plan-level verbose state in the UI (toggle with `V`) and overview rendering, keeping the terminal quiet by default while filtering RaMAx graph verification noise.\n+\n+### Documentation & Tooling\n+- Updated README with the new verbose shortcut and pre-run cleanup behaviour.\n+- Expanded `PlanRunner` logging to emphasise failures and log locations.\n+\n ## [0.1.0] - 2025-10-25\n \n The inaugural release of Cactus-RaMAx introduces an interactive workflow for remixing `cactus-prepare` plans with RaMAx substitutions."
      },
      {
        "sha": "52460b6281bdc139c63b6f06b8d6111c6540f46f",
        "filename": "README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/malabz/Cax/blob/83f3304baffd03ac6d291738bb1a904afeaa9693/README.md",
        "raw_url": "https://github.com/malabz/Cax/raw/83f3304baffd03ac6d291738bb1a904afeaa9693/README.md",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/README.md?ref=83f3304baffd03ac6d291738bb1a904afeaa9693",
        "patch": "@@ -31,6 +31,7 @@ cax\n ```\n \n - If you do not pass `--prepare-args` or `--from-file`, the program first prompts you for the full `cactus-prepare` command (for example `cactus-prepare examples/... --outDir ...`).\n+- Before running the command, CAX checks whether the requested `--outDir` or `--jobStore` already exist and offers to delete them so the run can start from a clean slate.\n - After execution completes, the UI displays the parsed plan and lets you toggle RaMAx replacements before running or exporting.\n - Scripted usage is still supported:\n   ```bash\n@@ -50,6 +51,7 @@ cax\n - `S`: export all commands to `ramax_commands.txt` inside the chosen output directory.\n - `P`: refresh the overview table.\n - `Q`: quit the UI.\n+- `V`: toggle verbose logging (when on, all command output is streamed to the console; off by default).\n \n When RaMAx is enabled for a round or subtree, execution stops on the first failure—it does not fall back to cactus `blast`/`align` automatically.\n "
      },
      {
        "sha": "70426f8528b330e41cc9ace2847ca726c8af0242",
        "filename": "VERSION",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/malabz/Cax/blob/83f3304baffd03ac6d291738bb1a904afeaa9693/VERSION",
        "raw_url": "https://github.com/malabz/Cax/raw/83f3304baffd03ac6d291738bb1a904afeaa9693/VERSION",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/VERSION?ref=83f3304baffd03ac6d291738bb1a904afeaa9693",
        "patch": "@@ -1 +1 @@\n-0.1.0\n+0.2.0-dev"
      },
      {
        "sha": "b74a54c347262aaa23a39c11150e0d5cbe1e82f2",
        "filename": "cax/cli.py",
        "status": "modified",
        "additions": 97,
        "deletions": 1,
        "changes": 98,
        "blob_url": "https://github.com/malabz/Cax/blob/83f3304baffd03ac6d291738bb1a904afeaa9693/cax%2Fcli.py",
        "raw_url": "https://github.com/malabz/Cax/raw/83f3304baffd03ac6d291738bb1a904afeaa9693/cax%2Fcli.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fcli.py?ref=83f3304baffd03ac6d291738bb1a904afeaa9693",
        "patch": "@@ -8,6 +8,7 @@\n \n import typer\n from rich import print\n+import shutil\n \n from . import command_prompt, parser, render, ui as ui_module\n from .runner import PlanRunner\n@@ -55,16 +56,111 @@ def ui(\n         prepare_args = prompt_result.args\n         executable = prompt_result.executable or executable\n \n+    out_dir_preview, job_store_preview = _prepare_plan_preview(executable, prepare_args, from_file)\n+    _ensure_clean_environment(out_dir_preview, job_store_preview)\n     text = _load_prepare_text(prepare_args, from_file, executable=executable)\n     plan = parser.parse_prepare_script(text)\n     result = ui_module.launch(plan)\n     plan = result.plan\n     if result.action == \"run\" or run_after:\n-        runner = PlanRunner(plan)\n+        runner = PlanRunner(plan, verbose=plan.verbose)\n         runner.run()\n     else:\n         print(render.plan_overview(plan))\n \n \n if __name__ == \"__main__\":\n     app()\n+\n+\n+def _prepare_plan_preview(\n+    executable: str,\n+    prepare_args: Optional[str],\n+    from_file: Optional[Path],\n+) -> tuple[Optional[str], Optional[str]]:\n+    \"\"\"Return the prospective --outDir and --jobStore before running cactus-prepare.\"\"\"\n+\n+    if from_file:\n+        try:\n+            text = Path(from_file).read_text(encoding=\"utf-8\")\n+            plan = parser.parse_prepare_script(text)\n+            return plan.out_dir, None\n+        except OSError:\n+            return None, None\n+    if prepare_args is None:\n+        return None, None\n+    tokens = shlex.split(prepare_args)\n+    out_dir = _extract_flag(tokens, \"--outDir\")\n+    out_seq = _extract_flag(tokens, \"--outSeqFile\")\n+    # If outDir not provided but outSeqFile is, derive from it.\n+    if out_dir is None and out_seq:\n+        out_dir = str(Path(out_seq).resolve().parent)\n+    job_store = _extract_flag(tokens, \"--jobStore\") or _extract_flag(tokens, \"--jobstore\")\n+    # Some users may pass --jobStore=file:/path or jobstore=...; leave as-is for now.\n+    return out_dir, job_store\n+\n+\n+def _extract_flag(tokens: list[str], flag: str) -> Optional[str]:\n+    for idx, tok in enumerate(tokens):\n+        if tok == flag and idx + 1 < len(tokens):\n+            return tokens[idx + 1]\n+        if tok.startswith(flag + \"=\"):\n+            return tok.split(\"=\", 1)[1]\n+    return None\n+\n+\n+def _ensure_clean_environment(out_dir: Optional[str], job_store: Optional[str]) -> None:\n+    \"\"\"Before running cactus-prepare, optionally clean existing output directories.\"\"\"\n+\n+    candidates: list[Path] = []\n+    if out_dir:\n+        out_path = _resolve_path(out_dir)\n+        candidates.append(out_path)\n+    if job_store:\n+        job_path = _resolve_path(job_store)\n+        candidates.append(job_path)\n+    # When no explicit jobStore is supplied, Toil uses subdirectories jobstore/0, etc.\n+    candidates.append(Path.cwd() / \"jobstore\")\n+\n+    existing: list[Path] = []\n+    seen: set[Path] = set()\n+    for path in candidates:\n+        resolved = path.resolve()\n+        if resolved.exists() and resolved not in seen:\n+            seen.add(resolved)\n+            existing.append(resolved)\n+\n+    if not existing:\n+        return\n+\n+    typer.echo(\"[cax] Warning: existing directories detected:\")\n+    for path in existing:\n+        try:\n+            relative = path.relative_to(Path.cwd())\n+            typer.echo(f\"  - {relative}\")\n+        except ValueError:\n+            typer.echo(f\"  - {path}\")\n+\n+    if typer.confirm(\"Delete these directories before running cactus-prepare?\", default=False):\n+        for path in existing:\n+            if not path.exists():\n+                continue\n+            try:\n+                if path.is_dir():\n+                    shutil.rmtree(path)\n+                else:\n+                    path.unlink()\n+            except OSError as exc:\n+                typer.echo(f\"[cax] Failed to remove {path}: {exc}\")\n+        typer.echo(\"[cax] Existing directories removed.\")\n+    else:\n+        typer.echo(\"[cax] Keeping existing directories (may reuse previous outputs).\")\n+\n+\n+def _resolve_path(path_like: str) -> Path:\n+    if path_like.startswith(\"file:\"):\n+        path_like = path_like.split(\":\", 1)[1]\n+    path = Path(path_like)\n+    if path.is_absolute():\n+        return path\n+    return (Path.cwd() / path).resolve()"
      },
      {
        "sha": "6791e558d04f54f1143991f3186e20af030a803d",
        "filename": "cax/models.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/malabz/Cax/blob/83f3304baffd03ac6d291738bb1a904afeaa9693/cax%2Fmodels.py",
        "raw_url": "https://github.com/malabz/Cax/raw/83f3304baffd03ac6d291738bb1a904afeaa9693/cax%2Fmodels.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fmodels.py?ref=83f3304baffd03ac6d291738bb1a904afeaa9693",
        "patch": "@@ -90,6 +90,7 @@ class Plan(BaseModel):\n     out_dir: Optional[str] = None\n     dry_run: bool = False\n     global_ramax_opts: list[str] = Field(default_factory=list)\n+    verbose: bool = False\n \n     @field_validator(\"out_seq_file\")\n     @classmethod"
      },
      {
        "sha": "8449ebcb87f8d8ce23628bf1cb73957b3cd2791b",
        "filename": "cax/render.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/malabz/Cax/blob/83f3304baffd03ac6d291738bb1a904afeaa9693/cax%2Frender.py",
        "raw_url": "https://github.com/malabz/Cax/raw/83f3304baffd03ac6d291738bb1a904afeaa9693/cax%2Frender.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Frender.py?ref=83f3304baffd03ac6d291738bb1a904afeaa9693",
        "patch": "@@ -35,6 +35,7 @@ def plan_overview(plan: Plan) -> str:\n         )\n \n     console.print(table)\n+    console.print(f\"Verbose logging: {'on' if plan.verbose else 'off'}\")\n     return buf.getvalue()\n \n "
      },
      {
        "sha": "0c8b9e864360690a843a644cd12382dededd521d",
        "filename": "cax/runner.py",
        "status": "modified",
        "additions": 196,
        "deletions": 27,
        "changes": 223,
        "blob_url": "https://github.com/malabz/Cax/blob/83f3304baffd03ac6d291738bb1a904afeaa9693/cax%2Frunner.py",
        "raw_url": "https://github.com/malabz/Cax/raw/83f3304baffd03ac6d291738bb1a904afeaa9693/cax%2Frunner.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Frunner.py?ref=83f3304baffd03ac6d291738bb1a904afeaa9693",
        "patch": "@@ -2,19 +2,33 @@\n from __future__ import annotations\n \n import os\n+from contextlib import nullcontext\n from pathlib import Path\n import subprocess\n import time\n from typing import Optional\n \n+from rich.console import Console\n+from rich.progress import Progress, SpinnerColumn, TextColumn, TimeElapsedColumn, TaskID\n+\n from . import planner\n from .models import Plan\n \n \n+IMPORTANT_KEYWORDS = (\"error\", \"failed\", \"exception\", \"critical\")\n+\n+\n class PlanRunner:\n     \"\"\"Run a :class:`~cax.models.Plan` sequentially with logging.\"\"\"\n \n-    def __init__(self, plan: Plan, base_dir: Optional[Path] = None, env: Optional[dict[str, str]] = None, mirror_stdout: bool = True):\n+    def __init__(\n+        self,\n+        plan: Plan,\n+        base_dir: Optional[Path] = None,\n+        env: Optional[dict[str, str]] = None,\n+        mirror_stdout: bool = True,\n+        verbose: bool = False,\n+    ):\n         self.plan = plan\n         self.base_dir = Path(base_dir) if base_dir else Path.cwd()\n         self.env = os.environ.copy()\n@@ -23,36 +37,120 @@ def __init__(self, plan: Plan, base_dir: Optional[Path] = None, env: Optional[di\n         self.log_root = self._derive_log_root()\n         self.master_log_path = self.log_root / \"cax-run.log\"\n         self.mirror_stdout = mirror_stdout\n+        self.console = Console(stderr=True)\n+        self.verbose = verbose\n \n     def run(self, dry_run: Optional[bool] = None) -> None:\n         \"\"\"Execute the plan. When ``dry_run`` is True, commands are only logged.\"\"\"\n \n         effective_dry = self.plan.dry_run if dry_run is None else dry_run\n         planned_commands = planner.build_execution_plan(self.plan, self.base_dir)\n         self.log_root.mkdir(parents=True, exist_ok=True)\n+        total_commands = len(planned_commands)\n+        completed_commands = 0\n+        failure_command: planner.PlannedCommand | None = None\n+\n+        progress_cm = (\n+            Progress(\n+                SpinnerColumn(),\n+                TextColumn(\"{task.description}\"),\n+                TextColumn(\"({task.completed}/{task.total} done)\"),\n+                TextColumn(\"[dim]{task.fields[remaining]} left[/dim]\"),\n+                TimeElapsedColumn(),\n+                console=self.console,\n+                transient=True,\n+            )\n+            if self.mirror_stdout and not self.verbose\n+            else nullcontext(None)\n+        )\n+\n         with self.master_log_path.open(\"a\", encoding=\"utf-8\") as master_log:\n-            for command in planned_commands:\n-                success = self._run_single(command, master_log, effective_dry)\n-                if not success:\n-                    raise RuntimeError(f\"Command failed: {command.display_name}\")\n+            with progress_cm as progress:\n+                overall_task: TaskID | None = None\n+                remaining = len(planned_commands)\n+                if isinstance(progress, Progress):\n+                    overall_task = progress.add_task(\n+                        \"Plan execution\",\n+                        total=remaining,\n+                        remaining=remaining,\n+                    )\n+                for command in planned_commands:\n+                    task_id: TaskID | None = None\n+                    if isinstance(progress, Progress):\n+                        progress.update(\n+                            overall_task,\n+                            description=f\"[cyan]{command.display_name}[/cyan]\",\n+                        )\n+                        task_id = overall_task\n+                    success = self._run_single(\n+                        command,\n+                        master_log,\n+                        effective_dry,\n+                        progress if isinstance(progress, Progress) else None,\n+                        task_id,\n+                    )\n+                    if not success:\n+                        if isinstance(progress, Progress):\n+                            progress.update(\n+                                overall_task,\n+                                description=f\"[red]✖ {command.display_name}[/red]\",\n+                            )\n+                        failure_command = command\n+                        break\n+                    if isinstance(progress, Progress) and overall_task is not None:\n+                        remaining -= 1\n+                        progress.advance(overall_task)\n+                        progress.update(\n+                            overall_task,\n+                            description=f\"[green]{command.display_name}[/green]\",\n+                            remaining=remaining,\n+                        )\n+                    completed_commands += 1\n+\n+        if failure_command is not None:\n+            if self.mirror_stdout:\n+                self.console.print(\n+                    f\"[red]Plan failed[/red]: {completed_commands}/{total_commands} commands succeeded. \"\n+                    f\"Failed step: [bold]{failure_command.display_name}[/bold].\"\n+                )\n+                if failure_command.log_path:\n+                    self.console.print(f\"  • Step log: {failure_command.log_path}\")\n+                self.console.print(f\"  • Master log: {self.master_log_path}\")\n+            raise RuntimeError(f\"Command failed: {failure_command.display_name}\")\n+\n+        if self.mirror_stdout:\n+            self.console.print(\n+                f\"[green]Plan completed[/green]: {completed_commands}/{total_commands} commands succeeded.\"\n+            )\n+            self.console.print(f\"Logs written to {self.master_log_path}\")\n \n-    def _run_single(self, command: planner.PlannedCommand, master_log, dry_run: bool) -> bool:\n+    def _run_single(\n+        self,\n+        command: planner.PlannedCommand,\n+        master_log,\n+        dry_run: bool,\n+        progress: Optional[Progress],\n+        task_id,\n+    ) -> bool:\n         start_time = time.time()\n         preview = command.shell_preview()\n         master_log.write(f\"[start] {command.display_name}: {preview}\\n\")\n         master_log.flush()\n-        if self.mirror_stdout:\n-            print(f\"[start] {command.display_name}: {preview}\", flush=True)\n+        if progress is None and self.mirror_stdout:\n+            self.console.print(f\"[cyan][start][/cyan] {command.display_name}: {preview}\")\n \n         if dry_run:\n-            if command.log_path:\n-                command.log_path.parent.mkdir(parents=True, exist_ok=True)\n-                with command.log_path.open(\"a\", encoding=\"utf-8\") as log_file:\n-                    log_file.write(f\"# DRY RUN\\n# {preview}\\n\")\n-            master_log.write(f\"[skip] dry-run complete in {time.time() - start_time:.1f}s\\n\")\n+            self._log_dry_run(command, preview)\n+            elapsed = time.time() - start_time\n+            master_log.write(f\"[skip] dry-run complete in {elapsed:.1f}s\\n\")\n             master_log.flush()\n-            if self.mirror_stdout:\n-                print(f\"[skip] dry-run complete in {time.time() - start_time:.1f}s\", flush=True)\n+            if progress is not None and task_id is not None:\n+                progress.update(\n+                    task_id,\n+                    description=f\"[yellow]⏭ {command.display_name} (dry-run)[/yellow]\",\n+                )\n+            elif self.mirror_stdout:\n+                self.console.print(f\"[yellow][skip][/yellow] {command.display_name} (dry-run {elapsed:.1f}s)\")\n             return True\n \n         if command.workdir:\n@@ -74,28 +172,99 @@ def _run_single(self, command: planner.PlannedCommand, master_log, dry_run: bool\n                     text=True,\n                 )\n             except OSError as exc:\n-                message = f\"[error] Failed to launch {command.display_name}: {exc}\\n\"\n-                step_log.write(message)\n-                master_log.write(message)\n-                master_log.flush()\n-                if self.mirror_stdout:\n-                    print(message, end=\"\", flush=True)\n-                return False\n+                return self._handle_launch_failure(\n+                    command,\n+                    exc,\n+                    master_log,\n+                    step_log,\n+                    progress,\n+                    task_id,\n+                )\n             assert proc.stdout is not None\n             for line in proc.stdout:\n                 step_log.write(line)\n                 master_log.write(line)\n-                if self.mirror_stdout:\n-                    print(line, end=\"\", flush=True)\n+                if self.verbose:\n+                    self._emit_full(line)\n+                elif self._should_surface(line):\n+                    self._emit_important(line, progress)\n             return_code = proc.wait()\n             duration = time.time() - start_time\n             step_log.write(f\"\\n# Exit code: {return_code} ({duration:.1f}s)\\n\")\n             step_log.flush()\n             master_log.write(f\"[end] {command.display_name} -> {return_code} ({duration:.1f}s)\\n\")\n             master_log.flush()\n-            if self.mirror_stdout:\n-                print(f\"[end] {command.display_name} -> {return_code} ({duration:.1f}s)\", flush=True)\n-            return return_code == 0\n+\n+            if return_code != 0:\n+                if progress is not None and task_id is not None:\n+                    progress.update(task_id, description=f\"[red]✖ {command.display_name} ({duration:.1f}s)[/red]\")\n+                elif self.mirror_stdout:\n+                    self.console.print(f\"[red][end][/red] {command.display_name} -> {return_code} ({duration:.1f}s)\")\n+                return False\n+\n+            if progress is not None and task_id is not None:\n+                progress.update(task_id, description=f\"[green]✔ {command.display_name} ({duration:.1f}s)[/green]\")\n+            elif self.mirror_stdout:\n+                self.console.print(f\"[green][end][/green] {command.display_name} ({duration:.1f}s)\")\n+            return True\n+\n+    def _log_dry_run(self, command: planner.PlannedCommand, preview: str) -> None:\n+        if command.log_path:\n+            command.log_path.parent.mkdir(parents=True, exist_ok=True)\n+            with command.log_path.open(\"a\", encoding=\"utf-8\") as log_file:\n+                log_file.write(f\"# DRY RUN\\n# {preview}\\n\")\n+\n+    def _handle_launch_failure(\n+        self,\n+        command: planner.PlannedCommand,\n+        exc: OSError,\n+        master_log,\n+        step_log,\n+        progress: Optional[Progress],\n+        task_id,\n+    ) -> bool:\n+        message = f\"[error] Failed to launch {command.display_name}: {exc}\\n\"\n+        step_log.write(message)\n+        master_log.write(message)\n+        master_log.flush()\n+        if progress is not None and task_id is not None:\n+            progress.update(task_id, description=f\"[red]✖ {command.display_name} (launch failed)[/red]\")\n+        elif self.mirror_stdout:\n+            self.console.print(f\"[red]{message.rstrip()}[/red]\")\n+        return False\n+\n+    def _emit_important(self, line: str, progress: Optional[Progress]) -> None:\n+        text = line.rstrip()\n+        if not text:\n+            return\n+        if progress is not None:\n+            progress.console.log(text)\n+        elif self.mirror_stdout:\n+            self.console.log(text)\n+\n+    def _should_surface(self, line: str) -> bool:\n+        if self.verbose:\n+            return True\n+        lowered = line.lower()\n+        suppress_phrases = (\n+            \"graph correctness verification\",\n+            \"verification summary\",\n+            \"pointer_validity\",\n+            \"coordinate_overlap\",\n+            \"total errors\",\n+            \"error breakdown by type\",\n+            \"reference species expected to have overlapping segments\",\n+        )\n+        if any(phrase in lowered for phrase in suppress_phrases):\n+            return False\n+        return any(keyword in lowered for keyword in IMPORTANT_KEYWORDS)\n+\n+    def _emit_full(self, line: str) -> None:\n+        text = line.rstrip()\n+        if not text:\n+            return\n+        if self.mirror_stdout:\n+            self.console.print(text)\n \n     def _derive_log_root(self) -> Path:\n         if self.plan.out_dir:"
      },
      {
        "sha": "a1820d4cf8b8518c22de9a0340691f04628a1382",
        "filename": "cax/ui.py",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/malabz/Cax/blob/83f3304baffd03ac6d291738bb1a904afeaa9693/cax%2Fui.py",
        "raw_url": "https://github.com/malabz/Cax/raw/83f3304baffd03ac6d291738bb1a904afeaa9693/cax%2Fui.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fui.py?ref=83f3304baffd03ac6d291738bb1a904afeaa9693",
        "patch": "@@ -245,6 +245,7 @@ class PlanUIApp(App[UIResult]):\n         Binding(\"s\", \"save_commands\", \"Save commands\"),\n         Binding(\"r\", \"run_plan\", \"Run\"),\n         Binding(\"q\", \"quit\", \"Quit\"),\n+        Binding(\"v\", \"toggle_verbose\", \"Toggle verbose\"),\n     ]\n \n     def __init__(self, plan: Plan, base_dir: Optional[Path] = None):\n@@ -348,6 +349,24 @@ def action_save_commands(self) -> None:\n     def action_quit(self) -> None:\n         self.exit(UIResult(plan=self.plan, action=\"quit\"))\n \n+    def action_toggle_verbose(self) -> None:\n+        self.plan.verbose = not self.plan.verbose\n+        message = \"Verbose logging enabled\" if self.plan.verbose else \"Verbose logging disabled\"\n+        if self.alignment_tree and self.tree_widget:\n+            node = self._selected_alignment_node()\n+            if node:\n+                self._show_alignment_node(node, status=message)\n+            elif self.detail_panel:\n+                self.detail_panel.update(message)\n+        elif self.round_list and self.round_items:\n+            index = self.round_list.index or 0\n+            if index < len(self.plan.rounds):\n+                self._show_round(index, status=message)\n+            elif self.detail_panel:\n+                self.detail_panel.update(message)\n+        elif self.detail_panel:\n+            self.detail_panel.update(message)\n+\n     def action_edit_round(self) -> None:\n         if self.alignment_tree and self.tree_widget:\n             node = self._selected_alignment_node()"
      }
    ]
  }
}