{
  "cached_at": "2025-12-20T14:35:11.477447",
  "commit_sha": "5c62f9b5dbdab43440503e22b8799d27ff39faf0",
  "repo": "malabz/Cax",
  "data": {
    "sha": "5c62f9b5dbdab43440503e22b8799d27ff39faf0",
    "node_id": "C_kwDOPt61otoAKDVjNjJmOWI1ZGJkYWI0MzQ0MDUwM2UyMmI4Nzk5ZDI3ZmYzOWZhZjA",
    "commit": {
      "author": {
        "name": "metaphysicser",
        "email": "zpl010720@qq.com",
        "date": "2025-11-08T09:19:18Z"
      },
      "committer": {
        "name": "metaphysicser",
        "email": "zpl010720@qq.com",
        "date": "2025-11-08T09:19:18Z"
      },
      "message": "feat: enhance quiet progress telemetry and release 0.2.2",
      "tree": {
        "sha": "219900cf454a4bd6f38eb096b125aa96d67d760c",
        "url": "https://api.github.com/repos/malabz/Cax/git/trees/219900cf454a4bd6f38eb096b125aa96d67d760c"
      },
      "url": "https://api.github.com/repos/malabz/Cax/git/commits/5c62f9b5dbdab43440503e22b8799d27ff39faf0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null,
        "verified_at": null
      }
    },
    "url": "https://api.github.com/repos/malabz/Cax/commits/5c62f9b5dbdab43440503e22b8799d27ff39faf0",
    "html_url": "https://github.com/malabz/Cax/commit/5c62f9b5dbdab43440503e22b8799d27ff39faf0",
    "comments_url": "https://api.github.com/repos/malabz/Cax/commits/5c62f9b5dbdab43440503e22b8799d27ff39faf0/comments",
    "author": {
      "login": "metaphysicser",
      "id": 62839294,
      "node_id": "MDQ6VXNlcjYyODM5Mjk0",
      "avatar_url": "https://avatars.githubusercontent.com/u/62839294?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/metaphysicser",
      "html_url": "https://github.com/metaphysicser",
      "followers_url": "https://api.github.com/users/metaphysicser/followers",
      "following_url": "https://api.github.com/users/metaphysicser/following{/other_user}",
      "gists_url": "https://api.github.com/users/metaphysicser/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/metaphysicser/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/metaphysicser/subscriptions",
      "organizations_url": "https://api.github.com/users/metaphysicser/orgs",
      "repos_url": "https://api.github.com/users/metaphysicser/repos",
      "events_url": "https://api.github.com/users/metaphysicser/events{/privacy}",
      "received_events_url": "https://api.github.com/users/metaphysicser/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "committer": {
      "login": "metaphysicser",
      "id": 62839294,
      "node_id": "MDQ6VXNlcjYyODM5Mjk0",
      "avatar_url": "https://avatars.githubusercontent.com/u/62839294?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/metaphysicser",
      "html_url": "https://github.com/metaphysicser",
      "followers_url": "https://api.github.com/users/metaphysicser/followers",
      "following_url": "https://api.github.com/users/metaphysicser/following{/other_user}",
      "gists_url": "https://api.github.com/users/metaphysicser/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/metaphysicser/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/metaphysicser/subscriptions",
      "organizations_url": "https://api.github.com/users/metaphysicser/orgs",
      "repos_url": "https://api.github.com/users/metaphysicser/repos",
      "events_url": "https://api.github.com/users/metaphysicser/events{/privacy}",
      "received_events_url": "https://api.github.com/users/metaphysicser/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4c088b5d4e1d277a416947f05903296701a514aa",
        "url": "https://api.github.com/repos/malabz/Cax/commits/4c088b5d4e1d277a416947f05903296701a514aa",
        "html_url": "https://github.com/malabz/Cax/commit/4c088b5d4e1d277a416947f05903296701a514aa"
      }
    ],
    "stats": {
      "total": 206,
      "additions": 199,
      "deletions": 7
    },
    "files": [
      {
        "sha": "4a9f056d2eec816b89f15b16feb2882cdce18158",
        "filename": "CHANGELOG.md",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/malabz/Cax/blob/5c62f9b5dbdab43440503e22b8799d27ff39faf0/CHANGELOG.md",
        "raw_url": "https://github.com/malabz/Cax/raw/5c62f9b5dbdab43440503e22b8799d27ff39faf0/CHANGELOG.md",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/CHANGELOG.md?ref=5c62f9b5dbdab43440503e22b8799d27ff39faf0",
        "patch": "@@ -2,7 +2,7 @@\n \n All notable changes to this project will be documented in this file.\n \n-## [0.2.2] - Unreleased\n+## [0.2.2] - 2025-11-08\n \n ### UI\n - The cactus-prepare wizard now lives inside a full-height scroll container with a dedicated footer so form fields remain focusable while actions stay pinned, even in narrow or short terminals.\n@@ -14,6 +14,10 @@ All notable changes to this project will be documented in this file.\n - `cax ui` still accepts `--threads N`, but the value now seeds the Run Settings dialog (or the post-UI prompt when `--run-after` is used) instead of bloating the plan definition; the planner applies `--maxCores/--threads` overrides only at execution time.\n - Plan serialization drops the `verbose`/`thread_count` fields, keeping plan files focused on cactus/RaMAx steps while run-only options live alongside the executor.\n \n+### Runner\n+- Enhanced the quiet-mode progress bar with wait time, CPU utilization, memory usage, and peak memory columns, while printing the full command in a separate line so the bar stays readable on narrow terminals.\n+- Added a psutil-backed telemetry thread that periodically aggregates CPU and memory stats from the running command and its descendants, synchronizing the metrics on dry-run skips, failures, and successful completions.\n+\n ## [0.2.1] - 2025-11-07\n \n ### Highlights"
      },
      {
        "sha": "ee1372d33a29e27945406f0527f8af8e6ee119c9",
        "filename": "VERSION",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/malabz/Cax/blob/5c62f9b5dbdab43440503e22b8799d27ff39faf0/VERSION",
        "raw_url": "https://github.com/malabz/Cax/raw/5c62f9b5dbdab43440503e22b8799d27ff39faf0/VERSION",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/VERSION?ref=5c62f9b5dbdab43440503e22b8799d27ff39faf0",
        "patch": "@@ -1 +1 @@\n-0.2.1\n+0.2.2"
      },
      {
        "sha": "42afd99fe35fa78ef5e7177e860dae57300a0aea",
        "filename": "cax/runner.py",
        "status": "modified",
        "additions": 192,
        "deletions": 4,
        "changes": 196,
        "blob_url": "https://github.com/malabz/Cax/blob/5c62f9b5dbdab43440503e22b8799d27ff39faf0/cax%2Frunner.py",
        "raw_url": "https://github.com/malabz/Cax/raw/5c62f9b5dbdab43440503e22b8799d27ff39faf0/cax%2Frunner.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Frunner.py?ref=5c62f9b5dbdab43440503e22b8799d27ff39faf0",
        "patch": "@@ -5,11 +5,14 @@\n from contextlib import nullcontext\n from pathlib import Path\n import subprocess\n+import threading\n import time\n from typing import Optional\n \n+import psutil\n from rich.console import Console\n from rich.progress import Progress, SpinnerColumn, TextColumn, TimeElapsedColumn, TaskID\n+from rich.text import Text\n \n from . import planner\n from .models import Plan, RunSettings\n@@ -62,6 +65,10 @@ def run(self, dry_run: Optional[bool] = None) -> None:\n                 TextColumn(\"{task.description}\"),\n                 TextColumn(\"({task.completed}/{task.total} done)\"),\n                 TextColumn(\"[dim]{task.fields[remaining]} left[/dim]\"),\n+                TextColumn(\"wait {task.fields[wait]}\", style=\"magenta\"),\n+                TextColumn(\"CPU {task.fields[cpu]}\", style=\"yellow\"),\n+                TextColumn(\"mem {task.fields[mem]}\", style=\"cyan\"),\n+                TextColumn(\"peak {task.fields[mem_peak]}\", style=\"cyan\"),\n                 TimeElapsedColumn(),\n                 console=self.console,\n                 transient=True,\n@@ -79,21 +86,32 @@ def run(self, dry_run: Optional[bool] = None) -> None:\n                         \"Plan execution\",\n                         total=remaining,\n                         remaining=remaining,\n+                        wait=\"0.0s\",\n+                        cpu=\"--\",\n+                        mem=\"--\",\n+                        mem_peak=\"--\",\n                     )\n                 for command in planned_commands:\n+                    preview = command.shell_preview()\n                     task_id: TaskID | None = None\n                     if isinstance(progress, Progress):\n                         progress.update(\n                             overall_task,\n                             description=f\"[cyan]{command.display_name}[/cyan]\",\n+                            wait=\"0.0s\",\n+                            cpu=\"--\",\n+                            mem=\"--\",\n+                            mem_peak=\"--\",\n                         )\n+                        self._announce_command(preview, progress)\n                         task_id = overall_task\n                     success = self._run_single(\n                         command,\n                         master_log,\n                         effective_dry,\n                         progress if isinstance(progress, Progress) else None,\n                         task_id,\n+                        preview,\n                     )\n                     if not success:\n                         if isinstance(progress, Progress):\n@@ -137,9 +155,10 @@ def _run_single(\n         dry_run: bool,\n         progress: Optional[Progress],\n         task_id,\n+        preview: Optional[str] = None,\n     ) -> bool:\n         start_time = time.time()\n-        preview = command.shell_preview()\n+        preview = preview or command.shell_preview()\n         master_log.write(f\"[start] {command.display_name}: {preview}\\n\")\n         master_log.flush()\n         if progress is None and self.mirror_stdout:\n@@ -154,6 +173,7 @@ def _run_single(\n                 progress.update(\n                     task_id,\n                     description=f\"[yellow]⏭ {command.display_name} (dry-run)[/yellow]\",\n+                    **_basic_metric_fields(elapsed),\n                 )\n             elif self.mirror_stdout:\n                 self.console.print(f\"[yellow][skip][/yellow] {command.display_name} (dry-run {elapsed:.1f}s)\")\n@@ -165,6 +185,7 @@ def _run_single(\n         step_log_path = command.log_path or (self.log_root / f\"{command.display_name}.log\")\n         step_log_path.parent.mkdir(parents=True, exist_ok=True)\n \n+        telemetry: _CommandTelemetry | None = None\n         with step_log_path.open(\"a\", encoding=\"utf-8\") as step_log:\n             step_log.write(f\"# Command: {preview}\\n\")\n             step_log.flush()\n@@ -185,8 +206,13 @@ def _run_single(\n                     step_log,\n                     progress,\n                     task_id,\n+                    preview,\n                 )\n             assert proc.stdout is not None\n+            if progress is not None and task_id is not None:\n+                telemetry_candidate = _CommandTelemetry(progress, task_id, start_time)\n+                if telemetry_candidate.start(proc.pid):\n+                    telemetry = telemetry_candidate\n             for line in proc.stdout:\n                 step_log.write(line)\n                 master_log.write(line)\n@@ -196,20 +222,34 @@ def _run_single(\n                     self._emit_important(line, progress)\n             return_code = proc.wait()\n             duration = time.time() - start_time\n+            telemetry_fields: dict[str, str] = {}\n+            if progress is not None and task_id is not None:\n+                if telemetry is not None:\n+                    telemetry_fields = telemetry.stop(duration)\n+                else:\n+                    telemetry_fields = _basic_metric_fields(duration)\n             step_log.write(f\"\\n# Exit code: {return_code} ({duration:.1f}s)\\n\")\n             step_log.flush()\n             master_log.write(f\"[end] {command.display_name} -> {return_code} ({duration:.1f}s)\\n\")\n             master_log.flush()\n \n             if return_code != 0:\n                 if progress is not None and task_id is not None:\n-                    progress.update(task_id, description=f\"[red]✖ {command.display_name} ({duration:.1f}s)[/red]\")\n+                    progress.update(\n+                        task_id,\n+                        description=f\"[red]✖ {command.display_name} ({duration:.1f}s)[/red]\",\n+                        **telemetry_fields,\n+                    )\n                 elif self.mirror_stdout:\n                     self.console.print(f\"[red][end][/red] {command.display_name} -> {return_code} ({duration:.1f}s)\")\n                 return False\n \n             if progress is not None and task_id is not None:\n-                progress.update(task_id, description=f\"[green]✔ {command.display_name} ({duration:.1f}s)[/green]\")\n+                progress.update(\n+                    task_id,\n+                    description=f\"[green]✔ {command.display_name} ({duration:.1f}s)[/green]\",\n+                    **telemetry_fields,\n+                )\n             elif self.mirror_stdout:\n                 self.console.print(f\"[green][end][/green] {command.display_name} ({duration:.1f}s)\")\n             return True\n@@ -220,6 +260,17 @@ def _log_dry_run(self, command: planner.PlannedCommand, preview: str) -> None:\n             with command.log_path.open(\"a\", encoding=\"utf-8\") as log_file:\n                 log_file.write(f\"# DRY RUN\\n# {preview}\\n\")\n \n+    def _announce_command(self, preview: str, progress: Optional[Progress]) -> None:\n+        text = Text(\"command \", style=\"dim\", overflow=\"fold\", no_wrap=False)\n+        text.append(preview)\n+        console: Console | None = None\n+        if progress is not None:\n+            console = progress.console\n+        elif self.mirror_stdout:\n+            console = self.console\n+        if console is not None:\n+            console.print(text)\n+\n     def _handle_launch_failure(\n         self,\n         command: planner.PlannedCommand,\n@@ -228,13 +279,18 @@ def _handle_launch_failure(\n         step_log,\n         progress: Optional[Progress],\n         task_id,\n+        preview: str,\n     ) -> bool:\n         message = f\"[error] Failed to launch {command.display_name}: {exc}\\n\"\n         step_log.write(message)\n         master_log.write(message)\n         master_log.flush()\n         if progress is not None and task_id is not None:\n-            progress.update(task_id, description=f\"[red]✖ {command.display_name} (launch failed)[/red]\")\n+            progress.update(\n+                task_id,\n+                description=f\"[red]✖ {command.display_name} (launch failed)[/red]\",\n+                **_basic_metric_fields(0.0),\n+            )\n         elif self.mirror_stdout:\n             self.console.print(f\"[red]{message.rstrip()}[/red]\")\n         return False\n@@ -278,6 +334,138 @@ def _derive_log_root(self) -> Path:\n         return (self.base_dir / \"logs\").resolve()\n \n \n+def _format_duration(seconds: float) -> str:\n+    if seconds < 0:\n+        seconds = 0.0\n+    if seconds < 60:\n+        return f\"{seconds:.1f}s\"\n+    minutes, sec = divmod(int(seconds), 60)\n+    hours, minutes = divmod(minutes, 60)\n+    if hours:\n+        return f\"{hours}h{minutes:02d}m\"\n+    return f\"{minutes}m{sec:02d}s\"\n+\n+\n+def _format_bytes(value: int) -> str:\n+    if value <= 0:\n+        return \"0B\"\n+    units = (\"B\", \"KB\", \"MB\", \"GB\", \"TB\")\n+    num = float(value)\n+    for unit in units:\n+        if num < 1024 or unit == units[-1]:\n+            return f\"{num:.1f}{unit}\"\n+        num /= 1024\n+    return f\"{num:.1f}TB\"\n+\n+\n+def _format_cpu(value: Optional[float]) -> str:\n+    if value is None or value < 0:\n+        return \"--\"\n+    return f\"{value:.1f}%\"\n+\n+\n+def _basic_metric_fields(elapsed: float) -> dict[str, str]:\n+    return {\n+        \"wait\": _format_duration(elapsed),\n+        \"cpu\": \"--\",\n+        \"mem\": \"--\",\n+        \"mem_peak\": \"--\",\n+    }\n+\n+\n+class _CommandTelemetry:\n+    \"\"\"Collect per-step CPU and memory stats for the progress bar.\"\"\"\n+\n+    def __init__(\n+        self,\n+        progress: Progress,\n+        task_id: TaskID,\n+        start_time: float,\n+        interval: float = 0.5,\n+    ) -> None:\n+        self.progress = progress\n+        self.task_id = task_id\n+        self.start_time = start_time\n+        self.interval = interval\n+        self._stop_event = threading.Event()\n+        self._thread: threading.Thread | None = None\n+        self._process: psutil.Process | None = None\n+        self._peak_bytes = 0\n+        self._latest: dict[str, str] = _basic_metric_fields(0.0)\n+\n+    def start(self, pid: int) -> bool:\n+        try:\n+            self._process = psutil.Process(pid)\n+        except psutil.Error:\n+            return False\n+        self._prime_cpu_counters(self._process)\n+        self._thread = threading.Thread(target=self._run, daemon=True)\n+        self._thread.start()\n+        return True\n+\n+    def stop(self, final_duration: float) -> dict[str, str]:\n+        if self._thread is not None:\n+            self._stop_event.set()\n+            self._thread.join(timeout=2.0)\n+        final_fields = dict(self._latest)\n+        final_fields[\"wait\"] = _format_duration(final_duration)\n+        return final_fields\n+\n+    def _run(self) -> None:\n+        while not self._stop_event.wait(self.interval):\n+            self._update_fields()\n+        self._update_fields()\n+\n+    def _update_fields(self) -> None:\n+        fields = dict(self._latest)\n+        elapsed = time.time() - self.start_time\n+        fields[\"wait\"] = _format_duration(elapsed)\n+        process = self._process\n+        if process is not None:\n+            cpu_value, mem_bytes = self._collect_stats(process)\n+            if cpu_value is not None:\n+                fields[\"cpu\"] = _format_cpu(cpu_value)\n+            if mem_bytes is not None:\n+                self._peak_bytes = max(self._peak_bytes, mem_bytes)\n+                fields[\"mem\"] = _format_bytes(mem_bytes)\n+                fields[\"mem_peak\"] = _format_bytes(self._peak_bytes)\n+        self._latest = fields\n+        self.progress.update(self.task_id, **fields)\n+\n+    def _collect_stats(self, root: psutil.Process) -> tuple[Optional[float], Optional[int]]:\n+        total_cpu = 0.0\n+        total_mem = 0\n+        sampled = False\n+        try:\n+            processes = [root, *root.children(recursive=True)]\n+        except psutil.Error:\n+            return None, None\n+        for proc in processes:\n+            try:\n+                with proc.oneshot():\n+                    cpu_part = proc.cpu_percent(interval=None)\n+                    mem_info = proc.memory_info()\n+            except psutil.Error:\n+                continue\n+            sampled = True\n+            total_cpu += cpu_part\n+            total_mem += mem_info.rss\n+        if not sampled:\n+            return None, None\n+        return total_cpu, total_mem\n+\n+    def _prime_cpu_counters(self, process: psutil.Process) -> None:\n+        try:\n+            processes = [process, *process.children(recursive=True)]\n+        except psutil.Error:\n+            processes = [process]\n+        for proc in processes:\n+            try:\n+                proc.cpu_percent(interval=None)\n+            except psutil.Error:\n+                continue\n+\n+\n def _to_path(path_like: str, base_dir: Path) -> Path:\n     path = Path(path_like).expanduser()\n     if path.is_absolute():"
      },
      {
        "sha": "3ebcaaf76607c36e25d3b15b70c13ce78a5736fa",
        "filename": "pyproject.toml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/malabz/Cax/blob/5c62f9b5dbdab43440503e22b8799d27ff39faf0/pyproject.toml",
        "raw_url": "https://github.com/malabz/Cax/raw/5c62f9b5dbdab43440503e22b8799d27ff39faf0/pyproject.toml",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/pyproject.toml?ref=5c62f9b5dbdab43440503e22b8799d27ff39faf0",
        "patch": "@@ -4,7 +4,7 @@ build-backend = \"hatchling.build\"\n \n [project]\n name = \"cactus-ramax\"\n-version = \"0.1.0\"\n+version = \"0.2.2\"\n description = \"Interactive tooling for mixing cactus and RaMAx workflows\"\n authors = [{name = \"Cactus-RaMAx Team\"}]\n readme = \"README.md\""
      }
    ]
  }
}