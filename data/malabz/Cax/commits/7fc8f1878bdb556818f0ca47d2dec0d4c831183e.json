{
  "cached_at": "2025-12-20T14:33:33.733948",
  "commit_sha": "7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
  "repo": "malabz/Cax",
  "data": {
    "sha": "7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
    "node_id": "C_kwDOPt61otoAKDdmYzhmMTg3OGJkYjU1NjgxOGYwY2E0N2QyZGVjMGQ0YzgzMTE4M2U",
    "commit": {
      "author": {
        "name": "LoadStar822",
        "email": "992247533@qq.com",
        "date": "2025-10-25T06:09:21Z"
      },
      "committer": {
        "name": "LoadStar822",
        "email": "992247533@qq.com",
        "date": "2025-10-25T06:09:21Z"
      },
      "message": "feat: add tree-based subtree switching and filtered execution for 0.1 release",
      "tree": {
        "sha": "b0161e20e6818b7068bd1af157e5c7ca98d98fb0",
        "url": "https://api.github.com/repos/malabz/Cax/git/trees/b0161e20e6818b7068bd1af157e5c7ca98d98fb0"
      },
      "url": "https://api.github.com/repos/malabz/Cax/git/commits/7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null,
        "verified_at": null
      }
    },
    "url": "https://api.github.com/repos/malabz/Cax/commits/7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
    "html_url": "https://github.com/malabz/Cax/commit/7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
    "comments_url": "https://api.github.com/repos/malabz/Cax/commits/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/comments",
    "author": {
      "login": "LoadStar822",
      "id": 56856603,
      "node_id": "MDQ6VXNlcjU2ODU2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/56856603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LoadStar822",
      "html_url": "https://github.com/LoadStar822",
      "followers_url": "https://api.github.com/users/LoadStar822/followers",
      "following_url": "https://api.github.com/users/LoadStar822/following{/other_user}",
      "gists_url": "https://api.github.com/users/LoadStar822/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LoadStar822/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LoadStar822/subscriptions",
      "organizations_url": "https://api.github.com/users/LoadStar822/orgs",
      "repos_url": "https://api.github.com/users/LoadStar822/repos",
      "events_url": "https://api.github.com/users/LoadStar822/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LoadStar822/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "committer": {
      "login": "LoadStar822",
      "id": 56856603,
      "node_id": "MDQ6VXNlcjU2ODU2NjAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/56856603?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/LoadStar822",
      "html_url": "https://github.com/LoadStar822",
      "followers_url": "https://api.github.com/users/LoadStar822/followers",
      "following_url": "https://api.github.com/users/LoadStar822/following{/other_user}",
      "gists_url": "https://api.github.com/users/LoadStar822/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/LoadStar822/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/LoadStar822/subscriptions",
      "organizations_url": "https://api.github.com/users/LoadStar822/orgs",
      "repos_url": "https://api.github.com/users/LoadStar822/repos",
      "events_url": "https://api.github.com/users/LoadStar822/events{/privacy}",
      "received_events_url": "https://api.github.com/users/LoadStar822/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2dc5f901cd82da1e2a405b924d150c9b49895722",
        "url": "https://api.github.com/repos/malabz/Cax/commits/2dc5f901cd82da1e2a405b924d150c9b49895722",
        "html_url": "https://github.com/malabz/Cax/commit/2dc5f901cd82da1e2a405b924d150c9b49895722"
      }
    ],
    "stats": {
      "total": 1038,
      "additions": 927,
      "deletions": 111
    },
    "files": [
      {
        "sha": "6e7fec853546e6221037a392952e9b2be1698c71",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/malabz/Cax/blob/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/.gitignore",
        "raw_url": "https://github.com/malabz/Cax/raw/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/.gitignore",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/.gitignore?ref=7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
        "patch": "@@ -1,2 +1,4 @@\n cax/__pycache__/\n steps-output/\n+jobstore/\n+tests/__pycache__/\n\\ No newline at end of file"
      },
      {
        "sha": "20054e1b8817eebb5a5aad3e76f783098618e5af",
        "filename": "README.md",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/malabz/Cax/blob/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/README.md",
        "raw_url": "https://github.com/malabz/Cax/raw/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/README.md",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/README.md?ref=7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
        "patch": "@@ -44,13 +44,16 @@ cax\n \n ### 2. 在 UI 中操作\n \n-- 列表展示所有对齐轮次，按空格切换是否使用 RaMAx；\n-- 面板展示当前轮次的原始命令或生成的 RaMAx 命令；\n+- 左侧以树形结构展示 cactus 的渐进式比对树，空格键可将选中节点的整棵子树切换为 RaMAx 或恢复 cactus（`Ctrl+Space` 可折叠/展开节点）；\n+- 面板实时展示当前节点的命令详情与子树统计信息；\n+- `E`：在当前节点中选择并手动编辑具体指令（支持 cactus 及 RaMAx 命令）；\n - `R`：立即执行完整计划；\n - `S`：导出所有需要运行的命令到 `ramax_commands.txt`；\n - `P`：刷新总览；\n - `Q`：退出。\n \n+当某轮次切换为 RaMAx 时，执行阶段若发生错误会立即终止，不会再自动回退到 cactus 的 `blast/align`。\n+\n 保存时会在 `--outDir` 或当前目录下创建 `ramax_commands.txt`，内容为逐行排列的 shell 命令，可直接用于批量执行或进一步修改。\n \n ## 日志与调试"
      },
      {
        "sha": "838cbc013205fa81937c0fc99777c7ce6e683c3b",
        "filename": "cax/models.py",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/malabz/Cax/blob/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/cax%2Fmodels.py",
        "raw_url": "https://github.com/malabz/Cax/raw/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/cax%2Fmodels.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fmodels.py?ref=7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
        "patch": "@@ -69,6 +69,7 @@ class Round(BaseModel):\n     replace_with_ramax: bool = False\n     workdir: Optional[str] = None\n     ramax_opts: list[str] = Field(default_factory=list)\n+    manual_ramax_command: Optional[str] = None\n \n     @model_validator(mode=\"after\")\n     def _validate_round(self) -> \"Round\":\n@@ -78,10 +79,6 @@ def _validate_round(self) -> \"Round\":\n             raise ValueError(\"blast_step and align_step required when not replacing with RaMAx\")\n         return self\n \n-\n-FallbackPolicy = Literal[\"cactus\", \"abort\"]\n-\n-\n class Plan(BaseModel):\n     \"\"\"Full execution plan assembled from the parsed cactus-prepare script.\"\"\"\n \n@@ -92,7 +89,6 @@ class Plan(BaseModel):\n     out_seq_file: str\n     out_dir: Optional[str] = None\n     dry_run: bool = False\n-    fallback_policy: FallbackPolicy = \"cactus\"\n     global_ramax_opts: list[str] = Field(default_factory=list)\n \n     @field_validator(\"out_seq_file\")"
      },
      {
        "sha": "9c1c6375ab5470e0e046a9e79c715dbe334ef44a",
        "filename": "cax/parser.py",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/malabz/Cax/blob/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/cax%2Fparser.py",
        "raw_url": "https://github.com/malabz/Cax/raw/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/cax%2Fparser.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fparser.py?ref=7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
        "patch": "@@ -234,7 +234,7 @@ def _parse_line_to_step(\n     if expected_kind and kind != expected_kind:\n         kind = expected_kind\n     jobstore = _extract_jobstore(tokens)\n-    root = _extract_root(tokens)\n+    root = _extract_root(tokens, kind)\n     log_file = _extract_log_file(tokens)\n     out_files = _extract_outputs(tokens, kind)\n     return Step(\n@@ -280,7 +280,9 @@ def _extract_jobstore(tokens: list[str]) -> Optional[str]:\n     return None\n \n \n-def _extract_root(tokens: list[str]) -> Optional[str]:\n+def _extract_root(tokens: list[str], kind: str) -> Optional[str]:\n+    if kind == \"halmerge\" and len(tokens) >= 4:\n+        return tokens[3]\n     for idx, tok in enumerate(tokens):\n         if tok == \"--root\" and idx + 1 < len(tokens):\n             return tokens[idx + 1]\n@@ -339,4 +341,3 @@ def _extract_prepare_args(command: str) -> dict[str, str]:\n     if \"out_seq_file\" not in results:\n         raise ParseError(\"Unable to extract --outSeqFile from cactus-prepare command\")\n     return results\n-"
      },
      {
        "sha": "04d45526d4dbf54fd4056f60b9c9395a1953e9d6",
        "filename": "cax/planner.py",
        "status": "modified",
        "additions": 47,
        "deletions": 26,
        "changes": 73,
        "blob_url": "https://github.com/malabz/Cax/blob/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/cax%2Fplanner.py",
        "raw_url": "https://github.com/malabz/Cax/raw/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/cax%2Fplanner.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fplanner.py?ref=7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
        "patch": "@@ -1,12 +1,13 @@\n \"\"\"Translate plans into executable command sequences.\"\"\"\n from __future__ import annotations\n \n-from dataclasses import dataclass, field\n+from dataclasses import dataclass\n from pathlib import Path\n import shlex\n-from typing import Iterable, List, Optional\n+from typing import List, Optional\n \n from .models import Plan, Round, Step\n+from . import tree_utils\n \n \n @dataclass\n@@ -20,7 +21,6 @@ class PlannedCommand:\n     round_name: Optional[str] = None\n     step: Optional[Step] = None\n     is_ramax: bool = False\n-    fallback_steps: list[Step] = field(default_factory=list)\n     workdir: Optional[Path] = None\n \n     def shell_preview(self) -> str:\n@@ -35,13 +35,20 @@ def build_execution_plan(plan: Plan, base_dir: Optional[Path] = None) -> list[Pl\n     base_dir = base_dir or Path.cwd()\n     commands: list[PlannedCommand] = []\n \n+    tree = tree_utils.build_alignment_tree(plan, base_dir=base_dir)\n+    skip_roots = _compute_skipped_roots(plan, tree)\n+\n     for step in plan.preprocess:\n         commands.append(_from_step(step, category=\"preprocess\", base_dir=base_dir))\n \n     for round_entry in plan.rounds:\n+        if round_entry.root in skip_roots:\n+            continue\n         commands.extend(_round_commands(plan, round_entry, base_dir))\n \n     for step in plan.hal_merges:\n+        if step.root and step.root in skip_roots:\n+            continue\n         commands.append(_from_step(step, category=\"halmerge\", base_dir=base_dir))\n \n     return commands\n@@ -53,7 +60,7 @@ def _round_commands(plan: Plan, round_entry: Round, base_dir: Path) -> list[Plan\n \n     if round_entry.replace_with_ramax:\n         cmds.append(\n-            _ramax_command(plan, round_entry, base_dir, fallback_policy=plan.fallback_policy)\n+            _ramax_command(plan, round_entry, base_dir)\n         )\n     else:\n         if round_entry.blast_step:\n@@ -109,32 +116,29 @@ def _from_step(\n     )\n \n \n-def _ramax_command(plan: Plan, round_entry: Round, base_dir: Path, fallback_policy: str) -> PlannedCommand:\n+def _ramax_command(plan: Plan, round_entry: Round, base_dir: Path) -> PlannedCommand:\n     workdir = round_entry.workdir\n     if not workdir and plan.out_dir:\n         workdir = str(Path(plan.out_dir) / \"temps\" / f\"blast-{round_entry.root}\")\n-    command: list[str] = [\n-        \"RaMAx\",\n-        \"-i\",\n-        plan.out_seq_file,\n-        \"-o\",\n-        round_entry.target_hal,\n-        \"--root\",\n-        round_entry.root,\n-    ]\n-    if workdir:\n-        command.extend([\"-w\", workdir])\n-    command.extend(plan.global_ramax_opts)\n-    command.extend(round_entry.ramax_opts)\n \n-    log_path = _guess_ramax_log_path(plan, round_entry, base_dir)\n+    if round_entry.manual_ramax_command:\n+        command = _split_command(round_entry.manual_ramax_command)\n+    else:\n+        command = [\n+            \"RaMAx\",\n+            \"-i\",\n+            plan.out_seq_file,\n+            \"-o\",\n+            round_entry.target_hal,\n+            \"--root\",\n+            round_entry.root,\n+        ]\n+        if workdir:\n+            command.extend([\"-w\", workdir])\n+        command.extend(plan.global_ramax_opts)\n+        command.extend(round_entry.ramax_opts)\n \n-    fallback_steps: list[Step] = []\n-    if fallback_policy == \"cactus\":\n-        if round_entry.blast_step:\n-            fallback_steps.append(round_entry.blast_step)\n-        if round_entry.align_step:\n-            fallback_steps.append(round_entry.align_step)\n+    log_path = _guess_ramax_log_path(plan, round_entry, base_dir)\n \n     workdir_path = Path(workdir).expanduser() if workdir else None\n     if workdir_path and not workdir_path.is_absolute():\n@@ -147,7 +151,6 @@ def _ramax_command(plan: Plan, round_entry: Round, base_dir: Path, fallback_poli\n         round_name=round_entry.name,\n         step=None,\n         is_ramax=True,\n-        fallback_steps=fallback_steps,\n         workdir=workdir_path,\n     )\n \n@@ -216,3 +219,21 @@ def _normalize_hal2fasta(command: List[str]) -> List[str]:\n     if out_path:\n         cleaned.extend([\"--outFaPath\", out_path])\n     return cleaned\n+\n+\n+def _compute_skipped_roots(plan: Plan, tree: Optional[tree_utils.AlignmentTree]) -> set[str]:\n+    if tree is None:\n+        return set()\n+\n+    skipped: set[str] = set()\n+    for round_entry in plan.rounds:\n+        node = tree.find(round_entry.root)\n+        if not node:\n+            continue\n+        ancestor = node.parent\n+        while ancestor:\n+            if ancestor.round and ancestor.round.replace_with_ramax:\n+                skipped.add(round_entry.root)\n+                break\n+            ancestor = ancestor.parent\n+    return skipped"
      },
      {
        "sha": "20df482cdacc1fdba84e4c46b807b7f7a4611f35",
        "filename": "cax/runner.py",
        "status": "modified",
        "additions": 3,
        "deletions": 42,
        "changes": 45,
        "blob_url": "https://github.com/malabz/Cax/blob/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/cax%2Frunner.py",
        "raw_url": "https://github.com/malabz/Cax/raw/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/cax%2Frunner.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Frunner.py?ref=7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
        "patch": "@@ -3,17 +3,16 @@\n \n import os\n from pathlib import Path\n-import shlex\n import subprocess\n import time\n-from typing import Iterable, Optional\n+from typing import Optional\n \n from . import planner\n-from .models import Plan, Step\n+from .models import Plan\n \n \n class PlanRunner:\n-    \"\"\"Run a :class:`~cax.models.Plan` sequentially with logging and fallback handling.\"\"\"\n+    \"\"\"Run a :class:`~cax.models.Plan` sequentially with logging.\"\"\"\n \n     def __init__(self, plan: Plan, base_dir: Optional[Path] = None, env: Optional[dict[str, str]] = None, mirror_stdout: bool = True):\n         self.plan = plan\n@@ -34,12 +33,6 @@ def run(self, dry_run: Optional[bool] = None) -> None:\n         with self.master_log_path.open(\"a\", encoding=\"utf-8\") as master_log:\n             for command in planned_commands:\n                 success = self._run_single(command, master_log, effective_dry)\n-                if success:\n-                    continue\n-                if command.is_ramax and command.fallback_steps and self.plan.fallback_policy == \"cactus\":\n-                    master_log.write(f\"[fallback] {command.display_name} failed – executing cactus steps\\n\")\n-                    master_log.flush()\n-                    success = self._run_fallback(command, master_log, effective_dry)\n                 if not success:\n                     raise RuntimeError(f\"Command failed: {command.display_name}\")\n \n@@ -104,46 +97,14 @@ def _run_single(self, command: planner.PlannedCommand, master_log, dry_run: bool\n                 print(f\"[end] {command.display_name} -> {return_code} ({duration:.1f}s)\", flush=True)\n             return return_code == 0\n \n-    def _run_fallback(self, command: planner.PlannedCommand, master_log, dry_run: bool) -> bool:\n-        for step in command.fallback_steps:\n-            fallback_command = planner.PlannedCommand(\n-                command=_split(step.raw),\n-                category=step.kind,\n-                display_name=step.short_label(),\n-                log_path=_step_log_path(step, self.base_dir, self.log_root),\n-                round_name=command.round_name,\n-                step=step,\n-                is_ramax=False,\n-            )\n-            success = self._run_single(fallback_command, master_log, dry_run)\n-            if not success:\n-                return False\n-        return True\n-\n     def _derive_log_root(self) -> Path:\n         if self.plan.out_dir:\n             return _to_path(self.plan.out_dir, self.base_dir) / \"logs\"\n         return (self.base_dir / \"logs\").resolve()\n \n \n-def _split(command: str) -> list[str]:\n-    try:\n-        return shlex.split(command)\n-    except ValueError:\n-        return command.split()\n-\n-\n def _to_path(path_like: str, base_dir: Path) -> Path:\n     path = Path(path_like).expanduser()\n     if path.is_absolute():\n         return path\n     return (base_dir / path).resolve()\n-\n-\n-def _step_log_path(step: Step, base_dir: Path, log_root: Path) -> Path:\n-    if step.log_file:\n-        path = Path(step.log_file).expanduser()\n-        if not path.is_absolute():\n-            path = (base_dir / path).resolve()\n-        return path\n-    return (log_root / f\"{step.short_label()}\").with_suffix('.log').resolve()"
      },
      {
        "sha": "155f450a335b535a63841b87e5f3471461a39522",
        "filename": "cax/tree_utils.py",
        "status": "added",
        "additions": 200,
        "deletions": 0,
        "changes": 200,
        "blob_url": "https://github.com/malabz/Cax/blob/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/cax%2Ftree_utils.py",
        "raw_url": "https://github.com/malabz/Cax/raw/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/cax%2Ftree_utils.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Ftree_utils.py?ref=7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
        "patch": "@@ -0,0 +1,200 @@\n+\"\"\"Utilities for parsing cactus alignment trees and mapping them to plan rounds.\"\"\"\n+from __future__ import annotations\n+\n+from dataclasses import dataclass, field\n+from pathlib import Path\n+from typing import Iterator, Optional\n+\n+from .models import Plan, Round\n+\n+\n+class NewickParseError(RuntimeError):\n+    \"\"\"Raised when a Newick tree cannot be parsed correctly.\"\"\"\n+\n+\n+@dataclass\n+class AlignmentNode:\n+    \"\"\"Node within the cactus alignment tree.\"\"\"\n+\n+    name: str\n+    children: list[\"AlignmentNode\"] = field(default_factory=list)\n+    round: Optional[Round] = None\n+    parent: Optional[\"AlignmentNode\"] = field(default=None, repr=False)\n+\n+    def walk(self) -> Iterator[\"AlignmentNode\"]:\n+        \"\"\"Yield this node and all descendants.\"\"\"\n+\n+        yield self\n+        for child in self.children:\n+            yield from child.walk()\n+\n+    def iter_rounds(self) -> Iterator[Round]:\n+        \"\"\"Iterate over all rounds contained within this subtree.\"\"\"\n+\n+        if self.round is not None:\n+            yield self.round\n+        for child in self.children:\n+            yield from child.iter_rounds()\n+\n+    def has_round(self) -> bool:\n+        \"\"\"Return ``True`` if this subtree contains at least one round.\"\"\"\n+\n+        if self.round is not None:\n+            return True\n+        return any(child.has_round() for child in self.children)\n+\n+\n+@dataclass\n+class AlignmentTree:\n+    \"\"\"Full cactus alignment tree rooted at ``root``.\"\"\"\n+\n+    root: AlignmentNode\n+    nodes_by_name: dict[str, AlignmentNode] = field(init=False, repr=False)\n+\n+    def __post_init__(self) -> None:\n+        self.nodes_by_name = {\n+            node.name: node for node in self.root.walk() if node.name\n+        }\n+\n+    def find(self, name: str) -> Optional[AlignmentNode]:\n+        \"\"\"Return the node with the given ``name`` if present.\"\"\"\n+\n+        return self.nodes_by_name.get(name)\n+\n+    def iter_rounds(self) -> Iterator[Round]:\n+        \"\"\"Iterate over rounds contained in the tree.\"\"\"\n+\n+        return self.root.iter_rounds()\n+\n+\n+def build_alignment_tree(plan: Plan, base_dir: Optional[Path] = None) -> Optional[AlignmentTree]:\n+    \"\"\"Construct an alignment tree from a parsed ``Plan``.\n+\n+    Returns ``None`` when the underlying ``--outSeqFile`` is missing or lacks\n+    a valid Newick tree definition.\n+    \"\"\"\n+\n+    newick = _read_newick(plan.out_seq_file, base_dir=base_dir)\n+    if not newick:\n+        return None\n+    parser = _NewickParser(newick)\n+    try:\n+        root = parser.parse()\n+    except NewickParseError:\n+        return None\n+    round_map = {round_entry.root: round_entry for round_entry in plan.rounds}\n+    _attach_rounds(root, round_map)\n+    return AlignmentTree(root)\n+\n+\n+def _read_newick(out_seq_file: str, base_dir: Optional[Path]) -> str | None:\n+    path = Path(out_seq_file).expanduser()\n+    if not path.is_absolute() and base_dir is not None:\n+        path = (Path(base_dir) / path).expanduser().resolve()\n+    if not path.exists():\n+        return None\n+    try:\n+        with path.open(\"r\", encoding=\"utf-8\") as handle:\n+            for line in handle:\n+                stripped = line.strip()\n+                if stripped:\n+                    return stripped\n+    except OSError:\n+        return None\n+    return None\n+\n+\n+def _attach_rounds(node: AlignmentNode, round_map: dict[str, Round]) -> None:\n+    if node.name in round_map:\n+        node.round = round_map[node.name]\n+    for child in node.children:\n+        child.parent = node\n+        _attach_rounds(child, round_map)\n+\n+\n+class _NewickParser:\n+    \"\"\"Minimal recursive-descent parser for Newick tree strings.\"\"\"\n+\n+    def __init__(self, text: str):\n+        self.text = text.strip()\n+        self.length = len(self.text)\n+        self.index = 0\n+\n+    def parse(self) -> AlignmentNode:\n+        node = self._parse_subtree()\n+        self._skip_ws()\n+        if self._peek() == \";\":\n+            self.index += 1\n+        self._skip_ws()\n+        if self.index != self.length:\n+            raise NewickParseError(f\"Unexpected trailing data at position {self.index}\")\n+        return node\n+\n+    def _parse_subtree(self) -> AlignmentNode:\n+        self._skip_ws()\n+        if self._peek() == \"(\":\n+            self.index += 1\n+            children: list[AlignmentNode] = []\n+            while True:\n+                children.append(self._parse_subtree())\n+                self._skip_ws()\n+                token = self._peek()\n+                if token == \",\":\n+                    self.index += 1\n+                    continue\n+                if token == \")\":\n+                    self.index += 1\n+                    break\n+                raise NewickParseError(f\"Expected ',' or ')' at position {self.index}\")\n+            name = self._parse_label()\n+            self._parse_branch_length()\n+            node = AlignmentNode(name=name or \"\", children=children)\n+            for child in children:\n+                child.parent = node\n+            return node\n+\n+        label = self._parse_label()\n+        if not label:\n+            raise NewickParseError(f\"Missing leaf label at position {self.index}\")\n+        self._parse_branch_length()\n+        return AlignmentNode(name=label)\n+\n+    def _parse_label(self) -> str:\n+        self._skip_ws()\n+        start = self.index\n+        while self.index < self.length:\n+            char = self.text[self.index]\n+            if char in \":,();\":\n+                break\n+            if char.isspace():\n+                break\n+            self.index += 1\n+        label = self.text[start:self.index].strip()\n+        self._skip_ws()\n+        return label\n+\n+    def _parse_branch_length(self) -> None:\n+        self._skip_ws()\n+        if self._peek() != \":\":\n+            return\n+        self.index += 1\n+        start = self.index\n+        while self.index < self.length:\n+            char = self.text[self.index]\n+            if char in \",();\":\n+                break\n+            if char.isspace():\n+                break\n+            self.index += 1\n+        if start == self.index:\n+            raise NewickParseError(f\"Missing branch length at position {self.index}\")\n+        self._skip_ws()\n+\n+    def _skip_ws(self) -> None:\n+        while self.index < self.length and self.text[self.index].isspace():\n+            self.index += 1\n+\n+    def _peek(self) -> str | None:\n+        if self.index >= self.length:\n+            return None\n+        return self.text[self.index]"
      },
      {
        "sha": "443086cc7a5389e533d322f7daaa63fe8bde2dac",
        "filename": "cax/ui.py",
        "status": "modified",
        "additions": 496,
        "deletions": 33,
        "changes": 529,
        "blob_url": "https://github.com/malabz/Cax/blob/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/cax%2Fui.py",
        "raw_url": "https://github.com/malabz/Cax/raw/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/cax%2Fui.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/cax%2Fui.py?ref=7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
        "patch": "@@ -8,10 +8,13 @@\n from textual.app import App, ComposeResult\n from textual.binding import Binding\n from textual.containers import Container\n-from textual.widgets import Footer, Header, ListItem, ListView, Static\n+from textual.screen import ModalScreen\n+from textual.widgets import Button, Footer, Header, Input, ListItem, ListView, Static, Tree\n \n-from . import planner, render\n-from .models import Plan, Round\n+from rich.text import Text\n+\n+from . import planner, render, tree_utils\n+from .models import Plan, Round, Step\n \n \n @dataclass\n@@ -21,6 +24,166 @@ class UIResult:\n     payload: Optional[Path] = None\n \n \n+@dataclass\n+class CommandTarget:\n+    \"\"\"Represents an editable command associated with a round.\"\"\"\n+\n+    key: str\n+    label: str\n+    command: str\n+    kind: str\n+    step: Step | None = None\n+    index: int | None = None\n+\n+\n+class CommandSelectionModal(ModalScreen[CommandTarget | None]):\n+    \"\"\"Modal dialog listing all editable commands for a round.\"\"\"\n+\n+    BINDINGS = [Binding(\"escape\", \"cancel\", \"取消\")]\n+\n+    CSS = \"\"\"\n+    CommandSelectionModal {\n+        align: center middle;\n+    }\n+    #picker-dialog {\n+        padding: 1 2;\n+        width: 80%;\n+        max-width: 80;\n+        border: round $accent;\n+        background: $panel;\n+    }\n+    #picker-title {\n+        padding-bottom: 1;\n+    }\n+    #picker-list {\n+        height: auto;\n+        max-height: 20;\n+    }\n+    #picker-hint {\n+        padding-top: 1;\n+        color: $text-muted;\n+    }\n+    \"\"\"\n+\n+    def __init__(self, targets: list[CommandTarget]):\n+        super().__init__()\n+        self.targets = targets\n+        self._list_view: ListView | None = None\n+\n+    def compose(self) -> ComposeResult:\n+        with Container(id=\"picker-dialog\"):\n+            yield Static(\"选择要编辑的指令\", id=\"picker-title\")\n+            items = []\n+            for target in self.targets:\n+                text = Text(target.label, style=\"bold\")\n+                text.append(\"\\n\")\n+                text.append(target.command)\n+                items.append(ListItem(Static(text, expand=True)))\n+            list_view = ListView(*items, id=\"picker-list\")\n+            self._list_view = list_view\n+            yield list_view\n+            yield Static(\"Enter 确认，Esc 取消\", id=\"picker-hint\")\n+\n+    def on_mount(self) -> None:\n+        if self._list_view:\n+            self._list_view.index = 0\n+            self.set_focus(self._list_view)\n+\n+    def on_list_view_selected(self, event: ListView.Selected) -> None:\n+        if event.index < len(self.targets):\n+            self.dismiss(self.targets[event.index])\n+\n+    def action_cancel(self) -> None:\n+        self.dismiss(None)\n+\n+\n+class CommandEditModal(ModalScreen[str | None]):\n+    \"\"\"Modal dialog allowing the user to edit a command string.\"\"\"\n+\n+    BINDINGS = [\n+        Binding(\"escape\", \"cancel\", \"取消\"),\n+        Binding(\"ctrl+s\", \"save\", \"保存\"),\n+        Binding(\"enter\", \"save\", \"保存\"),\n+    ]\n+\n+    CSS = \"\"\"\n+    CommandEditModal {\n+        align: center middle;\n+    }\n+    #editor-dialog {\n+        padding: 1 2;\n+        width: 80%;\n+        max-width: 90;\n+        border: round $accent;\n+        background: $panel;\n+    }\n+    #editor-title {\n+        padding-bottom: 1;\n+    }\n+    #editor-command {\n+        margin-bottom: 1;\n+    }\n+    #editor-buttons {\n+        layout: horizontal;\n+        height: auto;\n+        padding-top: 1;\n+    }\n+    #editor-buttons Button {\n+        margin-right: 1;\n+    }\n+    #editor-status {\n+        color: $error;\n+    }\n+    \"\"\"\n+\n+    def __init__(self, title: str, initial_command: str):\n+        super().__init__()\n+        self.title = title\n+        self.initial_command = initial_command\n+        self._input: Input | None = None\n+        self._status: Static | None = None\n+\n+    def compose(self) -> ComposeResult:\n+        with Container(id=\"editor-dialog\"):\n+            yield Static(self.title, id=\"editor-title\")\n+            input_widget = Input(value=self.initial_command, id=\"editor-command\")\n+            self._input = input_widget\n+            yield input_widget\n+            status = Static(\"\", id=\"editor-status\")\n+            self._status = status\n+            yield status\n+            with Container(id=\"editor-buttons\"):\n+                yield Button(\"保存\", id=\"save\", variant=\"success\")\n+                yield Button(\"取消\", id=\"cancel\")\n+\n+    def on_mount(self) -> None:\n+        if self._input:\n+            self._input.focus()\n+            self._input.cursor_position = len(self._input.value)\n+\n+    def on_input_submitted(self, event: Input.Submitted) -> None:\n+        self.action_save()\n+\n+    def action_save(self) -> None:\n+        if not self._input:\n+            self.dismiss(None)\n+            return\n+        value = self._input.value.strip()\n+        if not value:\n+            if self._status:\n+                self._status.update(\"指令不能为空\")\n+            return\n+        self.dismiss(value)\n+\n+    def action_cancel(self) -> None:\n+        self.dismiss(None)\n+\n+    def on_button_pressed(self, event: Button.Pressed) -> None:\n+        if event.button.id == \"save\":\n+            self.action_save()\n+        else:\n+            self.action_cancel()\n+\n class RoundListItem(ListItem):\n     \"\"\"List item reflecting a round with RaMAx toggle.\"\"\"\n \n@@ -38,6 +201,24 @@ def update_content(self) -> None:\n         static.update(self._text())\n \n \n+class AlignmentTreeWidget(Tree[tree_utils.AlignmentNode]):\n+    \"\"\"Tree widget with modified key bindings to cooperate with the global space toggle.\"\"\"\n+\n+    BINDINGS = [\n+        binding\n+        for binding in Tree.BINDINGS\n+        if binding.key != \"space\"\n+    ] + [\n+        Binding(\"space\", \"toggle_subtree\", \"切换子树\", show=False),\n+        Binding(\"ctrl+space\", \"toggle_node\", \"展开/折叠\", show=False),\n+    ]\n+\n+    def action_toggle_subtree(self) -> None:\n+        toggle_action = getattr(self.app, \"action_toggle_round\", None)\n+        if callable(toggle_action):\n+            toggle_action()\n+\n+\n class PlanUIApp(App[UIResult]):\n     CSS = \"\"\"\n     Screen {\n@@ -58,40 +239,83 @@ class PlanUIApp(App[UIResult]):\n     \"\"\"\n \n     BINDINGS = [\n-        Binding(\"space\", \"toggle_round\", \"Toggle RaMAx\"),\n-        Binding(\"e\", \"edit_round\", \"Edit workdir (todo)\"),\n-        Binding(\"p\", \"preview_plan\", \"Preview\"),\n-        Binding(\"s\", \"save_commands\", \"Save commands\"),\n-        Binding(\"r\", \"run_plan\", \"Run\"),\n-        Binding(\"q\", \"quit\", \"Quit\"),\n+        Binding(\"space\", \"toggle_round\", \"切换子树\"),\n+        Binding(\"e\", \"edit_round\", \"编辑指令\"),\n+        Binding(\"p\", \"preview_plan\", \"预览\"),\n+        Binding(\"s\", \"save_commands\", \"保存命令\"),\n+        Binding(\"r\", \"run_plan\", \"执行\"),\n+        Binding(\"q\", \"quit\", \"退出\"),\n     ]\n \n     def __init__(self, plan: Plan, base_dir: Optional[Path] = None):\n         super().__init__()\n         self.plan = plan\n         self.base_dir = Path(base_dir) if base_dir else Path.cwd()\n+        self.alignment_tree = tree_utils.build_alignment_tree(plan, base_dir=self.base_dir)\n+        self.tree_widget: AlignmentTreeWidget | None = None\n         self.round_items: list[RoundListItem] = []\n         self.round_list: ListView | None = None\n         self.detail_panel: Static | None = None\n \n     def compose(self) -> ComposeResult:\n         yield Header()\n         with Container(id=\"main\"):\n-            self.round_items = [RoundListItem(round_entry, idx) for idx, round_entry in enumerate(self.plan.rounds)]\n-            list_view = ListView(*self.round_items, id=\"rounds\")\n-            self.round_list = list_view\n-            yield list_view\n+            if self.alignment_tree:\n+                root_node = self.alignment_tree.root\n+                tree_widget = AlignmentTreeWidget(\n+                    self._format_node_label(root_node),\n+                    data=root_node,\n+                    id=\"rounds\",\n+                )\n+                self.tree_widget = tree_widget\n+                self._populate_tree(tree_widget.root, root_node)\n+                self._refresh_tree_labels(tree_widget.root)\n+                yield tree_widget\n+            else:\n+                self.round_items = [\n+                    RoundListItem(round_entry, idx)\n+                    for idx, round_entry in enumerate(self.plan.rounds)\n+                ]\n+                list_view = ListView(*self.round_items, id=\"rounds\")\n+                self.round_list = list_view\n+                yield list_view\n             detail = Static(render.plan_overview(self.plan), id=\"details\")\n             self.detail_panel = detail\n             yield detail\n         yield Footer()\n \n     def on_mount(self) -> None:\n-        if self.round_list and self.round_items:\n+        if self.tree_widget and self.alignment_tree:\n+            self.tree_widget.root.expand_all()\n+            self.tree_widget.move_cursor(self.tree_widget.root, animate=False)\n+            self.set_focus(self.tree_widget)\n+            self._show_alignment_node(self.alignment_tree.root)\n+        elif self.round_list and self.round_items:\n             self.round_list.index = 0\n             self._show_round(0)\n \n     def action_toggle_round(self) -> None:\n+        if self.alignment_tree and self.tree_widget:\n+            node = self._selected_alignment_node()\n+            if node is None:\n+                return\n+            rounds = list(node.iter_rounds())\n+            if not rounds:\n+                if self.detail_panel:\n+                    self.detail_panel.update(\"该节点不包含可替换的 cactus 步骤。\")\n+                return\n+            target_state = not all(round_entry.replace_with_ramax for round_entry in rounds)\n+            for round_entry in rounds:\n+                round_entry.replace_with_ramax = target_state\n+            self._refresh_tree_labels(self.tree_widget.root)\n+            status = (\n+                f\"子树内 {len(rounds)} 个轮次已切换至 RaMAx\"\n+                if target_state\n+                else f\"子树内 {len(rounds)} 个轮次已恢复为 cactus\"\n+            )\n+            self._show_alignment_node(node, status=status)\n+            return\n+\n         if not self.round_list:\n             return\n         index = self.round_list.index or 0\n@@ -100,7 +324,8 @@ def action_toggle_round(self) -> None:\n         round_entry = self.plan.rounds[index]\n         round_entry.replace_with_ramax = not round_entry.replace_with_ramax\n         self.round_items[index].update_content()\n-        self._show_round(index)\n+        status = \"已切换至 RaMAx\" if round_entry.replace_with_ramax else \"已恢复为 cactus\"\n+        self._show_round(index, status=status)\n \n     def action_preview_plan(self) -> None:\n         if self.detail_panel:\n@@ -118,41 +343,279 @@ def action_save_commands(self) -> None:\n         lines = [cmd.shell_preview() for cmd in commands]\n         output_path.write_text(\"\\n\".join(lines) + \"\\n\", encoding=\"utf-8\")\n         if self.detail_panel:\n-            self.detail_panel.update(f\"Saved commands to {output_path}\")\n+            self.detail_panel.update(f\"命令已保存到 {output_path}\")\n \n     def action_quit(self) -> None:\n         self.exit(UIResult(plan=self.plan, action=\"quit\"))\n \n-    def action_edit_round(self) -> None:  # placeholder for future editing\n-        if self.detail_panel:\n-            self.detail_panel.update(\"Editing workdir not yet implemented in this preview UI.\")\n+    def action_edit_round(self) -> None:\n+        if self.alignment_tree and self.tree_widget:\n+            node = self._selected_alignment_node()\n+            if node is None or node.round is None:\n+                if self.detail_panel:\n+                    self.detail_panel.update(\"请选择包含 cactus 轮次的节点后再按 E。\")\n+                return\n+            try:\n+                round_index = self.plan.rounds.index(node.round)\n+            except ValueError:\n+                return\n+            targets = self._gather_command_targets(node.round)\n+            if not targets:\n+                if self.detail_panel:\n+                    self.detail_panel.update(\"当前节点没有可编辑的指令。\")\n+                return\n+            if len(targets) == 1:\n+                self._open_command_editor(round_index, targets[0])\n+            else:\n+                self.push_screen(\n+                    CommandSelectionModal(targets),\n+                    lambda target: self._handle_command_selection(round_index, target),\n+                )\n+            return\n+\n+        if not self.round_list:\n+            return\n+        index = self.round_list.index or 0\n+        if index >= len(self.plan.rounds):\n+            return\n+        round_entry = self.plan.rounds[index]\n+        targets = self._gather_command_targets(round_entry)\n+        if not targets:\n+            if self.detail_panel:\n+                self.detail_panel.update(\"当前轮次没有可编辑的指令。\")\n+            return\n+        if len(targets) == 1:\n+            self._open_command_editor(index, targets[0])\n+        else:\n+            self.push_screen(\n+                CommandSelectionModal(targets),\n+                lambda target: self._handle_command_selection(index, target),\n+            )\n \n     def on_list_view_selected(self, event: ListView.Selected) -> None:\n         self._show_round(event.index)\n \n-    def _show_round(self, index: int) -> None:\n-        if not self.detail_panel or index >= len(self.plan.rounds):\n-            return\n-        round_entry = self.plan.rounds[index]\n+    def on_alignmenttreewidget_node_highlighted(\n+        self, event: AlignmentTreeWidget.NodeHighlighted\n+    ) -> None:\n+        node = event.node.data\n+        if node is not None:\n+            self._show_alignment_node(node)\n+\n+    def on_alignmenttreewidget_node_selected(\n+        self, event: AlignmentTreeWidget.NodeSelected\n+    ) -> None:\n+        node = event.node.data\n+        if node is not None:\n+            self._show_alignment_node(node)\n+\n+    def _round_details(self, round_entry: Round) -> list[str]:\n         details = [f\"[bold]{round_entry.name}[/bold] root={round_entry.root}\"]\n         if round_entry.replace_with_ramax:\n-            commands = planner.build_execution_plan(self.plan, self.base_dir)\n-            ramax_cmd = next((cmd for cmd in commands if cmd.round_name == round_entry.name and cmd.is_ramax), None)\n-            if ramax_cmd:\n-                details.append(\"\\n[green]RaMAx command[/green]\")\n-                details.append(f\"{ramax_cmd.shell_preview()}\")\n+            ramax_preview = self._ramax_command_preview(round_entry)\n+            if ramax_preview:\n+                details.extend([\"\", \"[green]RaMAx 命令[/green]\", ramax_preview])\n         else:\n             if round_entry.blast_step:\n-                details.append(\"\\n[cyan]cactus-blast[/cyan]\")\n-                details.append(round_entry.blast_step.raw)\n+                details.extend([\"\", \"[cyan]cactus-blast[/cyan]\", round_entry.blast_step.raw])\n             if round_entry.align_step:\n-                details.append(\"\\n[cyan]cactus-align[/cyan]\")\n-                details.append(round_entry.align_step.raw)\n+                details.extend([\"\", \"[cyan]cactus-align[/cyan]\", round_entry.align_step.raw])\n         if round_entry.hal2fasta_steps:\n-            details.append(\"\\n[magenta]hal2fasta[/magenta]\")\n+            details.append(\"\")\n+            details.append(\"[magenta]hal2fasta[/magenta]\")\n             details.extend(step.raw for step in round_entry.hal2fasta_steps)\n+        return details\n+\n+    def _show_round(self, index: int, status: str | None = None) -> None:\n+        if not self.detail_panel or index >= len(self.plan.rounds):\n+            return\n+        round_entry = self.plan.rounds[index]\n+        details = self._round_details(round_entry)\n+        if status:\n+            details.extend([\"\", f\"[green]{status}[/green]\"])\n+        self.detail_panel.update(\"\\n\".join(details))\n+\n+    def _gather_command_targets(self, round_entry: Round) -> list[CommandTarget]:\n+        targets: list[CommandTarget] = []\n+        if round_entry.replace_with_ramax:\n+            ramax_preview = self._ramax_command_preview(round_entry)\n+            targets.append(\n+                CommandTarget(\n+                    key=\"ramax\",\n+                    label=\"RaMAx\",\n+                    command=ramax_preview,\n+                    kind=\"ramax\",\n+                )\n+            )\n+        else:\n+            if round_entry.blast_step:\n+                targets.append(\n+                    CommandTarget(\n+                        key=\"blast\",\n+                        label=\"cactus-blast\",\n+                        command=round_entry.blast_step.raw,\n+                        kind=\"blast\",\n+                        step=round_entry.blast_step,\n+                    )\n+                )\n+            if round_entry.align_step:\n+                targets.append(\n+                    CommandTarget(\n+                        key=\"align\",\n+                        label=\"cactus-align\",\n+                        command=round_entry.align_step.raw,\n+                        kind=\"align\",\n+                        step=round_entry.align_step,\n+                    )\n+                )\n+        for idx, step in enumerate(round_entry.hal2fasta_steps):\n+            label = \"hal2fasta\" if len(round_entry.hal2fasta_steps) == 1 else f\"hal2fasta #{idx + 1}\"\n+            targets.append(\n+                CommandTarget(\n+                    key=f\"hal2fasta-{idx}\",\n+                    label=label,\n+                    command=step.raw,\n+                    kind=\"hal2fasta\",\n+                    step=step,\n+                    index=idx,\n+                )\n+            )\n+        return targets\n+\n+    def _show_alignment_node(\n+        self,\n+        node: tree_utils.AlignmentNode,\n+        status: str | None = None,\n+    ) -> None:\n+        if not self.detail_panel:\n+            return\n+        details: list[str] = []\n+        if node.round:\n+            details.extend(self._round_details(node.round))\n+        else:\n+            title = node.name or \"(未命名节点)\"\n+            details.append(f\"[bold]{title}[/bold]\")\n+        subtree_rounds = list(node.iter_rounds())\n+        if subtree_rounds:\n+            replaced = sum(1 for round_entry in subtree_rounds if round_entry.replace_with_ramax)\n+            details.extend(\n+                [\n+                    \"\",\n+                    f\"子树统计：RaMAx {replaced}/{len(subtree_rounds)} 个\",\n+                ]\n+            )\n+        else:\n+            details.extend([\"\", \"子树内不存在 cactus 轮次（叶子节点）。\"])\n+        if status:\n+            details.extend([\"\", f\"[green]{status}[/green]\"])\n         self.detail_panel.update(\"\\n\".join(details))\n \n+    def _selected_alignment_node(self) -> tree_utils.AlignmentNode | None:\n+        if not self.tree_widget:\n+            return None\n+        cursor = self.tree_widget.cursor_node\n+        return cursor.data if cursor is not None else None\n+\n+    def _find_node_for_round(self, round_entry: Round) -> tree_utils.AlignmentNode | None:\n+        if not self.alignment_tree:\n+            return None\n+        return self.alignment_tree.find(round_entry.root)\n+\n+    def _populate_tree(\n+        self,\n+        tree_node,\n+        alignment_node: tree_utils.AlignmentNode,\n+    ) -> None:\n+        for child in alignment_node.children:\n+            label = self._format_node_label(child)\n+            child_node = tree_node.add(label, data=child)\n+            if child.children:\n+                self._populate_tree(child_node, child)\n+\n+    def _refresh_tree_labels(self, tree_node) -> None:\n+        alignment_node = tree_node.data\n+        if alignment_node is not None:\n+            tree_node.set_label(self._format_node_label(alignment_node))\n+        for child in tree_node.children:\n+            self._refresh_tree_labels(child)\n+\n+    def _format_node_label(self, node: tree_utils.AlignmentNode) -> str:\n+        state = self._node_state(node)\n+        name = node.name or \"(未命名)\"\n+        if state == \"leaf\":\n+            return f\"    {name}\"\n+        marker = {\"checked\": \"[x]\", \"unchecked\": \"[ ]\", \"mixed\": \"[-]\"}[state]\n+        return f\"{marker} {name}\"\n+\n+    def _node_state(self, node: tree_utils.AlignmentNode) -> str:\n+        has_round = node.round is not None\n+        if node.round is not None:\n+            enabled = node.round.replace_with_ramax\n+            any_enabled = enabled\n+            all_enabled = enabled\n+        else:\n+            any_enabled = False\n+            all_enabled = True\n+        for child in node.children:\n+            child_state = self._node_state(child)\n+            if child_state == \"leaf\":\n+                continue\n+            has_round = True\n+            if child_state == \"checked\":\n+                any_enabled = True\n+            elif child_state == \"mixed\":\n+                any_enabled = True\n+                all_enabled = False\n+            elif child_state == \"unchecked\":\n+                all_enabled = False\n+        if not has_round:\n+            return \"leaf\"\n+        if all_enabled and any_enabled:\n+            return \"checked\"\n+        if any_enabled:\n+            return \"mixed\"\n+        return \"unchecked\"\n+\n+    def _handle_command_selection(self, round_index: int, target: CommandTarget | None) -> None:\n+        if target is None:\n+            return\n+        self._open_command_editor(round_index, target)\n+\n+    def _open_command_editor(self, round_index: int, target: CommandTarget) -> None:\n+        editor = CommandEditModal(f\"编辑 {target.label} 指令\", target.command)\n+        self.push_screen(\n+            editor,\n+            lambda new_command: self._apply_command_edit(round_index, target, new_command),\n+        )\n+\n+    def _apply_command_edit(\n+        self, round_index: int, target: CommandTarget, new_command: str | None\n+    ) -> None:\n+        if new_command is None or round_index >= len(self.plan.rounds):\n+            return\n+        round_entry = self.plan.rounds[round_index]\n+        if target.kind == \"ramax\":\n+            round_entry.manual_ramax_command = new_command\n+        elif target.step is not None:\n+            target.step.raw = new_command\n+        status = f\"已更新 {target.label} 指令\"\n+        if self.alignment_tree and self.tree_widget:\n+            node = self._find_node_for_round(round_entry)\n+            if node:\n+                self._refresh_tree_labels(self.tree_widget.root)\n+                self._show_alignment_node(node, status=status)\n+                return\n+        self._show_round(round_index, status=status)\n+\n+    def _ramax_command_preview(self, round_entry: Round) -> str:\n+        if round_entry.manual_ramax_command:\n+            return round_entry.manual_ramax_command\n+        commands = planner.build_execution_plan(self.plan, self.base_dir)\n+        for command in commands:\n+            if command.is_ramax and command.round_name == round_entry.name:\n+                return command.shell_preview()\n+        return \"\"\n+\n \n def launch(plan: Plan, base_dir: Optional[Path] = None) -> UIResult:\n     \"\"\"Run the Textual UI and return the resulting plan/action.\"\"\""
      },
      {
        "sha": "35ba14d461e1a8c0f751a11ed1d140b4428b23ec",
        "filename": "tests/test_planner_skips.py",
        "status": "added",
        "additions": 86,
        "deletions": 0,
        "changes": 86,
        "blob_url": "https://github.com/malabz/Cax/blob/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/tests%2Ftest_planner_skips.py",
        "raw_url": "https://github.com/malabz/Cax/raw/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/tests%2Ftest_planner_skips.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/tests%2Ftest_planner_skips.py?ref=7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
        "patch": "@@ -0,0 +1,86 @@\n+\"\"\"Tests covering planner behaviour for subtree replacements.\"\"\"\n+from __future__ import annotations\n+\n+from datetime import datetime\n+\n+from cax import planner\n+from cax.models import Plan, PrepareHeader, Round, Step\n+\n+\n+def _make_step(raw: str, kind: str, root: str | None = None) -> Step:\n+    return Step(\n+        raw=raw,\n+        kind=kind,\n+        jobstore=None,\n+        out_files=[],\n+        root=root,\n+    )\n+\n+\n+def _make_round(\n+    name: str,\n+    root: str,\n+    target_hal: str,\n+    replace_with_ramax: bool,\n+) -> Round:\n+    blast = Step(\n+        raw=f\"cactus-blast jobstore/1 seq.txt {root}.paf --root {root}\",\n+        kind=\"blast\",\n+        root=root,\n+    )\n+    align = Step(\n+        raw=f\"cactus-align jobstore/2 seq.txt {root}.paf {root}.hal --root {root}\",\n+        kind=\"align\",\n+        root=root,\n+        out_files=[f\"{root}.hal\"],\n+    )\n+    return Round(\n+        name=name,\n+        root=root,\n+        target_hal=f\"{target_hal}\",\n+        blast_step=None if replace_with_ramax else blast,\n+        align_step=None if replace_with_ramax else align,\n+        replace_with_ramax=replace_with_ramax,\n+    )\n+\n+\n+def test_descendant_rounds_skipped_when_ancestor_replaced(tmp_path) -> None:\n+    out_seq_file = tmp_path / \"tree.txt\"\n+    out_seq_file.write_text(\"((A:0.1,B:0.2)N1:0.3,C:0.4)Root;\\n\", encoding=\"utf-8\")\n+\n+    header = PrepareHeader(\n+        generated_by=\"cactus-prepare example --outSeqFile tree.txt\",\n+        date=datetime(2024, 1, 1, 0, 0, 0),\n+    )\n+    round_child = _make_round(\"Round child\", \"N1\", \"N1.hal\", replace_with_ramax=False)\n+    round_root = _make_round(\"Round root\", \"Root\", \"Root.hal\", replace_with_ramax=True)\n+\n+    plan = Plan(\n+        header=header,\n+        preprocess=[],\n+        rounds=[round_child, round_root],\n+        hal_merges=[\n+            _make_step(\n+                \"halAppendSubtree Root.hal N1.hal N1 N1 --merge\",\n+                kind=\"halmerge\",\n+                root=\"N1\",\n+            ),\n+            _make_step(\n+                \"halAppendSubtree Root.hal Root.hal Root Root --merge\",\n+                kind=\"halmerge\",\n+                root=\"Root\",\n+            ),\n+        ],\n+        out_seq_file=str(out_seq_file),\n+    )\n+\n+    commands = planner.build_execution_plan(plan, base_dir=tmp_path)\n+\n+    # Expect the child round to be skipped entirely (no blast/align/ramax commands)\n+    categories = {cmd.category for cmd in commands}\n+    assert \"blast\" not in categories\n+    assert \"align\" not in categories\n+\n+    # Hal merge for the child should also be skipped, root merge retained.\n+    merge_targets = [cmd.command[3] for cmd in commands if cmd.category == \"halmerge\"]\n+    assert merge_targets == [\"Root\"]"
      },
      {
        "sha": "466e22037c4bf5d8d25d503984ac51f831b969e7",
        "filename": "tests/test_tree_utils.py",
        "status": "added",
        "additions": 83,
        "deletions": 0,
        "changes": 83,
        "blob_url": "https://github.com/malabz/Cax/blob/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/tests%2Ftest_tree_utils.py",
        "raw_url": "https://github.com/malabz/Cax/raw/7fc8f1878bdb556818f0ca47d2dec0d4c831183e/tests%2Ftest_tree_utils.py",
        "contents_url": "https://api.github.com/repos/malabz/Cax/contents/tests%2Ftest_tree_utils.py?ref=7fc8f1878bdb556818f0ca47d2dec0d4c831183e",
        "patch": "@@ -0,0 +1,83 @@\n+\"\"\"Tests for the alignment tree utilities.\"\"\"\n+from __future__ import annotations\n+\n+from datetime import datetime\n+\n+from cax import tree_utils\n+from cax.models import Plan, PrepareHeader, Round, Step\n+\n+\n+def _make_round(name: str) -> Round:\n+    blast = Step(\n+        raw=f\"cactus-blast jobstore/1 input.txt output_{name}.paf --root {name}\",\n+        kind=\"blast\",\n+        root=name,\n+        log_file=f\"logs/blast-{name}.log\",\n+    )\n+    align = Step(\n+        raw=f\"cactus-align jobstore/2 input.txt output_{name}.paf {name}.hal --root {name}\",\n+        kind=\"align\",\n+        root=name,\n+        out_files=[f\"{name}.hal\"],\n+        log_file=f\"logs/align-{name}.log\",\n+    )\n+    return Round(\n+        name=name,\n+        root=name,\n+        target_hal=f\"{name}.hal\",\n+        blast_step=blast,\n+        align_step=align,\n+    )\n+\n+\n+def _make_plan(out_seq_path: str) -> Plan:\n+    header = PrepareHeader(\n+        generated_by=\"cactus-prepare tests/tree.txt --outSeqFile tree.txt\",\n+        date=datetime(2024, 1, 1, 0, 0, 0),\n+    )\n+    rounds = [\n+        _make_round(\"N1\"),\n+        _make_round(\"N2\"),\n+        _make_round(\"Root\"),\n+    ]\n+    return Plan(\n+        header=header,\n+        preprocess=[],\n+        rounds=rounds,\n+        hal_merges=[],\n+        out_seq_file=out_seq_path,\n+    )\n+\n+\n+def test_build_alignment_tree(tmp_path) -> None:\n+    out_seq_file = tmp_path / \"tree.txt\"\n+    out_seq_file.write_text(\n+        \"((A:0.1,B:0.2)N1:0.3,(C:0.4,D:0.5)N2:0.6)Root;\\n\",\n+        encoding=\"utf-8\",\n+    )\n+    plan = _make_plan(str(out_seq_file))\n+\n+    tree = tree_utils.build_alignment_tree(plan)\n+    assert tree is not None\n+    assert tree.root.name == \"Root\"\n+    assert tree.root.round is plan.rounds[2]\n+\n+    child_names = sorted(child.name for child in tree.root.children)\n+    assert child_names == [\"N1\", \"N2\"]\n+\n+    node_n1 = tree.find(\"N1\")\n+    assert node_n1 is not None\n+    assert node_n1.round is plan.rounds[0]\n+    leaf_names = sorted(child.name for child in node_n1.children)\n+    assert leaf_names == [\"A\", \"B\"]\n+    assert all(child.round is None for child in node_n1.children)\n+\n+    node_n2 = tree.find(\"N2\")\n+    assert node_n2 is not None\n+    assert node_n2.round is plan.rounds[1]\n+\n+    all_rounds = list(tree.iter_rounds())\n+    assert len(all_rounds) == 3\n+    assert sorted(round_entry.root for round_entry in all_rounds) == sorted(\n+        round_entry.root for round_entry in plan.rounds\n+    )"
      }
    ]
  }
}