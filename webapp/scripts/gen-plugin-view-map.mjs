import fs from 'node:fs';
import path from 'node:path';

function parseSimpleYaml(text) {
  const out = {};
  for (const line of text.split(/\r?\n/)) {
    const s = line.trim();
    if (!s || s.startsWith('#')) continue;
    const idx = s.indexOf(':');
    if (idx === -1) continue;
    const key = s.slice(0, idx).trim();
    let val = s.slice(idx + 1).trim();
    if (!key) continue;
    if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
      val = val.slice(1, -1);
    }
    out[key] = val;
  }
  return out;
}

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function existsFile(p) {
  try {
    return fs.statSync(p).isFile();
  } catch {
    return false;
  }
}

function normalizeTsImport(relPathFromPluginsDir) {
  // We want imports like: ../../plugins/<id>/view/single_repo
  // Input is e.g. "view/single_repo.tsx" or "view/single_repo.ts"
  let p = relPathFromPluginsDir.replace(/\\/g, '/');
  p = p.replace(/\.(tsx|ts|jsx|js)$/i, '');
  return p;
}

const webappDir = path.resolve(process.cwd()); // invoked from webapp/
const repoRoot = path.resolve(webappDir, '..');
const pluginsDir = path.join(repoRoot, 'plugins');

const outDir = path.join(webappDir, 'components', 'generated');
const outFile = path.join(outDir, 'pluginViewMap.ts');
// Import paths in the generated TS file are resolved relative to outDir (webapp/components/generated).
// From there to repoRoot/plugins is ../../../plugins
const importPluginsPrefix = '../../../plugins';

const plugins = [];
if (fs.existsSync(pluginsDir) && fs.statSync(pluginsDir).isDirectory()) {
  for (const name of fs.readdirSync(pluginsDir)) {
    const pluginDir = path.join(pluginsDir, name);
    if (!fs.statSync(pluginDir).isDirectory()) continue;
    const indexYaml = path.join(pluginDir, 'index.yaml');
    if (!existsFile(indexYaml)) continue;
    try {
      const d = parseSimpleYaml(fs.readFileSync(indexYaml, 'utf-8'));
      const pluginId = String(d.id || d.plugin_id || name).trim() || name;
      const viewSingleEntry = String(d.view_single_entry || 'view/single_repo.tsx').trim();
      const viewCompareEntry = String(d.view_compare_entry || 'view/multi_repo_compare.tsx').trim();
      const viewI18nEntry = String(d.view_i18n_entry || 'view/i18n.ts').trim();

      const singleAbs = path.join(pluginDir, viewSingleEntry);
      const compareAbs = path.join(pluginDir, viewCompareEntry);
      const i18nAbs = path.join(pluginDir, viewI18nEntry);

      plugins.push({
        pluginId,
        pluginDirName: name,
        viewSingleEntry,
        viewCompareEntry,
        hasSingle: existsFile(singleAbs),
        hasCompare: existsFile(compareAbs),
        viewI18nEntry,
        hasI18n: existsFile(i18nAbs),
      });
    } catch {
      // skip broken plugin
    }
  }
}

plugins.sort((a, b) => a.pluginId.localeCompare(b.pluginId));

ensureDir(outDir);

const lines = [];
lines.push("/* AUTO-GENERATED by scripts/gen-plugin-view-map.mjs. DO NOT EDIT BY HAND. */");
lines.push("import type React from 'react';");
lines.push("import type { Locale, Messages } from '../../i18n/types';");
lines.push('');
lines.push('export type SingleRepoViewProps = {');
lines.push('  evaluation: unknown;');
lines.push('  title?: string;');
lines.push('  loading?: boolean;');
lines.push('  error?: string;');
lines.push('};');
lines.push('');
lines.push('export type MultiRepoCompareViewProps = {');
lines.push('  data: unknown;');
lines.push('  loading?: boolean;');
lines.push('  error?: string;');
lines.push('};');
lines.push('');
lines.push('export const SINGLE_REPO_VIEW_IMPORTERS: Record<string, () => Promise<{ default: React.ComponentType<SingleRepoViewProps> }>> = {');
for (const p of plugins) {
  if (!p.hasSingle) continue;
  const mod = normalizeTsImport(p.viewSingleEntry);
  lines.push(
    `  ${JSON.stringify(p.pluginId)}: () => import(${JSON.stringify(`${importPluginsPrefix}/${p.pluginDirName}/${mod}`)}),`
  );
}
lines.push('};');
lines.push('');
lines.push(
  'export const MULTI_REPO_COMPARE_VIEW_IMPORTERS: Record<string, () => Promise<{ default: React.ComponentType<MultiRepoCompareViewProps> }>> = {'
);
for (const p of plugins) {
  if (!p.hasCompare) continue;
  const mod = normalizeTsImport(p.viewCompareEntry);
  lines.push(
    `  ${JSON.stringify(p.pluginId)}: () => import(${JSON.stringify(`${importPluginsPrefix}/${p.pluginDirName}/${mod}`)}),`
  );
}
lines.push('};');
lines.push('');

lines.push('export type PluginI18nPack = {');
lines.push('  pluginId?: string;');
lines.push('  messages: Partial<Record<Locale, Messages>>;');
lines.push('};');
lines.push('');
lines.push('export const PLUGIN_I18N_IMPORTERS: Record<string, () => Promise<{ default: PluginI18nPack }>> = {');
for (const p of plugins) {
  if (!p.hasI18n) continue;
  const mod = normalizeTsImport(p.viewI18nEntry);
  lines.push(`  ${JSON.stringify(p.pluginId)}: () => import(${JSON.stringify(`${importPluginsPrefix}/${p.pluginDirName}/${mod}`)}),`);
}
lines.push('};');
lines.push('');

fs.writeFileSync(outFile, lines.join('\n'), 'utf-8');
console.log(`[gen-plugin-view-map] Wrote ${path.relative(webappDir, outFile)} with ${plugins.length} plugins scanned.`);


